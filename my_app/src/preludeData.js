export const preludeFiles = {
  "DATS/CATS/CC/.keeper": ``,
  "DATS/CATS/JS/.keeper": ``,
  "DATS/CATS/JS/NODE/node000.cats": `////////////////////////////////////////////////////////////////////////.
//                                                                    //.
//                         Applied Type System                        //.
//                                                                    //.
////////////////////////////////////////////////////////////////////////.

/*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*/

////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
/*
Author: Hongwei Xi
Sun 01 Sep 2024 08:04:48 AM EDT
Authoremail: gmhwxiATgmailDOTcom
*/
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
const
XATS2JS_NODE_fs =
require('node:fs')
// HX: the same as require('fs')
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_NODE_g_print
  (x0)
{
  let rep = x0.toString();
  process.stdout.write(rep);
  return; // XATS2JS_NODE_g_print
}
//
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_NODE_sint_print
  (i0)
{
  XATS2JS_NODE_g_print(i0);
  return; // XATS2JS_NODE_sint_print
}
//
function
XATS2JS_NODE_uint_print
  (u0)
{
  XATS2JS_NODE_g_print(u0);
  return; // XATS2JS_NODE_uint_print
}
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_NODE_bool_print
  (b0)
{
  XATS2JS_NODE_g_print(b0);
  return; // XATS2JS_NODE_bool_print
}
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_NODE_char_print
  (c0)
{
  let cs =
  String.fromCharCode(c0)
  XATS2JS_NODE_g_print(cs);
  return; // XATS2JS_NODE_char_print
}
//
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_NODE_dflt_print
  (f0)
{
  XATS2JS_NODE_g_print(f0);
  return; // XATS2JS_NODE_dflt_print
}
//
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_NODE_strn_print
  (cs)
{
  XATS2JS_NODE_g_print(cs);
  return; // XATS2JS_NODE_strn_print
}
//
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
// end of [ATS3/XANADU_prelude_DATS_CATS_JS_NODE_node000.cats]
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
`,
  "DATS/CATS/JS/NODE/node000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Sun 01 Sep 2024 07:19:48 AM EDT
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
sint_print<> =
XATS2JS_NODE_sint_print
where
{
#extern
fun
XATS2JS_NODE_sint_print(i0: sint): void = $extnam()
}
//
#impltmp
uint_print<> =
XATS2JS_NODE_uint_print
where
{
#extern
fun
XATS2JS_NODE_uint_print(u0: uint): void = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
bool_print<> =
XATS2JS_NODE_bool_print
where
{
#extern
fun
XATS2JS_NODE_bool_print(b0: bool): void = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
char_print<> =
XATS2JS_NODE_char_print
where
{
#extern
fun
XATS2JS_NODE_char_print(c0: char): void = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
dflt_print<> =
XATS2JS_NODE_dflt_print
where
{
#extern
fun
XATS2JS_NODE_dflt_print(f0: dflt): void = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
strn_print<> =
XATS2JS_NODE_strn_print
where
{
#extern
fun
XATS2JS_NODE_strn_print(cs: strn): void = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)

(* end of [ATS3/XANADU_prelude_DATS_CATS_JS_NODE_node000.dats] *)
`,
  "DATS/CATS/JS/OUTS/.keeper": ``,
  "DATS/CATS/JS/axrf000.cats": `////////////////////////////////////////////////////////////////////////.
//                                                                    //.
//                         Applied Type System                        //.
//                                                                    //.
////////////////////////////////////////////////////////////////////////.

/*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*/

////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
/*
Author: Hongwei Xi
Mon 12 Aug 2024 09:36:59 AM EDT
Authoremail: gmhwxiATgmailDOTcom
*/
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_a0rf_lget
  ( A0 )
{
  return A0[0]
}
function
XATS2JS_a0rf_lset
  (A0, x1)
{
  A0[0] = x1; return
}
//
function
XATS2JS_a0rf_make_1val
  ( x0 )
{
  return [x0] // HX: singleton
}
//
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_a1rf_lget$at
  (A0, i0)
{
  return A0[i0]
}
function
XATS2JS_a1rf_lset$at
  (A0, i0, x1)
{
  A0[i0] = x1; return
}
//
function
XATS2JS_a1rf_make_ncpy
  (n0, x0)
{
  var i0 = 0
  var A0 = new Array(n0);
  while (i0 < n0) {
    A0[i0] = x0; i0 = i0 + 1
  }
  return A0 // HX: A0=[x0, x0, ..., x0]
}
//
function
XATS2JS_a1rf_make_nfun
  (n0, fopr)
{
  var i0 = 0
  var A0 = new Array(n0);
  while (i0 < n0) {
    A0[i0] = fopr(i0); i0 = i0 + 1
  }
  return A0 // HX: A0 = [fopr(0),...,fopr(n-1)]
}
//
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
// end of [ATS3/XANADU_prelude_DATS_CATS_JS_axrf000.cats]
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
`,
  "DATS/CATS/JS/axrf000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Mon 12 Aug 2024 09:36:20 AM EDT
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#absimpl
a0rf_vt_tx
(  a:vt  ) = $extbox("a0rf_tx")
#absimpl
a0rf_vt_vx
(  a:vt  ) = $extbox("a0rf_vx")
//
(* ****** ****** *)
//
#absimpl
a1rf_vt_i0_tx
( a:vt,n:i0 ) = $extbox("a1rf_tx")
#absimpl
a1rf_vt_i0_vx
( a:vt,n:i0 ) = $extbox("a1rf_vx")
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: vt >
a0rf_lget
  ( A ) =
(
XATS2JS_a0rf_lget
  ( A )) where
{
#extern
fun
XATS2JS_a0rf_lget
{a:vt}
( A
: a0rf(a))
: (owed(a) | a) = $extnam()
}
//
#impltmp
< a: vt >
a0rf_lset
(f | A, x) =
(
XATS2JS_a0rf_lset
  (f | A, x)) where
{
#extern
fun
XATS2JS_a0rf_lset
{a:vt}
(f:owed(a)
|A:a0rf(a), x:a): void = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: vt >
a0rf_make_1val
  ( x0 ) =
(
XATS2JS_a0rf_make_1val
  ( x0 )) where
{
#extern
fun
XATS2JS_a0rf_make_1val
{a:vt}( x0: a ): a0rf(a) = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: vt >
a1rf_lget$at
  (A, i) =
(
XATS2JS_a1rf_lget$at
  (A, i)) where
{
#extern
fun
XATS2JS_a1rf_lget$at
{a:vt}
( A
: a1rf(a)
, i: nint): (owed(a) | a) = $extnam()
}
//
#impltmp
< a: vt >
a1rf_lset$at
  (f | A, i, x) =
(
XATS2JS_a1rf_lset$at
  (f | A, i, x)) where
{
#extern
fun
XATS2JS_a1rf_lset$at
{a:vt}
(f:owed(a)
|A:a1rf(a),i:nint,x:a): void = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: t0 >
a1rf_make_ncpy
  (n, x) =
(
XATS2JS_a1rf_make_ncpy
  (n, x)) where
{
#extern
fun
XATS2JS_a1rf_make_ncpy
{a:t0}(n:nint, x:a): a1rf(a) = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
< a: vt >
a1rf_make_nfun
  (n, f) =
(
XATS2JS_a1rf_make_nfun
  (n, f)) where
{
#extern
fun
XATS2JS_a1rf_make_nfun
{a:t0}
(n:nint, f:(nint)->(a)): a1rf(a) = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_CATS_JS_axrf000.dats] *)
(***********************************************************************)
`,
  "DATS/CATS/JS/axsz000.cats": `////////////////////////////////////////////////////////////////////////.
//                                                                    //.
//                         Applied Type System                        //.
//                                                                    //.
////////////////////////////////////////////////////////////////////////.

/*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*/

////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
/*
Author: Hongwei Xi
Thu 15 Aug 2024 01:42:20 PM EDT
Authoremail: gmhwxiATgmailDOTcom
*/
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_a1sz_length
  ( A0 )
{
  return A0.length
}
//
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_a1sz_lget$at
  (A0, i0)
{
  return A0[i0]
}
function
XATS2JS_a1sz_lset$at
  (A0, i0, x1)
{
  A0[i0] = x1; return
}
//
////////////////////////////////////////////////////////////////////////.
/*
HX-2024-09-06:
Fri 06 Sep 2024 04:18:38 PM EDT
*/
//
function
XATS2JS_a1sz_make_none
  ( n0 )
{
  var A0 = new Array(n0)
  return A0 // HX: A0 = [?, ..., ?]
}
////////////////////////////////////////////////////////////////////////.
//
/*
HX-2024-08-15:
Thu 15 Aug 2024 01:50:45 PM EDT
*/
//
function
XATS2JS_a1sz_make_ncpy
  (n0, x0)
{
  var i0 = 0
  var A0 = new Array(n0)
  while (i0 < n0) {
    A0[i0] = x0; i0 = i0 + 1
  }
  return A0 // HX: A0 = [x0, ..., x0]
}
//
function
XATS2JS_a1sz_make_nfun
  (n0, fopr)
{
  var i0 = 0
  var A0 = new Array(n0)
  while (i0 < n0) {
    A0[i0] = fopr(i0); i0 = i0 + 1
  }
  return A0 // HX: A0 = [fopr(0),...,fopr(n-1)]
}
//
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_a1sz_fmake_fwork
  (fwork)
{
  var A0 = []
  fwork((x0) => {A0.push(x0);return}); return A0
}
//
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
// end of [ATS3/XANADU_prelude_DATS_CATS_JS_axsz000.cats]
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
`,
  "DATS/CATS/JS/axsz000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Thu 15 Aug 2024 05:05:45 AM EDT
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#absimpl
a1sz_vt_i0_tx
(a: vt, n: i0) = $extbox("a1sz_tx")
#absimpl
a1sz_vt_i0_vx
(a: vt, n: i0) = $extbox("a1sz_vx")
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: vt >
a1sz_length
 {n:i0}( A ) =
(
XATS2JS_a1sz_length
 {a}{n}( A )) where
{
#extern
fun
XATS2JS_a1sz_length
{a:vt}
{n:i0}
(A: a1sz(a, n)): sint(n) = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: vt >
a1sz_lget$at
  (A, i) =
(
XATS2JS_a1sz_lget$at
  (A, i)) where
{
#extern
fun
XATS2JS_a1sz_lget$at
{a:vt}
( A
: a1sz(a)
, i: nint): (owed(a) | a) = $extnam()
}
//
#impltmp
< a: vt >
a1sz_lset$at
  (f | A, i, x) =
(
XATS2JS_a1sz_lset$at
  (f | A, i, x)) where
{
#extern
fun
XATS2JS_a1sz_lset$at
{a:vt}
(f:owed(a)
|A:a1sz(a),i:nint,x:a): void = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-06:
Fri 06 Sep 2024 03:24:35 PM EDT
*)
//
#impltmp
< x0:t0 >
a1sz_make_none
  ( asz ) =
(
XATS2JS_a1sz_make_none
  ( asz )) where
{
#extern
fun
XATS2JS_a1sz_make_none
{n:nat}
(asz: nint(n)): a1sz(x0, n) = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: t0 >
a1sz_make_ncpy
  (n, x) =
(
XATS2JS_a1sz_make_ncpy
  (n, x)) where
{
#extern
fun
XATS2JS_a1sz_make_ncpy
{a:t0}(n:nint, x:a): a1sz(a) = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
< a: vt >
a1sz_make_nfun
  (n, f) =
(
XATS2JS_a1sz_make_nfun
  (n, f)) where
{
#extern
fun
XATS2JS_a1sz_make_nfun
{a:t0}
(n:nint, f:(nint)->(a)): a1sz(a) = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-17:
Sat 17 Aug 2024 07:33:26 PM EDT
*)
//
#impltmp
< x0:vt >
a1sz_fmake_fwork
  (fwork) =
(
XATS2JS_a1sz_fmake_fwork
  (fwork)) where
{
#extern
fun
XATS2JS_a1sz_fmake_fwork
{ x0:vt }
(
fwork:
((~x0) -> void) -> void): a1sz(x0) = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_CATS_JS_axsz000.dats] *)
(***********************************************************************)
`,
  "DATS/CATS/JS/bool000.cats": `////////////////////////////////////////////////////////////////////////.
//                                                                    //.
//                         Applied Type System                        //.
//                                                                    //.
////////////////////////////////////////////////////////////////////////.

/*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*/

////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
/*
Author: Hongwei Xi
Sun 01 Sep 2024 05:07:38 PM EDT
Authoremail: gmhwxiATgmailDOTcom
*/
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_bool_lt
  (b1, b2)
{
  return (b1 < b2) // HX: lt
}
function
XATS2JS_bool_gt
  (b1, b2)
{
  return (b1 > b2) // HX: gt
}
//
function
XATS2JS_bool_lte
  (b1, b2)
{
  return (b1 <= b2) // HX: lte
}
function
XATS2JS_bool_gte
  (b1, b2)
{
  return (b1 >= b2) // HX: gte
}
//
function
XATS2JS_bool_eq
  (b1, b2)
{
  return (b1 === b2) // HX: equal
}
function
XATS2JS_bool_neq
  (b1, b2)
{
  return (b1 !== b2) // HX: noteq
}
//
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
// end of [ATS3/XANADU_prelude_DATS_CATS_JS_bool000.cats]
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
`,
  "DATS/CATS/JS/bool000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Sun 01 Sep 2024 04:25:37 PM EDT
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
bool_lt
(b1, b2) =
(
XATS2JS_bool_lt
  (b1, b2)) where
{
#extern
fun
XATS2JS_bool_lt
(b1: bool, b2: bool): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
bool_gt
(b1, b2) =
(
XATS2JS_bool_gt
  (b1, b2)) where
{
#extern
fun
XATS2JS_bool_gt
(b1: bool, b2: bool): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
bool_eq
(b1, b2) =
(
XATS2JS_bool_eq
  (b1, b2)) where
{
#extern
fun
XATS2JS_bool_eq
(b1: bool, b2: bool): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
bool_lte
(b1, b2) =
(
XATS2JS_bool_lte
  (b1, b2)) where
{
#extern
fun
XATS2JS_bool_lte
(b1: bool, b2: bool): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
bool_gte
(b1, b2) =
(
XATS2JS_bool_gte
  (b1, b2)) where
{
#extern
fun
XATS2JS_bool_gte
(b1: bool, b2: bool): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
bool_neq
(b1, b2) =
(
XATS2JS_bool_neq
  (b1, b2)) where
{
#extern
fun
XATS2JS_bool_neq
(b1: bool, b2: bool): bool = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-05:
Thu 05 Sep 2024 11:11:27 AM EDT
*)
//
#impltmp
<(*tmp*)>
bool_print(b0) =
(
if b0
then strn_print<>("true")
else strn_print<>("false"))//end(impl)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_CATS_JS_bool000.dats] *)
(***********************************************************************)
`,
  "DATS/CATS/JS/char000.cats": `////////////////////////////////////////////////////////////////////////.
//                                                                    //.
//                         Applied Type System                        //.
//                                                                    //.
////////////////////////////////////////////////////////////////////////.

/*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*/

////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
/*
Author: Hongwei Xi
Sun 01 Sep 2024 05:08:01 PM EDT
Authoremail: gmhwxiATgmailDOTcom
*/
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_char_lt
  (c1, c2)
{
  return (c1 < c2) // HX: lt
}
function
XATS2JS_char_gt
  (c1, c2)
{
  return (c1 > c2) // HX: gt
}
//
function
XATS2JS_char_lte
  (c1, c2)
{
  return (c1 <= c2) // HX: lte
}
function
XATS2JS_char_gte
  (c1, c2)
{
  return (c1 >= c2) // HX: gte
}
//
function
XATS2JS_char_eq
  (c1, c2)
{
  return (c1 === c2) // HX: equal
}
function
XATS2JS_char_neq
  (c1, c2)
{
  return (c1 !== c2) // HX: noteq
}
//
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_char_add$sint
  (c1, i2)
{
  let c2 = c1+i2
  return (c2%256) // HX: char=int8
}
//
function
XATS2JS_char_sub$char
  (c1, c2)
{
  return (c1 - c2) // HX: char=int8
}
//
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_char_print
  ( c0 )
{
  let cs = String.fromCharCode(c0)
  XATS2JS_the_print_store.push(cs); return
}
//
////////////////////////////////////////////////////////////////////////.
//
/*
HX-2025-01-10:
Taken from gavinz
Sun Jan 19 01:11:19 AM EST 2025
*/
function
XATS2JS_char_make_sint( i0 ) { return i0 }
//
/*
HX-2026-01-15:
Thu Jan 15 06:47:03 PM EST 2026
*/
function
XATS2JS_sint_make_char( ch ) { return ch }
//
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
// end of [ATS3/XANADU_prelude_DATS_CATS_JS_char000.cats]
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
`,
  "DATS/CATS/JS/char000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Sun 01 Sep 2024 04:48:38 PM EDT
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
char_lt
(c1, c2) =
(
XATS2JS_char_lt
  (c1, c2)) where
{
#extern
fun
XATS2JS_char_lt
(c1: char, c2: char): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
char_gt
(c1, c2) =
(
XATS2JS_char_gt
  (c1, c2)) where
{
#extern
fun
XATS2JS_char_gt
(c1: char, c2: char): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
char_eq
(c1, c2) =
(
XATS2JS_char_eq
  (c1, c2)) where
{
#extern
fun
XATS2JS_char_eq
(c1: char, c2: char): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
char_lte
(c1, c2) =
(
XATS2JS_char_lte
  (c1, c2)) where
{
#extern
fun
XATS2JS_char_lte
(c1: char, c2: char): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
char_gte
(c1, c2) =
(
XATS2JS_char_gte
  (c1, c2)) where
{
#extern
fun
XATS2JS_char_gte
(c1: char, c2: char): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
char_neq
(c1, c2) =
(
XATS2JS_char_neq
  (c1, c2)) where
{
#extern
fun
XATS2JS_char_neq
(c1: char, c2: char): bool = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
char_add$sint
  (c1, i2) =
(
XATS2JS_char_add$sint
  (c1, i2)) where
{
#extern
fun
XATS2JS_char_add$sint
(c1: char, i2: sint): char = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
char_sub$char
  (c1, c2) =
(
XATS2JS_char_sub$char
  (c1, c2)) where
{
#extern
fun
XATS2JS_char_sub$char
(c1: char, c2: char): sint = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-05:
Thu 05 Sep 2024 11:11:27 AM EDT
*)
//
#impltmp
<(*tmp*)>
char_print
  ( c0 ) =
(
XATS2JS_char_print
  ( c0 )) where
{
#extern
fun
XATS2JS_char_print(c0: char): void = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
(*
HX-2026-01-15:
Thu Jan 15 06:39:48 PM EST 2026
*)
#impltmp
<(*tmp*)>
sint_make_char(ch) =
(
XATS2JS_sint_make_char(ch))
where
{
#extern
fun
XATS2JS_sint_make_char(ch: char): sint = $extnam()
}
(* ****** ****** *)
//
(*
HX-2025-01-19: from gavinz
Sun Jan 19 01:11:19 AM EST 2025
*)
#impltmp
<(*tmp*)>
char_make_sint(i0) =
(
XATS2JS_char_make_sint(i0))
where
{
#extern
fun
XATS2JS_char_make_sint(i0: sint): char = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_CATS_JS_char000.dats] *)
(***********************************************************************)
`,
  "DATS/CATS/JS/gbas000.cats": `////////////////////////////////////////////////////////////////////////.
//                                                                    //.
//                         Applied Type System                        //.
//                                                                    //.
////////////////////////////////////////////////////////////////////////.

/*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*/

////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
/*
Author: Hongwei Xi
Mon 09 Sep 2024 09:31:27 AM EDT
Authoremail: gmhwxiATgmailDOTcom
*/
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_g_tostr
  ( obj )
{
  return String(obj) }
//
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_strn_sint$parse$fwork
  (rep0, work)
{
  let i0 = parseInt(rep0)
  if (!isNaN(i0)) { work(i0) }; return
}
//
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_strn_dflt$parse$fwork
  (rep0, work)
{
  let f0 = parseFloat(rep0)
  if (!isNaN(f0)) { work(f0) }; return
}
//
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
// end of [ATS3/XANADU_prelude_DATS_CATS_JS_gbas000.cats]
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
`,
  "DATS/CATS/JS/gbas000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Mon 09 Sep 2024 08:48:13 AM EDT
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
g_tostr<x0>(x0) =
(
XATS2JS_g_tostr(x0)
) where
{
#extern
fun
XATS2JS_g_tostr
{x0:t0}(x0: x0): strn = $extnam()
}(*where*)//end-of-[g_tostr<x0>(x0)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#extern
fun<>
strn_sint$parse$fwork
( rep0: strn
, work: (sint)->void): void
//
#impltmp
g_parse$opt
< sint >
( rep0 ) =
list_head$opt
(
list_fmake_fwork
(
lam(work) =>
strn_sint$parse$fwork(rep0, work)))
//
#impltmp
<(*tmp*)>
strn_sint$parse$fwork
  (rep0, work) =
(
XATS2JS_strn_sint$parse$fwork
  (rep0, work)) where
{
#extern
fun
XATS2JS_strn_sint$parse$fwork
(rep0: strn, work:(sint)->void): void = $extnam()
}
//
(* ****** ****** *)
//
#extern
fun<>
strn_dflt$parse$fwork
( rep0: strn
, work: (dflt)->void): void
//
#impltmp
g_parse$opt
< dflt >
( rep0 ) =
list_head$opt
(
list_fmake_fwork
(
lam(work) =>
strn_dflt$parse$fwork(rep0, work)))
//
#impltmp
<(*tmp*)>
strn_dflt$parse$fwork
  (rep0, work) =
(
XATS2JS_strn_dflt$parse$fwork
  (rep0, work)) where
{
#extern
fun
XATS2JS_strn_dflt$parse$fwork
(rep0: strn, work:(dflt)->void): void = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_CATS_JS_gbas000.dats] *)
(***********************************************************************)
`,
  "DATS/CATS/JS/gdbg000.cats": `////////////////////////////////////////////////////////////////////////.
//                                                                    //.
//                         Applied Type System                        //.
//                                                                    //.
////////////////////////////////////////////////////////////////////////.

/*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*/

////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
/*
Author: Hongwei Xi
Fri Sep 20 09:05:02 AM EDT 2024
Authoremail: gmhwxiATgmailDOTcom
*/
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_bool_assert$errmsg
  (cond, emsg)
{
  if (!cond) {
    throw new Error("XATS2JS_bool_assert$errmsg: emsg = " + emsg)
  } ; return // HX: void is returned!
}
//
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
// end of [ATS3/XANADU_prelude_DATS_CATS_JS_gdbg000.cats]
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
`,
  "DATS/CATS/JS/gdbg000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Fri Sep 20 08:59:26 AM EDT 2024
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
bool_assert$errmsg
  (cond, emsg) =
(
XATS2JS_bool_assert$errmsg
  (cond, emsg)) where
{
#extern
fun
XATS2JS_bool_assert$errmsg
(cond: bool, emsg: strn): void = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_CATS_JS_gdbg000.dats] *)
(***********************************************************************)
`,
  "DATS/CATS/JS/gflt000.cats": `////////////////////////////////////////////////////////////////////////.
//                                                                    //.
//                         Applied Type System                        //.
//                                                                    //.
////////////////////////////////////////////////////////////////////////.

/*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*/

////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
/*
Author: Hongwei Xi
Mon 09 Sep 2024 06:14:11 PM EDT
Authoremail: gmhwxiATgmailDOTcom
*/
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_dflt_neg
  ( df )
{
  return ( -df ) //HX:neg
}
//
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_dflt_abs
  ( df )
{
  if (df >= 0.0)
    return df
  else
    return (-df) //HX:abs
}
//
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_dflt_sqrt
  ( df )
{
  return Math.sqrt(  df  )
}
//
function
XATS2JS_dflt_cbrt
  ( df )
{
  return Math.cbrt(  df  )
}
//
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_dflt_lt$dflt
  (f1, f2)
{
  return (f1 < f2) // HX: lt
}
function
XATS2JS_dflt_gt$dflt
  (f1, f2)
{
  return (f1 > f2) // HX: gt
}
//
function
XATS2JS_dflt_lte$dflt
  (f1, f2)
{
  return (f1 <= f2) // HX: lte
}
function
XATS2JS_dflt_gte$dflt
  (f1, f2)
{
  return (f1 >= f2) // HX: gte
}
//
function
XATS2JS_dflt_eq$dflt
  (f1, f2)
{
  return (f1 === f2) // HX: eq
}
function
XATS2JS_dflt_neq$dflt
  (f1, f2)
{
  return (f1 !== f2) // HX: neq
}
//
/*
HX-2025-12-13:
Sat Dec 13 05:19:31 PM EST 2025
*/
//
function
XATS2JS_dflt_cmp$dflt
  (f1, f2)
{
  if (f1 < f2)
    return (-1) // lt
  else // f1 >= f2
    return (f1 > f2 ? 1 : 0)
  // HX: end-of-if( f1 < f2 )
}
//
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_dflt_add$dflt
  (f1, f2)
{
  return (f1 + f2) // HX: add
}
//
function
XATS2JS_dflt_sub$dflt
  (f1, f2)
{
  return (f1 - f2) // HX: sub
}
//
//
function
XATS2JS_dflt_mul$dflt
  (f1, f2)
{
  return (f1 * f2) // HX: mul
}
//
function
XATS2JS_dflt_div$dflt
  (f1, f2)
{
  return (f1 / f2) // HX: div
}
//
function
XATS2JS_dflt_mod$dflt
  (f1, f2)
{
  return (f1 % f2) // HX: mod
}
//
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_dflt_ceil
  ( df )
{
  return Math.ceil(df) // (1.2) = 2
}
function
XATS2JS_dflt_floor
  ( df )
{
  return Math.floor(df) // (1.2) = 1
}
function
XATS2JS_dflt_round
  ( df )
{
  // HX: (1.2) = 1 // (1.5) = 2
  return Math.round(df) // (-1.5) = 1
}
function
XATS2JS_dflt_trunc
  ( df )
{
  // HX: (1.2) = 1 // (1.9) = 1
  return Math.trunc(df) // (-1.2) = -1
}
//
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_dflt_print
  ( f0 )
{
  let cs = f0.toString()
  XATS2JS_the_print_store.push(cs); return
}
//
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
// end of [ATS3/XANADU_prelude_DATS_CATS_JS_gflt000.cats]
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
`,
  "DATS/CATS/JS/gflt000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Mon 09 Sep 2024 06:12:39 PM EDT
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
g_si<dflt>
  ( i1 ) =
(
XATS2JS_si2dflt
  ( i1 )) where
{
#extern
fcast
XATS2JS_si2dflt
(i1: sint): dflt = $extnam() }
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
dflt_neg
  ( f1 ) =
(
XATS2JS_dflt_neg
  ( f1 )) where
{
#extern
fun
XATS2JS_dflt_neg
(f1: dflt): dflt = $extnam() }
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
dflt_abs
  ( f1 ) =
(
XATS2JS_dflt_abs
  ( f1 )) where
{
#extern
fun
XATS2JS_dflt_abs
(f1: dflt): dflt = $extnam() }
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
dflt_sqrt
  ( f1 ) =
(
XATS2JS_dflt_sqrt
  ( f1 )) where
{
#extern
fun
XATS2JS_dflt_sqrt
(f1: dflt): dflt = $extnam() }
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
dflt_cbrt
  ( f1 ) =
(
XATS2JS_dflt_cbrt
  ( f1 )) where
{
#extern
fun
XATS2JS_dflt_cbrt
(f1: dflt): dflt = $extnam() }
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
dflt_lt$dflt
  (f1, f2) =
(
XATS2JS_dflt_lt$dflt
  (f1, f2)) where
{
#extern
fun
XATS2JS_dflt_lt$dflt
(f1: dflt, f2: dflt): bool = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_gt$dflt
  (f1, f2) =
(
XATS2JS_dflt_gt$dflt
  (f1, f2)) where
{
#extern
fun
XATS2JS_dflt_gt$dflt
(f1: dflt, f2: dflt): bool = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_eq$dflt
  (f1, f2) =
(
XATS2JS_dflt_eq$dflt
  (f1, f2)) where
{
#extern
fun
XATS2JS_dflt_eq$dflt
(f1: dflt, f2: dflt): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
dflt_lte$dflt
  (f1, f2) =
(
XATS2JS_dflt_lte$dflt
  (f1, f2)) where
{
#extern
fun
XATS2JS_dflt_lte$dflt
(f1: dflt, f2: dflt): bool = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_gte$dflt
  (f1, f2) =
(
XATS2JS_dflt_gte$dflt
  (f1, f2)) where
{
#extern
fun
XATS2JS_dflt_gte$dflt
(f1: dflt, f2: dflt): bool = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_neq$dflt
  (f1, f2) =
(
XATS2JS_dflt_neq$dflt
  (f1, f2)) where
{
#extern
fun
XATS2JS_dflt_neq$dflt
(f1: dflt, f2: dflt): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
dflt_cmp$dflt
  (f1, f2) =
(
XATS2JS_dflt_cmp$dflt
  (f1, f2)) where
{
#extern
fun
XATS2JS_dflt_cmp$dflt
(f1: dflt, f2: dflt): sint = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
dflt_add$dflt
  (f1, f2) =
(
XATS2JS_dflt_add$dflt
  (f1, f2)) where
{
#extern
fun
XATS2JS_dflt_add$dflt
(f1: dflt, f2: dflt): dflt = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_sub$dflt
  (f1, f2) =
(
XATS2JS_dflt_sub$dflt
  (f1, f2)) where
{
#extern
fun
XATS2JS_dflt_sub$dflt
(f1: dflt, f2: dflt): dflt = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_mul$dflt
  (f1, f2) =
(
XATS2JS_dflt_mul$dflt
  (f1, f2)) where
{
#extern
fun
XATS2JS_dflt_mul$dflt
(f1: dflt, f2: dflt): dflt = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_div$dflt
  (f1, f2) =
(
XATS2JS_dflt_div$dflt
  (f1, f2)) where
{
#extern
fun
XATS2JS_dflt_div$dflt
(f1: dflt, f2: dflt): dflt = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_mod$dflt
  (f1, f2) =
(
XATS2JS_dflt_mod$dflt
  (f1, f2)) where
{
#extern
fun
XATS2JS_dflt_mod$dflt
(f1: dflt, f2: dflt): dflt = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-05:
Mon 09 Sep 2024 06:13:03 PM EDT
*)
//
#impltmp
<(*tmp*)>
dflt_print
  ( f0 ) =
(
XATS2JS_dflt_print
  ( f0 )) where
{
#extern
fun
XATS2JS_dflt_print(f0: dflt): void = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-21:
Sat Sep 21 03:31:11 PM EDT 2024
*)
//
#impltmp
<(*tmp*)>
dflt_ceil
  ( df ) =
(
XATS2JS_dflt_ceil
  ( df )) where
{
#extern
fun
XATS2JS_dflt_ceil(df: dflt): dflt = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_floor
  ( df ) =
(
XATS2JS_dflt_floor
  ( df )) where
{
#extern
fun
XATS2JS_dflt_floor(df: dflt): dflt = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_round
  ( df ) =
(
XATS2JS_dflt_round
  ( df )) where
{
#extern
fun
XATS2JS_dflt_round(df: dflt): dflt = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_trunc
  ( df ) =
(
XATS2JS_dflt_trunc
  ( df )) where
{
#extern
fun
XATS2JS_dflt_trunc(df: dflt): dflt = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_CATS_JS_gint000.dats] *)
(***********************************************************************)
`,
  "DATS/CATS/JS/gint000.cats": `////////////////////////////////////////////////////////////////////////.
//                                                                    //.
//                         Applied Type System                        //.
//                                                                    //.
////////////////////////////////////////////////////////////////////////.

/*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*/

////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
/*
Author: Hongwei Xi
Sun 01 Sep 2024 04:27:52 PM EDT
Authoremail: gmhwxiATgmailDOTcom
*/
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_sint_neg
  ( i1 )
{
  return ( -i1 ) // HX: neg
}
//
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_sint_lt$sint
  (i1, i2)
{
  return (i1 < i2) // HX: lt
}
function
XATS2JS_sint_gt$sint
  (i1, i2)
{
  return (i1 > i2) // HX: gt
}
//
function
XATS2JS_sint_lte$sint
  (i1, i2)
{
  return (i1 <= i2) // HX: lte
}
function
XATS2JS_sint_gte$sint
  (i1, i2)
{
  return (i1 >= i2) // HX: gte
}
//
function
XATS2JS_sint_eq$sint
  (i1, i2)
{
  return (i1 === i2) // HX: equal
}
function
XATS2JS_sint_neq$sint
  (i1, i2)
{
  return (i1 !== i2) // HX: noteq
}
//
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_sint_add$sint
  (i1, i2)
{
  return (i1 + i2) // HX: add
}
//
function
XATS2JS_sint_sub$sint
  (i1, i2)
{
  return (i1 - i2) // HX: sub
}
//
function
XATS2JS_sint_mul$sint
  (i1, i2)
{
  return (i1 * i2) // HX: mul
}
//
function
XATS2JS_sint_div$sint
  (i1, i2)
{
  return Math.trunc(i1 / i2)
}
//
function
XATS2JS_sint_mod$sint
  (i1, i2)
{
  return (i1 % i2) // HX: mod
}
//
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_sint_print
  ( i0 )
{
  let cs = i0.toString()
  XATS2JS_the_print_store.push(cs); return
}
//
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
//
// HX-2025-09-27:
// for unsigned ints
// Sat Sep 27 12:38:38 PM EDT 2025
//
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_uint_print
  ( u0 )
{
  let cs = u0.toString()
  XATS2JS_the_print_store.push(cs); return
}
//
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_sint_to$uint
  ( i0 )
{
  if (i0>=0)
  {
    return i0 // i0>=0
  } else {
    throw new Error("XATS2JS_sint_to$uint: i0 = " + i0.toString())
  } // end of [if(i0>=0)]
}
function
XATS2JS_uint_to$sint
  ( u0 )
{
  if (u0>=0)
  {
    return u0 // always?
  } else {
    throw new Error("XATS2JS_uint_to$sint: u0 = " + u0.toString())
  } // end of [if(u0>=0)]
}
//
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
// end of [ATS3/XANADU_prelude_DATS_CATS_JS_gint000.cats]
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
`,
  "DATS/CATS/JS/gint000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Sun 01 Sep 2024 04:25:37 PM EDT
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
sint_neg
  ( i1 ) =
(
XATS2JS_sint_neg
  ( i1 )) where
{
#extern
fun
XATS2JS_sint_neg
(i1: sint): sint = $extnam() }
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
sint_lt$sint
  (i1, i2) =
(
XATS2JS_sint_lt$sint
  (i1, i2)) where
{
#extern
fun
XATS2JS_sint_lt$sint
(i1: sint, i2: sint): bool = $extnam()
}
//
#impltmp
<(*tmp*)>
sint_gt$sint
  (i1, i2) =
(
XATS2JS_sint_gt$sint
  (i1, i2)) where
{
#extern
fun
XATS2JS_sint_gt$sint
(i1: sint, i2: sint): bool = $extnam()
}
//
#impltmp
<(*tmp*)>
sint_eq$sint
  (i1, i2) =
(
XATS2JS_sint_eq$sint
  (i1, i2)) where
{
#extern
fun
XATS2JS_sint_eq$sint
(i1: sint, i2: sint): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
sint_lte$sint
  (i1, i2) =
(
XATS2JS_sint_lte$sint
  (i1, i2)) where
{
#extern
fun
XATS2JS_sint_lte$sint
(i1: sint, i2: sint): bool = $extnam()
}
//
#impltmp
<(*tmp*)>
sint_gte$sint
  (i1, i2) =
(
XATS2JS_sint_gte$sint
  (i1, i2)) where
{
#extern
fun
XATS2JS_sint_gte$sint
(i1: sint, i2: sint): bool = $extnam()
}
//
#impltmp
<(*tmp*)>
sint_neq$sint
  (i1, i2) =
(
XATS2JS_sint_neq$sint
  (i1, i2)) where
{
#extern
fun
XATS2JS_sint_neq$sint
(i1: sint, i2: sint): bool = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
sint_add$sint
  (i1, i2) =
(
XATS2JS_sint_add$sint
  (i1, i2)) where
{
#extern
fun
XATS2JS_sint_add$sint
(i1: sint, i2: sint): sint = $extnam()
}
//
#impltmp
<(*tmp*)>
sint_sub$sint
  (i1, i2) =
(
XATS2JS_sint_sub$sint
  (i1, i2)) where
{
#extern
fun
XATS2JS_sint_sub$sint
(i1: sint, i2: sint): sint = $extnam()
}
//
#impltmp
<(*tmp*)>
sint_mul$sint
  (i1, i2) =
(
XATS2JS_sint_mul$sint
  (i1, i2)) where
{
#extern
fun
XATS2JS_sint_mul$sint
(i1: sint, i2: sint): sint = $extnam()
}
//
#impltmp
<(*tmp*)>
sint_div$sint
  (i1, i2) =
(
XATS2JS_sint_div$sint
  (i1, i2)) where
{
#extern
fun
XATS2JS_sint_div$sint
(i1: sint, i2: sint): sint = $extnam()
}
//
#impltmp
<(*tmp*)>
sint_mod$sint
  (i1, i2) =
(
XATS2JS_sint_mod$sint
  (i1, i2)) where
{
#extern
fun
XATS2JS_sint_mod$sint
(i1: sint, i2: sint): sint = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-05:
Thu 05 Sep 2024 11:11:27 AM EDT
*)
//
#impltmp
<(*tmp*)>
sint_print
  ( i0 ) =
(
XATS2JS_sint_print
  ( i0 )) where
{
#extern
fun
XATS2JS_sint_print(i0: sint): void = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-09-27:
For unsigned ints
Sat Sep 27 12:16:41 PM EDT 2025
*)
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
sint_to$uint
  ( i0 ) =
(
XATS2JS_sint_to$uint
  ( i0 )) where
{
#extern
fun
XATS2JS_sint_to$uint
  (i0: sint): uint = $extnam() }
//
#impltmp
<(*tmp*)>
uint_to$sint
  ( u0 ) =
(
XATS2JS_uint_to$sint
  ( u0 )) where
{
#extern
fun
XATS2JS_uint_to$sint
  (u0: uint): sint = $extnam() }
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
uint_print
  ( u0 ) =
(
XATS2JS_uint_print
  ( u0 )) where
{
#extern
fun
XATS2JS_uint_print(u0: uint): void = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
uint_pre(u0) =
XATS2JS_uint_pre(u0) where
{ #extern
  fun
  XATS2JS_uint_pre(u0: uint): uint = $extnam() }
//
#impltmp
<(*tmp*)>
uint_suc(u0) =
XATS2JS_uint_suc(u0) where
{ #extern
  fun
  XATS2JS_uint_suc(u0: uint): uint = $extnam() }
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
uint_lnot(u0) =
XATS2JS_uint_lnot(u0) where
{ #extern
  fun
  XATS2JS_uint_lnot(u0: uint): uint = $extnam() }
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
uint_ladd
  (u1, u2) =
(
XATS2JS_uint_ladd
  (u1, u2)) where
{
#extern
fun
XATS2JS_uint_ladd(u1: uint, u2: uint): uint = $extnam()
}
//
#impltmp
<(*tmp*)>
uint_lmul
  (u1, u2) =
(
XATS2JS_uint_lmul
  (u1, u2)) where
{
#extern
fun
XATS2JS_uint_lmul(u1: uint, u2: uint): uint = $extnam()
}
//
#impltmp
<(*tmp*)>
uint_lneq
  (u1, u2) =
(
XATS2JS_uint_lneq
  (u1, u2)) where
{
#extern
fun
XATS2JS_uint_lneq(u1: uint, u2: uint): uint = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_CATS_JS_gint000.dats] *)
(***********************************************************************)
`,
  "DATS/CATS/JS/list000.cats": `////////////////////////////////////////////////////////////////////////.
//                                                                    //.
//                         Applied Type System                        //.
//                                                                    //.
////////////////////////////////////////////////////////////////////////.

/*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2026 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*/

////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
/*
Author: Hongwei Xi
Fri Jan  2 03:23:26 PM EST 2026
Authoremail: gmhwxiATgmailDOTcom
*/
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_list_vt_foritm0$f1un
  (xs, work)
{
  let nilq1 =
    XATS2JS_list_vt_nilq1
  while (1) {
    if (nilq1(xs)) {
      break;
    } else {
      let x1 =
        XATS2JS_list_vt_head$raw1(xs)
      work(x1)
      xs = XATS2JS_list_vt_tail$raw0(xs)
    }
  }
  return // XATS2JS_list_vt_foritm0$f1un
}
//
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_list_vt_forall0$f1un
  (xs, test, free)
{
  let nilq1 =
    XATS2JS_list_vt_nilq1
  while (1) {
    if (nilq1(xs)) {
      break;
    } else {
      let x1 =
        XATS2JS_list_vt_head$raw1(xs)
      if (test(x1)) {
        xs = XATS2JS_list_vt_tail$raw0(xs)
      } else {
        xs = XATS2JS_list_vt_tail$raw0(xs)
        XATS2JS_list_vt_foritm0$f1un(xs, free); return false
      }
    }
  }
  return true // XATS2JS_list_vt_forall0$f1un
}
//
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
// end of [ATS3/XANADU_prelude_DATS_CATS_JS_list000.cats]
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
`,
  "DATS/CATS/JS/list000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2026 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Fri Jan  2 01:41:33 PM EST 2026
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#extern
fun
XATS2JS_list_vt_foritm0$f1un
{x0:vt}
( xs
: list_vt(x0)
, work
: (~x0) -> void): void
= $extnam()//extern(./list000.cats)
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
list_vt_foritm0
  (  xs  ) =
let
fun
work(x0: ~x0): void =
(
  foritm$work0<x0>(x0))
in//let
XATS2JS_list_vt_foritm0$f1un{x0}(xs, work)
end(*let*)//end-of-[ list_vt_foritm0<x0>(xs) ]
//
(* ****** ****** *)
(* ****** ****** *)
//
#extern
fun
XATS2JS_list_vt_forall0$f1un
{x0:vt}
( xs
: list_vt(x0)
, test
: (~x0) -> bool
, free
: (~x0) -> void): bool
= $extnam()//extern(./list000.cats)
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
list_vt_forall0
  (  xs  ) =
let
fun
test(x0: ~x0): bool =
(
  forall$test0<x0>(x0))
fun
free(x0: ~x0): void = g_free<x0>(x0)
in//let
XATS2JS_list_vt_forall0$f1un{x0}(xs, test, free)
end(*let*)//end-of-[list_vt_forall0<x0>(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_CATS_JS_list000.dats] *)
(***********************************************************************)
`,
  "DATS/CATS/JS/optn000.cats": `////////////////////////////////////////////////////////////////////////.
//                                                                    //.
//                         Applied Type System                        //.
//                                                                    //.
////////////////////////////////////////////////////////////////////////.

/*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2026 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*/

////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
/*
Author: Hongwei Xi
Fri Jan  2 03:23:26 PM EST 2026
Authoremail: gmhwxiATgmailDOTcom
*/
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
//
// HX: It is yet to be populated!
//
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
// end of [ATS3/XANADU_prelude_DATS_CATS_JS_optn000.cats]
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
`,
  "DATS/CATS/JS/optn000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2026 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Fri Jan  2 01:41:33 PM EST 2026
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_CATS_JS_optn000.dats] *)
(***********************************************************************)
`,
  "DATS/CATS/JS/precats.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2026 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Fri Jan  2 01:41:33 PM EST 2026
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-02:
For implementing operations
in JS that can be called in ATS.
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
//
(*
HX-2026-01-02:
Already inside
[xats2js_js1emit.js]!
*)
//
#extern
fun
XATS2JS_optn_nil
{a:t0}
((*0*)): optn(a) = $extnam()
#implfun
XATS2JS_optn_nil() = optn_nil()
#extern
fun
XATS2JS_optn_cons
{a:t0}
(x0: a): optn(a) = $extnam()
#implfun
XATS2JS_optn_cons(x0) = optn_cons(x0)
//
*)
//
(* ****** ****** *)
//
#extern
fun
XATS2JS_optn_nilq
{a:t0}
( xs
: optn(a)): bool = $extnam()
#implfun
XATS2JS_optn_nilq(xs) =
(
case+ xs of
|optn_nil() => true |optn_cons _ => false)
//
#extern
fun
XATS2JS_optn_consq
{a:t0}
( xs
: optn(a)): bool = $extnam()
#implfun
XATS2JS_optn_consq(xs) =
(
case+ xs of
|optn_nil() => false |optn_cons _ => (true))
//
(* ****** ****** *)
//
#extern
fun
XATS2JS_optn_head$raw
{a:t0}
( xs
: optn(a)): (a) = $extnam()
#implfun
XATS2JS_optn_head$raw(xs) =
(
case- xs of optn_cons(x0) => (x0))
//
#extern
fun
XATS2JS_optn_uncons$raw
{a:t0}
( xs
: optn(a)): (a) = $extnam()
#implfun
XATS2JS_optn_uncons$raw(xs) =
(
case- xs of optn_cons(x0) => (x0))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
//
(*
HX-2026-01-02:
Already inside
[xats2js_js1emit.js]!
*)
//
#extern
fun
XATS2JS_list_nil
{a:t0}
((*0*)): list(a) = $extnam()
#implfun
XATS2JS_list_nil() = list_nil()
#extern
fun
XATS2JS_list_cons
{a:t0}
( x1: a//head
, xs: list(a)): list(a) = $extnam()
#implfun
XATS2JS_list_cons(x1,xs) = list_cons(x1,xs)
//
*)
//
(* ****** ****** *)
//
#extern
fun
XATS2JS_list_nilq
{a:t0}
( xs
: list(a)): bool = $extnam()
#implfun
XATS2JS_list_nilq(xs) =
(
case+ xs of
|list_nil() => true |list_cons _ => false)
//
#extern
fun
XATS2JS_list_consq
{a:t0}
( xs
: list(a)): bool = $extnam()
#implfun
XATS2JS_list_consq(xs) =
(
case+ xs of
|list_nil() => false |list_cons _ => (true))
//
(* ****** ****** *)
//
#extern
fun
XATS2JS_list_head$raw
{a:t0}
( xs
: list(a)): (a) = $extnam()
#implfun
XATS2JS_list_head$raw(xs) =
(
case- xs of list_cons(x1, xs) => (x1))
//
(* ****** ****** *)
(* ****** ****** *)
//
#extern
fun
XATS2JS_lazy_make_f0un
{a:t0}
( f0
: ()->(a)): lazy(a) = $extnam()
#implfun
XATS2JS_lazy_make_f0un(f0) = $lazy(f0())
//
(* ****** ****** *)
(* ****** ****** *)
//
#extern
fun
XATS2JS_strmcon_nil
{a:t0}
((*0*)): strmcon(a) = $extnam()
#implfun
XATS2JS_strmcon_nil() = strmcon_nil()
//
#extern
fun
XATS2JS_strmcon_cons
{a:t0}
(x1: a//head
,xs: strm(a)): strmcon(a) = $extnam()
#implfun
XATS2JS_strmcon_cons(x1,xs) = strmcon_cons(x1,xs)
//
#extern
fun
XATS2JS_strxcon_cons
{a:t0}
(x1: a//head
,xs: strx(a)): strxcon(a) = $extnam()
#implfun
XATS2JS_strxcon_cons(x1,xs) = strxcon_cons(x1,xs)
//
(* ****** ****** *)
//
#extern
fun
XATS2JS_strmcon_nilq
{a:t0}
( xs
: strmcon(a)): bool = $extnam()
#implfun
XATS2JS_strmcon_nilq(xs) =
(
case+ xs of
|strmcon_nil() => true |strmcon_cons _ => false)
//
#extern
fun
XATS2JS_strmcon_consq
{a:t0}
( xs
: strmcon(a)): bool = $extnam()
#implfun
XATS2JS_strmcon_consq(xs) =
(
case+ xs of
|strmcon_nil() => false |strmcon_cons _ => (true))
//
(* ****** ****** *)
//
#extern
fun
XATS2JS_strmcon_head$raw
{a:t0}
( xs
: strmcon(a)): (a) = $extnam()
#implfun
XATS2JS_strmcon_head$raw(xs) =
(
case- xs of strmcon_cons(x1, xs) => (x1))
//
#extern
fun
XATS2JS_strmcon_tail$raw
{a:t0}
( xs
: strmcon(a)): strm(a) = $extnam()
#implfun
XATS2JS_strmcon_tail$raw(xs) =
(
case- xs of strmcon_cons(x1, xs) => (xs))
//
(* ****** ****** *)
//
#extern
fun
(*
HX: no failure!
*)
XATS2JS_strxcon_head$raw
{a:t0}
( xs
: strxcon(a)): (a) = $extnam()
#implfun
XATS2JS_strxcon_head$raw(xs) =
(
case+ xs of strxcon_cons(x1, xs) => (x1))
//
#extern
fun
(*
HX: no failure!
*)
XATS2JS_strxcon_tail$raw
{a:t0}
( xs
: strxcon(a)): strx(a) = $extnam()
#implfun
XATS2JS_strxcon_tail$raw(xs) =
(
case+ xs of strxcon_cons(x1, xs) => (xs))
//
(* ****** ****** *)
(* ****** ****** *)
(*
HX-2026-01-02: For VT!
*)
(* ****** ****** *)
(* ****** ****** *)
//
(*
//
(*
HX-2026-01-02:
Already inside
[xats2js_js1emit.js]!
*)
//
#extern
fun
XATS2JS_optn_vt_nil
{a:vt}
((*0*)): optn_vt(a) = $extnam()
#implfun
XATS2JS_optn_vt_nil() = optn_vt_nil()
#extern
fun
XATS2JS_optn_vt_cons
{a:vt}
(x0: a): optn_vt(a) = $extnam()
#implfun
XATS2JS_optn_vt_cons(x0) = optn_vt_cons(x0)
//
*)
//
(* ****** ****** *)
//
#extern
fun
XATS2JS_optn_vt_nilq1
{a:vt}
( xs:
! optn_vt(a)): bool = $extnam()
#implfun
XATS2JS_optn_vt_nilq1(xs) =
(
case+ xs of
|optn_vt_nil()=>true|optn_vt_cons(x0)=>false)
//
#extern
fun
XATS2JS_optn_vt_consq1
{a:vt}
( xs:
! optn_vt(a)): bool = $extnam()
#implfun
XATS2JS_optn_vt_consq1(xs) =
(
case+ xs of
|optn_vt_nil()=>false|optn_vt_cons(x0)=>(true))
//
(* ****** ****** *)
//
#extern
fun
XATS2JS_optn_vt_head$raw0
{a:vt}
( xs
: optn_vt(a)): (a) = $extnam()
#implfun
XATS2JS_optn_vt_head$raw0(xs) =
(
case- xs of ~optn_vt_cons(x0) => (x0))
//
#extern
fun
XATS2JS_optn_vt_uncons$raw0
{a:vt}
( xs
: optn_vt(a)): (a) = $extnam()
#implfun
XATS2JS_optn_vt_uncons$raw0(xs) =
(
case- xs of ~optn_vt_cons(x0) => (x0))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
//
(*
HX-2026-01-02:
Already inside
[xats2js_js1emit.js]!
*)
//
#extern
fun
XATS2JS_list_vt_nil
{a:vt}
((*0*)): list_vt(a) = $extnam()
#implfun
XATS2JS_list_vt_nil() = list_vt_nil()
#extern
fun
XATS2JS_list_vt_cons
{a:vt}
( x1: a//head
, xs: list_vt(a)): list_vt(a) = $extnam()
#implfun
XATS2JS_list_vt_cons(x1,xs) = list_vt_cons(x1,xs)
//
*)
//
(* ****** ****** *)
//
#extern
fun
XATS2JS_list_vt_nilq1
{a:vt}
( xs:
! list_vt(a)): bool = $extnam()
#implfun
XATS2JS_list_vt_nilq1(xs) =
(
case+ xs of
|list_vt_nil()=>true|list_vt_cons _ => false)
//
#extern
fun
XATS2JS_list_vt_consq1
{a:vt}
( xs:
! list_vt(a)): bool = $extnam()
#implfun
XATS2JS_list_vt_consq1(xs) =
(
case+ xs of
|list_vt_nil()=>false|list_vt_cons _ => (true))
//
(* ****** ****** *)
//
#extern
fun
XATS2JS_list_vt_head$raw1
{a:vt}
( xs
: list_vt(a)): (a) = $extnam()
#implfun
XATS2JS_list_vt_head$raw1(xs) =
(
case- xs of
|
list_vt_cons
(  x1, xs  ) =>
let
val x1 =
$UN.datacopy(x1) in $UN.enlinear(x1) end)
//
#extern
fun
XATS2JS_list_vt_tail$raw0
{a:vt}
( xs:
~ list_vt(a)): list_vt(a) = $extnam()
#implfun
XATS2JS_list_vt_tail$raw0(xs) =
case- xs of
| ~
list_vt_cons
(  x1, xs  ) =>
(
  let val x1 = $UN.delinear(x1) in xs end)
//
(* ****** ****** *)
(* ****** ****** *)
//
#extern
fun
XATS2JS_lazy_vt_eval
{a:vt}
( lz:
~ lazy_vt(a)): (a) = $extnam()
#implfun
XATS2JS_lazy_vt_eval(lz) = $eval(lz)
//
#extern
fun
XATS2JS_lazy_vt_free
{a:vt}
( lz:
~ lazy_vt(a)): void = $extnam()
#implfun
XATS2JS_lazy_vt_free(lz) = $free(lz)
//
(* ****** ****** *)
//
#extern
fun
XATS2JS_lazy_vt_make_f0un
{a:vt}
( f0
: ()->(a)): lazy_vt(a) = $extnam()
#implfun
XATS2JS_lazy_vt_make_f0un(f0) = $llazy(f0())
//
(* ****** ****** *)
(* ****** ****** *)
//
#extern
fun
XATS2JS_strmcon_vt_nil
{a:vt}
((*0*)): strmcon_vt(a) = $extnam()
#implfun
XATS2JS_strmcon_vt_nil() = strmcon_vt_nil()
//
#extern
fun
XATS2JS_strmcon_vt_cons
{a:vt}
(x1: a//head
,xs: strm_vt(a)): strmcon_vt(a) = $extnam()
#implfun
XATS2JS_strmcon_vt_cons(x1,xs) = strmcon_vt_cons(x1,xs)
//
#extern
fun
XATS2JS_strxcon_vt_cons
{a:vt}
(x1: a//head
,xs: strx_vt(a)): strxcon_vt(a) = $extnam()
#implfun
XATS2JS_strxcon_vt_cons(x1,xs) = strxcon_vt_cons(x1,xs)
//
(* ****** ****** *)
//
#extern
fun
XATS2JS_strmcon_vt_nilq1
{a:vt}
( xs:
! strmcon_vt(a)): bool = $extnam()
#implfun
XATS2JS_strmcon_vt_nilq1(xs) =
(
case+ xs of
|strmcon_vt_nil()=>true|strmcon_vt_cons _ =>false)
//
#extern
fun
XATS2JS_strmcon_vt_consq1
{a:vt}
( xs:
! strmcon_vt(a)): bool = $extnam()
#implfun
XATS2JS_strmcon_vt_consq1(xs) =
(
case+ xs of
|strmcon_vt_nil()=>false|strmcon_vt_cons _ =>(true))
//
(* ****** ****** *)
//
#extern
fun
XATS2JS_strmcon_vt_head$raw1
{a:vt}
( xs:
! strmcon_vt(a)): (a) = $extnam()
#implfun
XATS2JS_strmcon_vt_head$raw1(xs) =
(
case- xs of
|
strmcon_vt_cons
(   x1 , xs   ) =>
let
val x1 =
$UN.datacopy(x1) in $UN.enlinear(x1) end)
//
#extern
fun
XATS2JS_strmcon_vt_tail$raw0
{a:vt}
( xs:
~ strmcon_vt(a)): strm_vt(a) = $extnam()
#implfun
XATS2JS_strmcon_vt_tail$raw0(xs) =
case- xs of
| ~
strmcon_vt_cons
(   x1 , xs   ) =>
(
  let val x1 = $UN.delinear(x1) in xs end)
//
(* ****** ****** *)
//
(*
HX: no failure!
*)
#extern
fun
XATS2JS_strxcon_vt_head$raw1
{a:vt}
( xs:
! strxcon_vt(a)): (a) = $extnam()
#implfun
XATS2JS_strxcon_vt_head$raw1(xs) =
(
case+ xs of
|
strxcon_vt_cons
(   x1 , xs   ) =>
let
val x1 =
$UN.datacopy(x1) in $UN.enlinear(x1) end)
//
(*
HX: no failure!
*)
#extern
fun
XATS2JS_strxcon_vt_tail$raw0
{a:vt}
( xs:
~ strxcon_vt(a)): strx_vt(a) = $extnam()
#implfun
XATS2JS_strxcon_vt_tail$raw0(xs) =
case+ xs of
| ~
strxcon_vt_cons
(   x1 , xs   ) =>
(
  let val x1 = $UN.delinear(x1) in xs end)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_CATS_JS_precats.dats] *)
(***********************************************************************)
`,
  "DATS/CATS/JS/strm000.cats": `////////////////////////////////////////////////////////////////////////.
//                                                                    //.
//                         Applied Type System                        //.
//                                                                    //.
////////////////////////////////////////////////////////////////////////.

/*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2026 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*/

////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
/*
Author: Hongwei Xi
Fri Jan  2 03:23:26 PM EST 2026
Authoremail: gmhwxiATgmailDOTcom
*/
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_strm_vt_forall0$f1un
  (fxs, test)
{
  let nilq1 =
    XATS2JS_strmcon_vt_nilq1
  while (1) {
    let cxs =
      XATS2JS_lazy_vt_eval(fxs)
    if (nilq1(cxs))
    {
      break;
    } else {
      let x01 =
        XATS2JS_strmcon_vt_head$raw1(cxs)
      if (test(x01))
      {
        fxs = XATS2JS_strmcon_vt_tail$raw0(cxs)
      } else {
        fxs = XATS2JS_strmcon_vt_tail$raw0(cxs)
        XATS2JS_lazy_vt_free(fxs); return false
      }
    }
  }
  return true // XATS2JS_strm_vt_forall0$f1un(...)
}
//
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_strm_vt_filter0$f1un
  (fxs, test, free)
{
  return XATS2JS_lazy_vt_make_f0un(
    () => XATS2JS_strmcon_vt_filter0$f1un(XATS2JS_lazy_vt_eval(fxs), test, free)
  )
}
//
function
XATS2JS_strmcon_vt_filter0$f1un
  (cxs, test, free)
{
  let nilq1 =
    XATS2JS_strmcon_vt_nilq1
  while (1) {
    if (nilq1(cxs))
    {
      return XATS2JS_strmcon_vt_nil()
    } else {
      let x01 = XATS2JS_strmcon_vt_head$raw1(cxs)
      let fxs = XATS2JS_strmcon_vt_tail$raw0(cxs)
      if (test(x01)) {
        return XATS2JS_strmcon_vt_cons(x01, XATS2JS_strm_vt_filter0$f1un(fxs, test, free))
      } else {
        free(x01);
        cxs = XATS2JS_lazy_vt_eval(fxs); continue;
      }
    }
  }
}
//
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
// end of [ATS3/XANADU_prelude_DATS_CATS_JS_strm000.cats]
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
`,
  "DATS/CATS/JS/strm000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2026 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Fri Jan  2 03:05:42 PM EST 2026
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#extern
fun
XATS2JS_strm_vt_forall0$f1un
{x0:vt}
( xs
: strm_vt(x0)
, test
: (~x0) -> bool): bool
= $extnam()//extern(./strm000.cats)
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
strm_vt_forall0
  (  xs  ) =
let
fun
test(x0: ~x0): bool =
(
  forall$test0<x0>(x0))
in//let
XATS2JS_strm_vt_forall0$f1un{x0}(xs, test)
end(*let*)//end-of-[strm_vt_forall0<x0>(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#extern
fun
XATS2JS_strm_vt_filter0$f1un
{x0:vt}
( xs
: strm_vt(x0)
, test
: (!x0) -> bool
, free
: (~x0) -> void): strm_vt(x0)
= $extnam()//extern(./strm000.cats)
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
strm_vt_filter0
  (  xs  ) =
let
fun
test(x0: !x0): bool =
(
  filter$test1<x0>(x0))
fun
free(x0: ~x0): void = g_free<x0>(x0)
in//let
XATS2JS_strm_vt_filter0$f1un{x0}(xs, test, free)
end(*let*)//end-of-[strm_vt_filter0<x0>(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_CATS_JS_strm000.dats] *)
(***********************************************************************)
`,
  "DATS/CATS/JS/strn000.cats": `////////////////////////////////////////////////////////////////////////.
//                                                                    //.
//                         Applied Type System                        //.
//                                                                    //.
////////////////////////////////////////////////////////////////////////.

/*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*/

////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
/*
Author: Hongwei Xi
Fri 16 Aug 2024 05:26:45 PM EDT
Authoremail: gmhwxiATgmailDOTcom
*/
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_strn_cmp
  (x1, x2)
{
  var df
  var i0 = 0
  var n1 = x1.length;
  var n2 = x2.length;
  var n0 =
  (n1 <= n2) ? n1 : n2;
  while (i0 < n0) {
    df =
    x1.charCodeAt(i0)
    -
    x2.charCodeAt(i0)
    if (df !== 0) return df;
    i0 = (  i0 + 1  )
  }
  return (      n1 - n2      );
}
//
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_strn_length
  (cs)
{
  return cs.length // HX: field
}
function
XATS000_strn_length
  (cs)
{
  return cs.length // HX: field
}
//
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_strn_get$at$raw
  (cs, i0)
{
  return cs.charCodeAt(i0) // HX: ascii
}
function
XATS000_strn_get$at$raw
  (cs, i0)
{
  return XATS2JS_strn_get$at$raw(cs, i0)
}
//
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_strn_fmake_fwork
  (fwork)
{
  var cs = []
  fwork((ch) => {cs.push(ch);return})
  return String.fromCharCode.apply(null, cs)
}
//
function
XATS000_strn_fmake_fwork
  (fwork)
{
  return XATS2JS_strn_fmake_fwork(fwork)
}
//
////////////////////////////////////////////////////////////////////////.
//
function
XATS000_strn_print
  ( cs )
{
  return XATS2JS_strn_print(cs)
}
function
XATS2JS_strn_print
  ( cs )
{
  XATS2JS_the_print_store.push(cs); return
}
//
////////////////////////////////////////////////////////////////////////.
//
/*
HX-2025-04-26:
Sat Apr 26 08:48:02 PM EDT 2025
*/
//
function
XATS2JS_strn_fmake_env$fwork
  (env, fwork)
{
  var cs = []
  fwork(env, (ch) => {cs.push(ch);return})
  return String.fromCharCode.apply(null, cs)
}
function
XATS2JS_strn_fmake1_env$fwork
  (env, fwork)
{
  var cs = []
  fwork(env, (ch) => {cs.push(ch);return})
  return String.fromCharCode.apply(null, cs)
}
//
function
XATS000_strn_fmake_env$fwork
  (env, fwork)
{
  return XATS2JS_strn_fmake_env$fwork(env, fwork)
}
function
XATS000_strn_fmake1_env$fwork
  (env, fwork)
{
  return XATS2JS_strn_fmake1_env$fwork(env, fwork)
}
//
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
// end of [ATS3/XANADU_prelude_DATS_CATS_JS_strn000.cats]
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
`,
  "DATS/CATS/JS/strn000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Fri 16 Aug 2024 05:24:40 PM EDT
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
strn_nilq
  ( cs ) =
(
strn_length<>(cs) = 0)
//
#impltmp
<(*tmp*)>
strn_consq
  ( cs ) =
(
strn_length<>(cs) > 0)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
strn_length
  ( cs ) =
(
XATS2JS_strn_length
  ( cs )) where
{
#extern
fun
XATS2JS_strn_length
  (cs: strn): nint = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-04:
Wed 04 Sep 2024 04:52:34 AM EDT
*)
//
#impltmp
<(*tmp*)>
strn_cmp
  (x1, x2) =
(
XATS2JS_strn_cmp
  (x1, x2)) where
{
#extern
fun
XATS2JS_strn_cmp
(x1: strn, x2: strn): nint = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-05:
Thu 05 Sep 2024 11:11:27 AM EDT
*)
//
#impltmp
<(*tmp*)>
strn_print
  ( cs ) =
(
XATS2JS_strn_print
  ( cs )) where
{
#extern
fun
XATS2JS_strn_print(cs: strn): void = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-04:
Sun Jan  4 04:45:42 PM EST 2026
*)
//
#impltmp
<(*tmp*)>
strn_get$at
  (cs, i0) =
(
XATS2JS_strn_get$at$raw
(    cs      , i0     ))
where
{
#extern
fun
XATS2JS_strn_get$at$raw
(    cs: strn, i0: nint    ): char = $extnam()
}
//
(* ****** ****** *)
//
(*
#impltmp
<(*tmp*)>
strn_fset$at
  (cs, i0, c0) =
(
XATS2JS_strn_fset$at$raw
(    cs,   i0,   c0    ))
where
{
#extern
fun
XATS2JS_strn_fset$at$raw
(cs: strn, i0: nint, c0: cgtz): strn = $extnam()
}
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_CATS_JS_strn000.dats] *)
(***********************************************************************)
`,
  "DATS/CATS/JS/strx000.cats": `////////////////////////////////////////////////////////////////////////.
//                                                                    //.
//                         Applied Type System                        //.
//                                                                    //.
////////////////////////////////////////////////////////////////////////.

/*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2026 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*/

////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
/*
Author: Hongwei Xi
Wed Jan 14 01:17:42 PM EST 2026
Authoremail: gmhwxiATgmailDOTcom
*/
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_strx_vt_forall0$f1un
  (fxs, test)
{
  while (1) {
    let cxs =
      XATS2JS_lazy_vt_eval(fxs)
    let x01 =
      XATS2JS_strxcon_vt_head$raw1(cxs)
    if (test(x01))
    {
      fxs = XATS2JS_strxcon_vt_tail$raw0(cxs)
    } else {
      fxs = XATS2JS_strxcon_vt_tail$raw0(cxs)
      XATS2JS_lazy_vt_free(fxs); return false
    }
  }
  return true // XATS2JS_strx_vt_forall0$f1un(...)
}
//
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_strx_vt_filter0$f1un
  (fxs, test, free)
{
  return XATS2JS_lazy_vt_make_f0un(
    () => XATS2JS_strxcon_vt_filter0$f1un(XATS2JS_lazy_vt_eval(fxs), test, free)
  )
}
//
function
XATS2JS_strxcon_vt_filter0$f1un
  (cxs, test, free)
{
  while (1) {
    let x01 = XATS2JS_strxcon_vt_head$raw1(cxs)
    let fxs = XATS2JS_strxcon_vt_tail$raw0(cxs)
    if (test(x01)) {
      return XATS2JS_strxcon_vt_cons(x01, XATS2JS_strx_vt_filter0$f1un(fxs, test, free))
    } else {
      free(x01);
      cxs = XATS2JS_lazy_vt_eval(fxs); continue;
    }
  }
}
//
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
// end of [ATS3/XANADU_prelude_DATS_CATS_JS_strx000.cats]
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
`,
  "DATS/CATS/JS/strx000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2026 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Wed Jan 14 01:16:23 PM EST 2026
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#extern
fun
XATS2JS_strx_vt_forall0$f1un
{x0:vt}
( xs
: strx_vt(x0)
, test
: (~x0) -> bool): bool
= $extnam()//extern(./strx000.cats)
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
strx_vt_forall0
  (  xs  ) =
let
fun
test(x0: ~x0): bool =
(
  forall$test0<x0>(x0))
in//let
XATS2JS_strx_vt_forall0$f1un{x0}(xs, test)
end(*let*)//end-of-[strx_vt_forall0<x0>(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#extern
fun
XATS2JS_strx_vt_filter0$f1un
{x0:vt}
( xs
: strx_vt(x0)
, test
: (!x0) -> bool
, free
: (~x0) -> void): strx_vt(x0)
= $extnam()//extern(./strx000.cats)
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
strx_vt_filter0
  (  xs  ) =
let
fun
test(x0: !x0): bool =
(
  filter$test1<x0>(x0))
fun
free(x0: ~x0): void = g_free<x0>(x0)
in//let
XATS2JS_strx_vt_filter0$f1un{x0}(xs, test, free)
end(*let*)//end-of-[strx_vt_filter0<x0>(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_CATS_JS_strx000.dats] *)
(***********************************************************************)
`,
  "DATS/CATS/JS/xtop000.cats": `////////////////////////////////////////////////////////////////////////.
//                                                                    //.
//                         Applied Type System                        //.
//                                                                    //.
////////////////////////////////////////////////////////////////////////.

/*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*/

////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
/*
Author: Hongwei Xi
Thu 05 Sep 2024 11:21:07 AM EDT
Authoremail: gmhwxiATgmailDOTcom
*/
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_console_log
  (x0)
{
  return console.log(x0) // HX: void
}
//
////////////////////////////////////////////////////////////////////////.
//
const
XATS2JS_the_print_store = [] // HX: for prints?
//
const
XATS2JS_the_prout_store = [] // HX: for general output
//
const
XATS2JS_the_prerr_store = [] // HX: for reporting errors
//
////////////////////////////////////////////////////////////////////////.
//
function
XATS2JS_the_print_store_clear
  ( /*void*/ )
{
  XATS2JS_the_print_store.length = 0; return
}
//
function
XATS2JS_the_print_store_flush
  ( /*void*/ )
{
  let cs =
  XATS2JS_the_print_store.join("")
  XATS2JS_the_print_store.length = 0; return cs
}
//
function
XATS2JS_the_prout_store_flush
  ( /*void*/ )
{
  let cs =
  XATS2JS_the_prout_store.join("")
  XATS2JS_the_prout_store.length = 0; return cs
}
//
function
XATS2JS_the_prerr_store_flush
  ( /*void*/ )
{
  let cs =
  XATS2JS_the_prerr_store.join("")
  XATS2JS_the_prerr_store.length = 0; return cs
}
//
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
// end of [ATS3/XANADU_prelude_DATS_CATS_JS_xtop000.cats]
////////////////////////////////////////////////////////////////////////.
////////////////////////////////////////////////////////////////////////.
`,
  "DATS/CATS/JS/xtop000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Thu 05 Sep 2024 11:54:02 AM EDT
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#abstype
console_type
#typedef
console = console_type
//
(* ****** ****** *)
(* ****** ****** *)
//
#extern
fun<>
console_log
{t0:t0}(x0: t0): void
//
#impltmp
<(*tmp*)>
console_log
  ( x0 ) =
(
XATS2JS_console_log
  ( x0 )) where
{
#extern
fun
XATS2JS_console_log
{t0:t0}(x0: t0): void = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#extern
fun<>
the_print_store_log(): void
//
#extern
fun<>
the_print_store_flush(): strn
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
the_print_store_log() =
console_log(the_print_store_flush())
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
the_print_store_flush
  ((*void*)) =
(
XATS2JS_the_print_store_flush
  ((*void*))) where
{
#extern
fun
XATS2JS_the_print_store_flush(): strn = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_CATS_JS_xtop000.dats] *)
(***********************************************************************)
`,
  "DATS/CATS/PY/OUTS/.keeper": ``,
  "DATS/CATS/PY/axrf000.cats": `########################################################################.
##                                                                    ##.
##                         Applied Type System                        ##.
##                                                                    ##.
########################################################################.

##
## ATS/Xanadu - Unleashing the Potential of Types!
## Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
## All rights reserved
##
## ATS is free software;  you can  redistribute it and/or modify it under
## the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
## Free Software Foundation; either version 3, or (at  your  option)  any
## later version.
## 
## ATS is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
## FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
## for more details.
## 
## You  should  have  received  a  copy of the GNU General Public License
## along  with  ATS;  see the  file COPYING.  If not, please write to the
## Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
## 02110-1301, USA.
##

########################################################################.
########################################################################.
##
## Author: Hongwei Xi
## Wed Jan  8 02:46:14 AM EST 2025
## Authoremail: gmhwxiATgmailDOTcom
##
########################################################################.
########################################################################.
##
def XATS2PY_a0rf_lget(A):
  return A[0]
def XATS2PY_a0rf_lset(A, x1):
  A[0] = x1; return
##
def XATS2PY_a0rf_make_1val(x0):
  return [x0] ## HX: singleton
##
########################################################################.
########################################################################.
##
def XATS2PY_a1rf_lget_at(A, i0):
  return A[i0]
def XATS2PY_a1rf_lset_at(A, i0, x1):
  A[i0] = x1; return
##
def XATS2PY_a1rf_make_ncpy(n0, x0):
  i0 = 0
  A0 = []
  while (i0 < n0):
    A0.append(x0); i0 = i0 + 1
  return A0 ## HX: A0 = [x0, x0, ..., x0]
##
def XATS2PY_a1rf_make_nfun(n0, fopr):
  i0 = 0
  A0 = []
  while (i0 < n0):
    A0.append(fopr(i0)); i0 = i0 + 1
  return A0 ## HX: A0 = [fopr(0),...,fopr(n)]
##
########################################################################.
########################################################################.
## end of [ATS3/XANADU_prelude_DATS_CATS_PY_axrf000.cats]
########################################################################.
########################################################################.
`,
  "DATS/CATS/PY/axrf000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Wed Jan  1 03:28:47 PM EST 2025
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#absimpl
a0rf_vt_tx
(  a:vt  ) = $extbox("a0rf_tx")
#absimpl
a0rf_vt_vx
(  a:vt  ) = $extbox("a0rf_vx")
//
(* ****** ****** *)
//
#absimpl
a1rf_vt_i0_tx
( a:vt,n:i0 ) = $extbox("a1rf_tx")
#absimpl
a1rf_vt_i0_vx
( a:vt,n:i0 ) = $extbox("a1rf_vx")
//
(* ****** ****** *)
(* ****** ****** *)
//
//
#impltmp
< a: vt >
a0rf_lget
  ( A ) =
(
XATS2PY_a0rf_lget
  ( A )) where
{
#extern
fun
XATS2PY_a0rf_lget
{a:vt}
( A
: a0rf(a))
: (owed(a) | a) = $extnam()
}
//
#impltmp
< a: vt >
a0rf_lset
(f | A, x) =
(
XATS2PY_a0rf_lset
  (f | A, x)) where
{
#extern
fun
XATS2PY_a0rf_lset
{a:vt}
(f:owed(a)
|A:a0rf(a), x:a): void = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: vt >
a0rf_make_1val
  ( x1 ) =
(
XATS2PY_a0rf_make_1val
  ( x1 )) where
{
#extern
fun
XATS2PY_a0rf_make_1val
{a:vt}( x1: a ): a0rf(a) = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: vt >
a1rf_lget$at
  (A, i) =
(
XATS2PY_a1rf_lget$at
  (A, i)) where
{
#extern
fun
XATS2PY_a1rf_lget$at
{a:vt}
( A
: a1rf(a)
, i: nint): (owed(a) | a) = $extnam()
}
//
#impltmp
< a: vt >
a1rf_lset$at
  (f | A, i, x) =
(
XATS2PY_a1rf_lset$at
  (f | A, i, x)) where
{
#extern
fun
XATS2PY_a1rf_lset$at
{a:vt}
(f:owed(a)
|A:a1rf(a),i:nint,x:a): void = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: t0 >
a1rf_make_ncpy
  (n, x) =
(
XATS2PY_a1rf_make_ncpy
  (n, x)) where
{
#extern
fun
XATS2PY_a1rf_make_ncpy
{a:t0}(n:nint, x:a): a1rf(a) = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
< a: vt >
a1rf_make_nfun
  (n, f) =
(
XATS2PY_a1rf_make_nfun
  (n, f)) where
{
#extern
fun
XATS2PY_a1rf_make_nfun
{a:t0}
(n:nint, f:(nint)->(a)): a1rf(a) = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(* ****** ****** *)(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)(* ****** ****** *)

(* end of [ATS3/XANADU_prelude_DATS_CATS_PY_axrf000.dats] *)
`,
  "DATS/CATS/PY/axsz000.cats": `########################################################################.
##                                                                    ##.
##                         Applied Type System                        ##.
##                                                                    ##.
########################################################################.

##
## ATS/Xanadu - Unleashing the Potential of Types!
## Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
## All rights reserved
##
## ATS is free software;  you can  redistribute it and/or modify it under
## the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
## Free Software Foundation; either version 3, or (at  your  option)  any
## later version.
## 
## ATS is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
## FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
## for more details.
## 
## You  should  have  received  a  copy of the GNU General Public License
## along  with  ATS;  see the  file COPYING.  If not, please write to the
## Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
## 02110-1301, USA.
##

########################################################################.
########################################################################.
##
## Author: Hongwei Xi
## Wed Jan  8 02:46:14 AM EST 2025
## Authoremail: gmhwxiATgmailDOTcom
##
########################################################################.
########################################################################.
##
def XATS2PY_a1sz_length(A0):
  return len(A0)
##
########################################################################.
##
def XATS2PY_a1sz_lget_at(A0, i0):
  return A0[i0]
def XATS2PY_a1sz_lset_at(A0, i0, x1):
  A0[i0] = x1; return
##
########################################################################.
##
def XATS2PY_a1sz_make_ncpy(n0, x0):
  i0 = 0
  A0 = []
  while (i0 < n0):
    A0.append(x0); i0 = i0 + 1
  return A0 ## HX: A0 = [x0, ..., x0]
##
def XATS2PY_a1sz_make_nfun(n0, fopr):
  i0 = 0
  A0 = []
  while (i0 < n0):
    A0.append(fopr(i0)); i0 = i0 + 1
  return A0 ## HX: A0 = [fopr(0),...,fopr(n-1)]
##
########################################################################.
##
def XATS2PY_a1sz_fmake_fwork(fwork):
  A0 = []
  fwork(lambda x0: A0.append(x0)); return A0
##
########################################################################.
########################################################################.
## end of [ATS3/XANADU_prelude_DATS_CATS_PY_axsz000.cats]
########################################################################.
########################################################################.
`,
  "DATS/CATS/PY/axsz000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Wed Jan  1 03:30:43 PM EST 2025
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#absimpl
a1sz_vt_i0_tx
(a: vt, n: i0) = $extbox("a1sz_tx")
#absimpl
a1sz_vt_i0_vx
(a: vt, n: i0) = $extbox("a1sz_vx")
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: vt >
a1sz_length
 {n:i0}( A ) =
(
XATS2PY_a1sz_length
 {a}{n}( A )) where
{
#extern
fun
XATS2PY_a1sz_length
{a:vt}
{n:i0}
(A: a1sz(a, n)): sint(n) = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: vt >
a1sz_lget$at
  (A, i) =
(
XATS2PY_a1sz_lget$at
  (A, i)) where
{
#extern
fun
XATS2PY_a1sz_lget$at
{a:vt}
( A
: a1sz(a)
, i: nint): (owed(a) | a) = $extnam()
}
//
#impltmp
< a: vt >
a1sz_lset$at
  (f | A, i, x) =
(
XATS2PY_a1sz_lset$at
  (f | A, i, x)) where
{
#extern
fun
XATS2PY_a1sz_lset$at
{a:vt}
(f:owed(a)
|A:a1sz(a),i:nint,x:a): void = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: t0 >
a1sz_make_ncpy
  (n, x) =
(
XATS2PY_a1sz_make_ncpy
  (n, x)) where
{
#extern
fun
XATS2PY_a1sz_make_ncpy
{a:t0}(n:nint, x:a): a1sz(a) = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
< a: vt >
a1sz_make_nfun
  (n, f) =
(
XATS2PY_a1sz_make_nfun
  (n, f)) where
{
#extern
fun
XATS2PY_a1sz_make_nfun
{a:t0}
(n:nint, f:(nint)->(a)): a1sz(a) = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-04-27:
Sun Apr 27 07:00:55 PM EDT 2025
*)
//
#impltmp
< x0:vt >
a1sz_fmake_fwork
  (fwork) =
(
XATS2PY_a1sz_fmake_fwork
  (fwork)) where
{
#extern
fun
XATS2PY_a1sz_fmake_fwork
{ x0:vt }
(
fwork:
((~x0) -> void) -> void): a1sz(x0) = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(* ****** ****** *)(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)(* ****** ****** *)

(* end of [ATS3/XANADU_prelude_DATS_CATS_PY_axsz000.dats] *)
`,
  "DATS/CATS/PY/bool000.cats": `########################################################################.
##                                                                    ##.
##                         Applied Type System                        ##.
##                                                                    ##.
########################################################################.

##
## ATS/Xanadu - Unleashing the Potential of Types!
## Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
## All rights reserved
##
## ATS is free software;  you can  redistribute it and/or modify it under
## the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
## Free Software Foundation; either version 3, or (at  your  option)  any
## later version.
## 
## ATS is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
## FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
## for more details.
## 
## You  should  have  received  a  copy of the GNU General Public License
## along  with  ATS;  see the  file COPYING.  If not, please write to the
## Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
## 02110-1301, USA.
##

########################################################################.
########################################################################.
##
## Author: Hongwei Xi
## Wed Jan  8 02:48:20 AM EST 2025
## Authoremail: gmhwxiATgmailDOTcom
##
########################################################################.
########################################################################.
##
def XATS2PY_bool_lt(b1, b2):
  return (b1 < b2) ## HX: lt
def XATS2PY_bool_gt(b1, b2):
  return (b1 > b2) ## HX: gt
def XATS2PY_bool_eq(b1, b2):
  return (b1 == b2) ## HX: eq
def XATS2PY_bool_lte(b1, b2):
  return (b1 <= b2) ## HX: lte
def XATS2PY_bool_gte(b1, b2):
  return (b1 >= b2) ## HX: gte
def XATS2PY_bool_neq(b1, b2):
  return (b1 != b2) ## HX: neq
##
########################################################################.
########################################################################.
## end of [ATS3/XANADU_prelude_DATS_CATS_PY_bool000.cats]
########################################################################.
########################################################################.
`,
  "DATS/CATS/PY/bool000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Wed Jan  8 02:48:44 AM EST 2025
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
bool_lt
(b1, b2) =
(
XATS2PY_bool_lt
  (b1, b2)) where
{
#extern
fun
XATS2PY_bool_lt
(b1: bool, b2: bool): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
bool_gt
(b1, b2) =
(
XATS2PY_bool_gt
  (b1, b2)) where
{
#extern
fun
XATS2PY_bool_gt
(b1: bool, b2: bool): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
bool_eq
(b1, b2) =
(
XATS2PY_bool_eq
  (b1, b2)) where
{
#extern
fun
XATS2PY_bool_eq
(b1: bool, b2: bool): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
bool_lte
(b1, b2) =
(
XATS2PY_bool_lte
  (b1, b2)) where
{
#extern
fun
XATS2PY_bool_lte
(b1: bool, b2: bool): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
bool_gte
(b1, b2) =
(
XATS2PY_bool_gte
  (b1, b2)) where
{
#extern
fun
XATS2PY_bool_gte
(b1: bool, b2: bool): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
bool_neq
(b1, b2) =
(
XATS2PY_bool_neq
  (b1, b2)) where
{
#extern
fun
XATS2PY_bool_neq
(b1: bool, b2: bool): bool = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
bool_print(b0) =
(
if b0
then strn_print<>("true")
else strn_print<>("false"))//end(impl)
//
(* ****** ****** *)
(* ****** ****** *)
//
(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)

(* end of [ATS3/XANADU_prelude_DATS_CATS_PY_bool000.dats] *)
`,
  "DATS/CATS/PY/char000.cats": `########################################################################.
##                                                                    ##.
##                         Applied Type System                        ##.
##                                                                    ##.
########################################################################.

##
## ATS/Xanadu - Unleashing the Potential of Types!
## Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
## All rights reserved
##
## ATS is free software;  you can  redistribute it and/or modify it under
## the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
## Free Software Foundation; either version 3, or (at  your  option)  any
## later version.
## 
## ATS is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
## FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
## for more details.
## 
## You  should  have  received  a  copy of the GNU General Public License
## along  with  ATS;  see the  file COPYING.  If not, please write to the
## Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
## 02110-1301, USA.
##

########################################################################.
########################################################################.
##
## Author: Hongwei Xi
## Wed Jan  8 02:49:26 AM EST 2025
## Authoremail: gmhwxiATgmailDOTcom
##
########################################################################.
########################################################################.
##
def XATS2PY_char_lt(c1, c2):
  return (c1 < c2) ## HX: lt
def XATS2PY_char_gt(c1, c2):
  return (c1 > c2) ## HX: gt
def XATS2PY_char_eq(c1, c2):
  return (c1 == c2) ## HX: eq
##
def XATS2PY_char_lte(c1, c2):
  return (c1 <= c2) ## HX: lte
def XATS2PY_char_gte(c1, c2):
  return (c1 >= c2) ## HX: gte
def XATS2PY_char_neq(c1, c2):
  return (c1 != c2) ## HX: noteq
##
########################################################################.
##
def XATS2PY_char_add_sint(c1, i2):
  c2 = c1+i2
  return (c2%256) ## HX: char=int8
##
def XATS2PY_char_sub_char(c1, c2):
  return (c1 - c2) ## HX: char=int8
##
########################################################################.
##
def XATS2PY_char_print(c0):
  XATS2PY_strn_print(chr(c0)); return
##
########################################################################.
########################################################################.
## end of [ATS3/XANADU_prelude_DATS_CATS_PY_char000.cats]
########################################################################.
########################################################################.
`,
  "DATS/CATS/PY/char000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Wed Jan  8 02:50:04 AM EST 2025
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
char_lt
(c1, c2) =
(
XATS2PY_char_lt
  (c1, c2)) where
{
#extern
fun
XATS2PY_char_lt
(c1: char, c2: char): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
char_gt
(c1, c2) =
(
XATS2PY_char_gt
  (c1, c2)) where
{
#extern
fun
XATS2PY_char_gt
(c1: char, c2: char): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
char_eq
(c1, c2) =
(
XATS2PY_char_eq
  (c1, c2)) where
{
#extern
fun
XATS2PY_char_eq
(c1: char, c2: char): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
char_lte
(c1, c2) =
(
XATS2PY_char_lte
  (c1, c2)) where
{
#extern
fun
XATS2PY_char_lte
(c1: char, c2: char): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
char_gte
(c1, c2) =
(
XATS2PY_char_gte
  (c1, c2)) where
{
#extern
fun
XATS2PY_char_gte
(c1: char, c2: char): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
char_neq
(c1, c2) =
(
XATS2PY_char_neq
  (c1, c2)) where
{
#extern
fun
XATS2PY_char_neq
(c1: char, c2: char): bool = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
char_add$sint
  (c1, i2) =
(
XATS2PY_char_add$sint
  (c1, i2)) where
{
#extern
fun
XATS2PY_char_add$sint
(c1: char, i2: sint): char = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
char_sub$char
  (c1, c2) =
(
XATS2PY_char_sub$char
  (c1, c2)) where
{
#extern
fun
XATS2PY_char_sub$char
(c1: char, c2: char): sint = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
char_print
  ( c0 ) =
(
XATS2PY_char_print
  ( c0 )) where
{
#extern
fun
XATS2PY_char_print(c0: char): void = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)

(* end of [ATS3/XANADU_prelude_DATS_CATS_PY_char000.dats] *)
`,
  "DATS/CATS/PY/gbas000.cats": `########################################################################.
##                                                                    ##.
##                         Applied Type System                        ##.
##                                                                    ##.
########################################################################.

##
## ATS/Xanadu - Unleashing the Potential of Types!
## Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
## All rights reserved
##
## ATS is free software;  you can  redistribute it and/or modify it under
## the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
## Free Software Foundation; either version 3, or (at  your  option)  any
## later version.
## 
## ATS is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
## FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
## for more details.
## 
## You  should  have  received  a  copy of the GNU General Public License
## along  with  ATS;  see the  file COPYING.  If not, please write to the
## Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
## 02110-1301, USA.
##

########################################################################.
########################################################################.
##
## Author: Hongwei Xi
## Wed Jan  8 02:43:18 AM EST 2025
## Authoremail: gmhwxiATgmailDOTcom
##
########################################################################.
########################################################################.
## end of [ATS3/XANADU_prelude_DATS_CATS_PY_gbas000.cats]
########################################################################.
########################################################################.
`,
  "DATS/CATS/PY/gbas000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Wed Jan  1 03:25:54 PM EST 2025
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)

(* end of [ATS3/XANADU_prelude_DATS_CATS_PY_gbas000.dats] *)
`,
  "DATS/CATS/PY/gdbg000.cats": `########################################################################.
##                                                                    ##.
##                         Applied Type System                        ##.
##                                                                    ##.
########################################################################.

##
## ATS/Xanadu - Unleashing the Potential of Types!
## Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
## All rights reserved
##
## ATS is free software;  you can  redistribute it and/or modify it under
## the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
## Free Software Foundation; either version 3, or (at  your  option)  any
## later version.
## 
## ATS is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
## FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
## for more details.
## 
## You  should  have  received  a  copy of the GNU General Public License
## along  with  ATS;  see the  file COPYING.  If not, please write to the
## Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
## 02110-1301, USA.
##

########################################################################.
########################################################################.
##
## Author: Hongwei Xi
## Wed Jan  8 02:49:44 AM EST 2025
## Authoremail: gmhwxiATgmailDOTcom
##
########################################################################.
########################################################################.
##
def XATS2PY_bool_assert_errmsg(cond, emsg):
  if not(cond):
    raise Exception("XATS2PY_bool_assert_errmsg: emsg = " + emsg)
  return ## HX: void is returned!
##
########################################################################.
########################################################################.
## end of [ATS3/XANADU_prelude_DATS_CATS_PY_gdbg000.cats]
########################################################################.
########################################################################.
`,
  "DATS/CATS/PY/gdbg000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Wed Jan  8 02:50:28 AM EST 2025
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
bool_assert$errmsg
  (cond, emsg) =
(
XATS2PY_bool_assert$errmsg
  (cond, emsg)) where
{
#extern
fun
XATS2PY_bool_assert$errmsg
(cond: bool, emsg: strm): void = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)

(* end of [ATS3/XANADU_prelude_DATS_CATS_PY_gdbg000.dats] *)
`,
  "DATS/CATS/PY/gflt000.cats": `########################################################################.
##                                                                    ##.
##                         Applied Type System                        ##.
##                                                                    ##.
########################################################################.

##
## ATS/Xanadu - Unleashing the Potential of Types!
## Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
## All rights reserved
##
## ATS is free software;  you can  redistribute it and/or modify it under
## the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
## Free Software Foundation; either version 3, or (at  your  option)  any
## later version.
## 
## ATS is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
## FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
## for more details.
## 
## You  should  have  received  a  copy of the GNU General Public License
## along  with  ATS;  see the  file COPYING.  If not, please write to the
## Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
## 02110-1301, USA.
##

########################################################################.
########################################################################.
##
## Author: Hongwei Xi
## Wed Jan  8 02:50:50 AM EST 2025
## Authoremail: gmhwxiATgmailDOTcom
##
########################################################################.
########################################################################.
##
def XATS2PY_dflt_neg(df):
  return ( -df ) ## HX:neg
##
########################################################################.
##
def XATS2PY_dflt_abs(df):
  if df >= 0.0:
    return df
  else:
    return (-df) ## HX:abs
##
########################################################################.
##
def XATS2PY_dflt_sqrt(df):
  return math.sqrt(  df  )
##
def XATS2PY_dflt_cbrt(df):
  return math.cbrt(  df  )
##
########################################################################.
##
def XATS2PY_dflt_lt_dflt(f1, f2):
  return (f1 < f2) ## HX: lt
def XATS2PY_dflt_gt_dflt(f1, f2):
  return (f1 > f2) ## HX: gt
def XATS2PY_dflt_eq_dflt(f1, f2):
  return (f1 == f2) ## HX: equal
##
def XATS2PY_dflt_lte_dflt(f1, f2):
  return (f1 <= f2) ## HX: lte
def XATS2PY_dflt_gte_dflt(f1, f2):
  return (f1 >= f2) ## HX: gte
def XATS2PY_dflt_neq_dflt(f1, f2):
  return (f1 != f2) ## HX: noteq
##
########################################################################.
##
def XATS2PY_dflt_add_dflt(f1, f2):
  return (f1 + f2) ## HX: add
def XATS2PY_dflt_sub_dflt(f1, f2):
  return (f1 - f2) ## HX: sub
##
def XATS2PY_dflt_mul_dflt(f1, f2):
  return (f1 * f2) ## HX: mul
##
def XATS2PY_dflt_div_dflt(f1, f2):
  return (f1 / f2) ## HX: div
def XATS2PY_dflt_mod_dflt(f1, f2):
  return (f1 % f2) ## HX: mod
##
########################################################################.
########################################################################.
##
def XATS2PY_dflt_ceil(df):
  return math.ceil(df) ## (1.2) = 2
def XATS2PY_dflt_floor(df):
  return math.floor(df) ## (1.2) = 1
def XATS2PY_dflt_round(df):
  ## HX: (1.2) = 1 ## (1.5) = 2
  return math.round(df) ## (-1.5) = 1
def XATS2PY_dflt_trunc(df):
  ## HX: (1.2) = 1 ## (1.9) = 1
  return math.trunc(df) ## (-1.2) = -1
##
########################################################################.
########################################################################.
## end of [ATS3/XANADU_prelude_DATS_CATS_PY_gflt000.cats]
########################################################################.
########################################################################.
`,
  "DATS/CATS/PY/gflt000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Wed Jan  8 02:50:50 AM EST 2025
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
g_si<dflt>
  ( i1 ) =
(
XATS2PY_si2dflt
  ( i1 )) where
{
#extern
fcast
XATS2PY_si2dflt
(i1: sint): dflt = $extnam() }
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
dflt_neg
  ( f1 ) =
(
XATS2PY_dflt_neg
  ( f1 )) where
{
#extern
fun
XATS2PY_dflt_neg
(f1: dflt): dflt = $extnam() }
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
dflt_abs
  ( f1 ) =
(
XATS2PY_dflt_abs
  ( f1 )) where
{
#extern
fun
XATS2PY_dflt_abs
(f1: dflt): dflt = $extnam() }
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
dflt_sqrt
  ( f1 ) =
(
XATS2PY_dflt_sqrt
  ( f1 )) where
{
#extern
fun
XATS2PY_dflt_sqrt
(f1: dflt): dflt = $extnam() }
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
dflt_cbrt
  ( f1 ) =
(
XATS2PY_dflt_cbrt
  ( f1 )) where
{
#extern
fun
XATS2PY_dflt_cbrt
(f1: dflt): dflt = $extnam() }
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
dflt_lt$dflt
  (f1, f2) =
(
XATS2PY_dflt_lt$dflt
  (f1, f2)) where
{
#extern
fun
XATS2PY_dflt_lt$dflt
(f1: dflt, f2: dflt): bool = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_gt_dflt
  (f1, f2) =
(
XATS2PY_dflt_gt$dflt
  (f1, f2)) where
{
#extern
fun
XATS2PY_dflt_gt$dflt
(f1: dflt, f2: dflt): bool = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_eq$dflt
  (f1, f2) =
(
XATS2PY_dflt_eq$dflt
  (f1, f2)) where
{
#extern
fun
XATS2PY_dflt_eq$dflt
(f1: dflt, f2: dflt): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
dflt_lte$dflt
  (f1, f2) =
(
XATS2PY_dflt_lte$dflt
  (f1, f2)) where
{
#extern
fun
XATS2PY_dflt_lte$dflt
(f1: dflt, f2: dflt): bool = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_gte$dflt
  (f1, f2) =
(
XATS2PY_dflt_gte$dflt
  (f1, f2)) where
{
#extern
fun
XATS2PY_dflt_gte$dflt
(f1: dflt, f2: dflt): bool = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_neq$dflt
  (f1, f2) =
(
XATS2PY_dflt_neq$dflt
  (f1, f2)) where
{
#extern
fun
XATS2PY_dflt_neq$dflt
(f1: dflt, f2: dflt): bool = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
dflt_add$dflt
  (f1, f2) =
(
XATS2PY_dflt_add$dflt
  (f1, f2)) where
{
#extern
fun
XATS2PY_dflt_add$dflt
(f1: dflt, f2: dflt): dflt = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_sub$dflt
  (f1, f2) =
(
XATS2PY_dflt_sub$dflt
  (f1, f2)) where
{
#extern
fun
XATS2PY_dflt_sub$dflt
(f1: dflt, f2: dflt): dflt = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_mul$dflt
  (f1, f2) =
(
XATS2PY_dflt_mul$dflt
  (f1, f2)) where
{
#extern
fun
XATS2PY_dflt_mul$dflt
(f1: dflt, f2: dflt): dflt = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_div$dflt
  (f1, f2) =
(
XATS2PY_dflt_div$dflt
  (f1, f2)) where
{
#extern
fun
XATS2PY_dflt_div$dflt
(f1: dflt, f2: dflt): dflt = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_mod$dflt
  (f1, f2) =
(
XATS2PY_dflt_mod$dflt
  (f1, f2)) where
{
#extern
fun
XATS2PY_dflt_mod$dflt
(f1: dflt, f2: dflt): dflt = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
dflt_print
  ( f0 ) =
(
XATS2PY_dflt_print
  ( f0 )) where
{
#extern
fun
XATS2PY_dflt_print(f0: dflt): void = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
dflt_ceil
  ( df ) =
(
XATS2PY_dflt_ceil
  ( df )) where
{
#extern
fun
XATS2PY_dflt_ceil(df: dflt): dflt = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_floor
  ( df ) =
(
XATS2PY_dflt_floor
  ( df )) where
{
#extern
fun
XATS2PY_dflt_floor(df: dflt): dflt = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_round
  ( df ) =
(
XATS2PY_dflt_round
  ( df )) where
{
#extern
fun
XATS2PY_dflt_round(df: dflt): dflt = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_trunc
  ( df ) =
(
XATS2PY_dflt_trunc
  ( df )) where
{
#extern
fun
XATS2PY_dflt_trunc(df: dflt): dflt = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)

(* end of [ATS3/XANADU_prelude_DATS_CATS_PY_gint000.dats] *)
`,
  "DATS/CATS/PY/gint000.cats": `########################################################################.
##                                                                    ##.
##                         Applied Type System                        ##.
##                                                                    ##.
########################################################################.

##
## ATS/Xanadu - Unleashing the Potential of Types!
## Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
## All rights reserved
##
## ATS is free software;  you can  redistribute it and/or modify it under
## the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
## Free Software Foundation; either version 3, or (at  your  option)  any
## later version.
## 
## ATS is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
## FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
## for more details.
## 
## You  should  have  received  a  copy of the GNU General Public License
## along  with  ATS;  see the  file COPYING.  If not, please write to the
## Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
## 02110-1301, USA.
##

########################################################################.
########################################################################.
##
## Author: Hongwei Xi
## Wed Jan  8 02:50:50 AM EST 2025
## Authoremail: gmhwxiATgmailDOTcom
##
########################################################################.
########################################################################.
##
def XATS2PY_sint_neg(i1):
  return ( -i1 ) ## HX: neg
##
########################################################################.
##
def XATS2PY_sint_lt_sint(i1, i2):
  return (i1 < i2) ## HX: lt
def XATS2PY_sint_gt_sint(i1, i2):
  return (i1 > i2) ## HX: gt
##
def XATS2PY_sint_lte_sint(i1, i2):
  return (i1 <= i2) ## HX: lte
def XATS2PY_sint_gte_sint(i1, i2):
  return (i1 >= i2) ## HX: gte
##
def XATS2PY_sint_eq_sint(i1, i2):
  return (i1 == i2) ## HX: equal
def XATS2PY_sint_neq_sint(i1, i2):
  return (i1 != i2) ## HX: noteq
##
########################################################################.
##
def XATS2PY_sint_add_sint(i1, i2):
  return (i1 + i2) ## HX: add
def XATS2PY_sint_sub_sint(i1, i2):
  return (i1 - i2) ## HX: sub
def XATS2PY_sint_mul_sint(i1, i2):
  return (i1 * i2) ## HX: mul
def XATS2PY_sint_mod_sint(i1, i2):
  return (i1 % i2) ## HX: mod
def XATS2PY_sint_div_sint(i1, i2):
  return (i1 // i2) ## HX: int div
##
########################################################################.
##
def XATS2PY_sint_print(i0):
  sys.stdout.write(str(i0)); return None
##
########################################################################.
########################################################################.
## end of [ATS3/XANADU_prelude_DATS_CATS_PY_gint000.cats]
########################################################################.
########################################################################.
`,
  "DATS/CATS/PY/gint000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Wed Jan  8 02:50:50 AM EST 2025
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
sint_neg
  ( i1 ) =
(
XATS2PY_sint_neg
  ( i1 )) where
{
#extern
fun
XATS2PY_sint_neg
(i1: sint): sint = $extnam() }
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
sint_lt$sint
  (i1, i2) =
(
XATS2PY_sint_lt$sint
  (i1, i2)) where
{
#extern
fun
XATS2PY_sint_lt$sint
(i1: sint, i2: sint): bool = $extnam()
}
//
#impltmp
<(*tmp*)>
sint_gt$sint
  (i1, i2) =
(
XATS2PY_sint_gt$sint
  (i1, i2)) where
{
#extern
fun
XATS2PY_sint_gt$sint
(i1: sint, i2: sint): bool = $extnam()
}
//
#impltmp
<(*tmp*)>
sint_eq$sint
  (i1, i2) =
(
XATS2PY_sint_eq$sint
  (i1, i2)) where
{
#extern
fun
XATS2PY_sint_eq$sint
(i1: sint, i2: sint): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
sint_lte$sint
  (i1, i2) =
(
XATS2PY_sint_lte$sint
  (i1, i2)) where
{
#extern
fun
XATS2PY_sint_lte$sint
(i1: sint, i2: sint): bool = $extnam()
}
//
#impltmp
<(*tmp*)>
sint_gte$sint
  (i1, i2) =
(
XATS2PY_sint_gte$sint
  (i1, i2)) where
{
#extern
fun
XATS2PY_sint_gte$sint
(i1: sint, i2: sint): bool = $extnam()
}
//
#impltmp
<(*tmp*)>
sint_neq$sint
  (i1, i2) =
(
XATS2PY_sint_neq$sint
  (i1, i2)) where
{
#extern
fun
XATS2PY_sint_neq$sint
(i1: sint, i2: sint): bool = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
sint_add$sint
  (i1, i2) =
(
XATS2PY_sint_add$sint
  (i1, i2)) where
{
#extern
fun
XATS2PY_sint_add$sint
(i1: sint, i2: sint): sint = $extnam()
}
//
#impltmp
<(*tmp*)>
sint_sub$sint
  (i1, i2) =
(
XATS2PY_sint_sub$sint
  (i1, i2)) where
{
#extern
fun
XATS2PY_sint_sub$sint
(i1: sint, i2: sint): sint = $extnam()
}
//
#impltmp
<(*tmp*)>
sint_mul$sint
  (i1, i2) =
(
XATS2PY_sint_mul$sint
  (i1, i2)) where
{
#extern
fun
XATS2PY_sint_mul$sint
(i1: sint, i2: sint): sint = $extnam()
}
//
#impltmp
<(*tmp*)>
sint_div$sint
  (i1, i2) =
(
XATS2PY_sint_div$sint
  (i1, i2)) where
{
#extern
fun
XATS2PY_sint_div$sint
(i1: sint, i2: sint): sint = $extnam()
}
//
#impltmp
<(*tmp*)>
sint_mod$sint
  (i1, i2) =
(
XATS2PY_sint_mod$sint
  (i1, i2)) where
{
#extern
fun
XATS2PY_sint_mod$sint
(i1: sint, i2: sint): sint = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
sint_print
  ( i0 ) =
(
XATS2PY_sint_print
  ( i0 )) where
{
#extern
fun
XATS2PY_sint_print(i0: sint): void = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)

(* end of [ATS3/XANADU_prelude_DATS_CATS_PY_gint000.dats] *)
`,
  "DATS/CATS/PY/list000.cats": `########################################################################.
##                                                                    ##.
##                         Applied Type System                        ##.
##                                                                    ##.
########################################################################.

##
## ATS/Xanadu - Unleashing the Potential of Types!
## Copyright (C) 2026 Hongwei Xi, ATS Trustful Software, Inc.
## All rights reserved
##
## ATS is free software;  you can  redistribute it and/or modify it under
## the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
## Free Software Foundation; either version 3, or (at  your  option)  any
## later version.
## 
## ATS is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
## FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
## for more details.
## 
## You  should  have  received  a  copy of the GNU General Public License
## along  with  ATS;  see the  file COPYING.  If not, please write to the
## Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
## 02110-1301, USA.
##

########################################################################.
########################################################################.
##
## Author: Hongwei Xi
## Sat Jan  3 05:24:14 PM EST 2026
## Authoremail: gmhwxiATgmailDOTcom
##
########################################################################.
########################################################################.
##
def \\
XATS2PY_list_vt_foritm0_f1un \\
  (xs, work):
  while (True):
    if XATS2PY_list_vt_nilq1(xs):
      break
    else:
      x1 = XATS2PY_list_vt_head_raw1(xs)
      work(x1)
      xs = XATS2PY_list_vt_tail_raw0(xs)
    ## end-of-(if(XATS2PY_list_vt_nilq1(xs)))
  return None ## XATS2PY_list_vt_foritm0_f1un(...)
##
########################################################################.
##
def \\
XATS2PY_list_vt_forall0_f1un \\
  (xs, test, free):
  while (True):
    if (XATS2PY_list_vt_nilq1(xs)):
      break
    else:
      x1 = XATS2PY_list_vt_head_raw1(xs)
      if (test(x1)):
        xs = XATS2PY_list_vt_tail_raw0(xs)
      else:
        xs = XATS2PY_list_vt_tail_raw0(xs)
        XATS2PY_list_vt_foritm0_f1un(xs, free)
        return False
    ## end-of-(if(XATS2PY_list_vt_nilq1(xs)))
  return True ## XATS2PY_list_vt_forall0_f1un(...)
##
########################################################################.
########################################################################.
## end of [ATS3/XANADU_prelude_DATS_CATS_PY_list000.cats]
########################################################################.
########################################################################.
`,
  "DATS/CATS/PY/list000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2026 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Sat Jan  3 05:24:14 PM EST 2026
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#extern
fun
XATS2PY_list_vt_foritm0$f1un
{x0:vt}
( xs
: list_vt(x0)
, work
: (~x0) -> void): void
= $extnam()//extern(./list000.cats)
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
list_vt_foritm0
  (  xs  ) =
let
fun
work(x0: ~x0): void =
(
  foritm$work0<x0>(x0))
in//let
XATS2PY_list_vt_foritm0$f1un{x0}(xs, work)
end(*let*)//end-of-[ list_vt_foritm0<x0>(xs) ]
//
(* ****** ****** *)
(* ****** ****** *)
//
#extern
fun
XATS2PY_list_vt_forall0$f1un
{x0:vt}
( xs
: list_vt(x0)
, test
: (~x0) -> bool
, free
: (~x0) -> void): bool
= $extnam()//extern(./list000.cats)
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
list_vt_forall0
  (  xs  ) =
let
fun
test(x0: ~x0): bool =
(
  forall$test0<x0>(x0))
fun
free(x0: ~x0): void = g_free<x0>(x0)
in//let
XATS2PY_list_vt_forall0$f1un{x0}(xs, test, free)
end(*let*)//end-of-[list_vt_forall0<x0>(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_CATS_PY_list000.dats] *)
(***********************************************************************)
`,
  "DATS/CATS/PY/optn000.cats": `########################################################################.
##                                                                    ##.
##                         Applied Type System                        ##.
##                                                                    ##.
########################################################################.

##
## ATS/Xanadu - Unleashing the Potential of Types!
## Copyright (C) 2026 Hongwei Xi, ATS Trustful Software, Inc.
## All rights reserved
##
## ATS is free software;  you can  redistribute it and/or modify it under
## the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
## Free Software Foundation; either version 3, or (at  your  option)  any
## later version.
## 
## ATS is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
## FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
## for more details.
## 
## You  should  have  received  a  copy of the GNU General Public License
## along  with  ATS;  see the  file COPYING.  If not, please write to the
## Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
## 02110-1301, USA.
##

########################################################################.
########################################################################.
##
## Author: Hongwei Xi
## Sat Jan  3 05:24:14 PM EST 2026
## Authoremail: gmhwxiATgmailDOTcom
##
########################################################################.
########################################################################.
##
## HX: It is yet to be populated!
##
########################################################################.
########################################################################.
## end of [ATS3/XANADU_prelude_DATS_CATS_PY_optn000.cats]
########################################################################.
########################################################################.
`,
  "DATS/CATS/PY/optn000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2026 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Sat Jan  3 05:24:14 PM EST 2026
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_CATS_PY_optn000.dats] *)
(***********************************************************************)
`,
  "DATS/CATS/PY/precats.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2026 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Sat Jan  3 04:14:44 PM EST 2026
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-03:
For implementing operations
in PY that can be called in ATS.
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
//
(*
HX-2026-01-03:
Already inside
[xats2py_py1emit.py]!
*)
//
#extern
fun
XATS2PY_optn_nil
{a:t0}
((*0*)): optn(a) = $extnam()
#implfun
XATS2PY_optn_nil() = optn_nil()
#extern
fun
XATS2PY_optn_cons
{a:t0}
(x0: a): optn(a) = $extnam()
#implfun
XATS2PY_optn_cons(x0) = optn_cons(x0)
//
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#extern
fun
XATS2PY_optn_nilq
{a:t0}
( xs
: optn(a)): bool = $extnam()
#implfun
XATS2PY_optn_nilq(xs) =
(
case+ xs of
|optn_nil() => true |optn_cons _ => false)
//
#extern
fun
XATS2PY_optn_consq
{a:t0}
( xs
: optn(a)): bool = $extnam()
#implfun
XATS2PY_optn_consq(xs) =
(
case+ xs of
|optn_nil() => false |optn_cons _ => (true))
//
(* ****** ****** *)
//
#extern
fun
XATS2PY_optn_head$raw
{a:t0}
( xs
: optn(a)): (a) = $extnam()
#implfun
XATS2PY_optn_head$raw(xs) =
(
case- xs of optn_cons(x0) => (x0))
//
#extern
fun
XATS2PY_optn_uncons$raw
{a:t0}
( xs
: optn(a)): (a) = $extnam()
#implfun
XATS2PY_optn_uncons$raw(xs) =
(
case- xs of optn_cons(x0) => (x0))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
//
(*
HX-2026-01-03:
Already inside
[xats2py_py1emit.py]!
*)
//
#extern
fun
XATS2PY_list_nil
{a:t0}
((*0*)): list(a) = $extnam()
#implfun
XATS2PY_list_nil() = list_nil()
#extern
fun
XATS2PY_list_cons
{a:t0}
( x1: a//head
, xs: list(a)): list(a) = $extnam()
#implfun
XATS2PY_list_cons(x1,xs) = list_cons(x1,xs)
//
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
//
#extern
fun
XATS2PY_list_nilq
{a:t0}
( xs
: list(a)): bool = $extnam()
#implfun
XATS2PY_list_nilq(xs) =
(
case+ xs of
|list_nil() => true |list_cons _ => false)
//
#extern
fun
XATS2PY_list_consq
{a:t0}
( xs
: list(a)): bool = $extnam()
#implfun
XATS2PY_list_consq(xs) =
(
case+ xs of
|list_nil() => false |list_cons _ => (true))
//
(* ****** ****** *)
//
#extern
fun
XATS2PY_list_head$raw
{a:t0}
( xs
: list(a)): (a) = $extnam()
#implfun
XATS2PY_list_head$raw(xs) =
(
case- xs of list_cons(x1, xs) => (x1))
//
(* ****** ****** *)
(* ****** ****** *)
//
#extern
fun
XATS2PY_lazy_make_f0un
{a:t0}
( f0
: ()->(a)): lazy(a) = $extnam()
#implfun
XATS2PY_lazy_make_f0un(f0) = $lazy(f0())
//
(* ****** ****** *)
(* ****** ****** *)
//
#extern
fun
XATS2PY_strmcon_nil
{a:t0}
((*0*)): strmcon(a) = $extnam()
#implfun
XATS2PY_strmcon_nil() = strmcon_nil()
//
#extern
fun
XATS2PY_strmcon_cons
{a:t0}
(x1: a//head
,xs: strm(a)): strmcon(a) = $extnam()
#implfun
XATS2PY_strmcon_cons(x1,xs) = strmcon_cons(x1,xs)
//
(* ****** ****** *)
//
#extern
fun
XATS2PY_strmcon_nilq
{a:t0}
( xs
: strmcon(a)): bool = $extnam()
#implfun
XATS2PY_strmcon_nilq(xs) =
(
case+ xs of
|strmcon_nil() => true |strmcon_cons _ => false)
//
#extern
fun
XATS2PY_strmcon_consq
{a:t0}
( xs
: strmcon(a)): bool = $extnam()
#implfun
XATS2PY_strmcon_consq(xs) =
(
case+ xs of
|strmcon_nil() => false |strmcon_cons _ => (true))
//
(* ****** ****** *)
//
#extern
fun
XATS2PY_strmcon_head$raw
{a:t0}
( xs
: strmcon(a)): (a) = $extnam()
#implfun
XATS2PY_strmcon_head$raw(xs) =
(
case- xs of strmcon_cons(x1, xs) => (x1))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-03: For VT!
*)
(* ****** ****** *)
(* ****** ****** *)
//
(*
//
(*
HX-2026-01-03:
Already inside
[xats2py_py1emit.py]!
*)
//
#extern
fun
XATS2PY_optn_vt_nil
{a:vt}
((*0*)): optn_vt(a) = $extnam()
#implfun
XATS2PY_optn_vt_nil() = optn_vt_nil()
#extern
fun
XATS2PY_optn_vt_cons
{a:vt}
(x0: a): optn_vt(a) = $extnam()
#implfun
XATS2PY_optn_vt_cons(x0) = optn_vt_cons(x0)
//
*)
//
(* ****** ****** *)
//
#extern
fun
XATS2PY_optn_vt_nilq1
{a:vt}
( xs:
! optn_vt(a)): bool = $extnam()
#implfun
XATS2PY_optn_vt_nilq1(xs) =
(
case+ xs of
|optn_vt_nil()=>true|optn_vt_cons(x0)=>false)
//
#extern
fun
XATS2PY_optn_vt_consq1
{a:vt}
( xs:
! optn_vt(a)): bool = $extnam()
#implfun
XATS2PY_optn_vt_consq1(xs) =
(
case+ xs of
|optn_vt_nil()=>false|optn_vt_cons(x0)=>(true))
//
(* ****** ****** *)
//
#extern
fun
XATS2PY_optn_vt_head$raw0
{a:vt}
( xs
: optn_vt(a)): (a) = $extnam()
#implfun
XATS2PY_optn_vt_head$raw0(xs) =
(
case- xs of ~optn_vt_cons(x0) => (x0))
//
#extern
fun
XATS2PY_optn_vt_uncons$raw0
{a:vt}
( xs
: optn_vt(a)): (a) = $extnam()
#implfun
XATS2PY_optn_vt_uncons$raw0(xs) =
(
case- xs of ~optn_vt_cons(x0) => (x0))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
//
(*
HX-2026-01-03:
Already inside
[xats2py_py1emit.py]!
*)
//
#extern
fun
XATS2PY_list_vt_nil
{a:vt}
((*0*)): list_vt(a) = $extnam()
#implfun
XATS2PY_list_vt_nil() = list_vt_nil()
#extern
fun
XATS2PY_list_vt_cons
{a:vt}
( x1: a//head
, xs: list_vt(a)): list_vt(a) = $extnam()
#implfun
XATS2PY_list_vt_cons(x1,xs) = list_vt_cons(x1,xs)
//
*)
//
(* ****** ****** *)
//
#extern
fun
XATS2PY_list_vt_nilq1
{a:vt}
( xs:
! list_vt(a)): bool = $extnam()
#implfun
XATS2PY_list_vt_nilq1(xs) =
(
case+ xs of
|list_vt_nil()=>true|list_vt_cons _ => false)
//
#extern
fun
XATS2PY_list_vt_consq1
{a:vt}
( xs:
! list_vt(a)): bool = $extnam()
#implfun
XATS2PY_list_vt_consq1(xs) =
(
case+ xs of
|list_vt_nil()=>false|list_vt_cons _ => (true))
//
(* ****** ****** *)
//
#extern
fun
XATS2PY_list_vt_head$raw1
{a:vt}
( xs
: list_vt(a)): (a) = $extnam()
#implfun
XATS2PY_list_vt_head$raw1(xs) =
(
case- xs of
|
list_vt_cons
(  x1, xs  ) =>
let
val x1 =
$UN.datacopy(x1) in $UN.enlinear(x1) end)
//
#extern
fun
XATS2PY_list_vt_tail$raw0
{a:vt}
( xs:
~ list_vt(a)): list_vt(a) = $extnam()
#implfun
XATS2PY_list_vt_tail$raw0(xs) =
case- xs of
| ~
list_vt_cons
(  x1, xs  ) =>
(
  let val x1 = $UN.delinear(x1) in xs end)
//
(* ****** ****** *)
(* ****** ****** *)
//
#extern
fun
XATS2PY_lazy_vt_eval
{a:vt}
( lz:
~ lazy_vt(a)): (a) = $extnam()
#implfun
XATS2PY_lazy_vt_eval(lz) = $eval(lz)
//
#extern
fun
XATS2PY_lazy_vt_free
{a:vt}
( lz:
~ lazy_vt(a)): void = $extnam()
#implfun
XATS2PY_lazy_vt_free(lz) = $free(lz)
//
(* ****** ****** *)
//
#extern
fun
XATS2PY_lazy_vt_make_f0un
{a:vt}
( f0
: ()->(a)): lazy_vt(a) = $extnam()
#implfun
XATS2PY_lazy_vt_make_f0un(f0) = $llazy(f0())
//
(* ****** ****** *)
(* ****** ****** *)
//
#extern
fun
XATS2PY_strmcon_vt_nil
{a:vt}
((*0*)): strmcon_vt(a) = $extnam()
#implfun
XATS2PY_strmcon_vt_nil() = strmcon_vt_nil()
//
#extern
fun
XATS2PY_strmcon_vt_cons
{a:vt}
(x1: a//head
,xs: strm_vt(a)): strmcon_vt(a) = $extnam()
#implfun
XATS2PY_strmcon_vt_cons(x1,xs) = strmcon_vt_cons(x1,xs)
//
(* ****** ****** *)
//
#extern
fun
XATS2PY_strmcon_vt_nilq1
{a:vt}
( xs:
! strmcon_vt(a)): bool = $extnam()
#implfun
XATS2PY_strmcon_vt_nilq1(xs) =
(
case+ xs of
|strmcon_vt_nil()=>true|strmcon_vt_cons _ =>false)
//
#extern
fun
XATS2PY_strmcon_vt_consq1
{a:vt}
( xs:
! strmcon_vt(a)): bool = $extnam()
#implfun
XATS2PY_strmcon_vt_consq1(xs) =
(
case+ xs of
|strmcon_vt_nil()=>false|strmcon_vt_cons _ =>(true))
//
(* ****** ****** *)
//
#extern
fun
XATS2PY_strmcon_vt_head$raw1
{a:vt}
( xs:
! strmcon_vt(a)): (a) = $extnam()
#implfun
XATS2PY_strmcon_vt_head$raw1(xs) =
(
case- xs of
|
strmcon_vt_cons
(   x1 , xs   ) =>
let
val x1 =
$UN.datacopy(x1) in $UN.enlinear(x1) end)
//
#extern
fun
XATS2PY_strmcon_vt_tail$raw0
{a:vt}
( xs:
~ strmcon_vt(a)): strm_vt(a) = $extnam()
#implfun
XATS2PY_strmcon_vt_tail$raw0(xs) =
case- xs of
| ~
strmcon_vt_cons
(   x1 , xs   ) =>
(
  let val x1 = $UN.delinear(x1) in xs end)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_CATS_PY_precats.dats] *)
(***********************************************************************)
`,
  "DATS/CATS/PY/strm000.cats": `########################################################################.
##                                                                    ##.
##                         Applied Type System                        ##.
##                                                                    ##.
########################################################################.

##
## ATS/Xanadu - Unleashing the Potential of Types!
## Copyright (C) 2026 Hongwei Xi, ATS Trustful Software, Inc.
## All rights reserved
##
## ATS is free software;  you can  redistribute it and/or modify it under
## the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
## Free Software Foundation; either version 3, or (at  your  option)  any
## later version.
## 
## ATS is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
## FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
## for more details.
## 
## You  should  have  received  a  copy of the GNU General Public License
## along  with  ATS;  see the  file COPYING.  If not, please write to the
## Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
## 02110-1301, USA.
##

########################################################################.
########################################################################.
##
## Author: Hongwei Xi
## Sat Jan  3 04:47:20 PM EST 2026
## Authoremail: gmhwxiATgmailDOTcom
##
########################################################################.
########################################################################.
##
def \\
XATS2PY_strm_vt_forall0_f1un \\
  (fxs, test):
  while (True):
    cxs = XATS2PY_lazy_vt_eval(fxs)
    if XATS2PY_strmcon_vt_nilq1(cxs):
      break
    else:
      x01 = XATS2PY_strmcon_vt_head_raw1(cxs)
      if (test(x01)):
        fxs = XATS2PY_strmcon_vt_tail_raw0(cxs)
      else:
        fxs = XATS2PY_strmcon_vt_tail_raw0(cxs)
        XATS2PY_lazy_vt_free(fxs)
        return False
      ## end-of-(if(test(x01))
    ## end-of-(if(XATS2PY_strmcon_vt_nilq1(cxs)))
  return true ## XATS2PY_strm_vt_forall0_f1un(...)
##
########################################################################.
##
def \\
XATS2PY_strm_vt_filter0_f1un \\
  (fxs, test, free):
  return XATS2PY_lazy_vt_make_f0un(
    lambda: XATS2PY_strmcon_vt_filter0_f1un(XATS2PY_lazy_vt_eval(fxs), test, free)
  )
##
def \\
XATS2PY_strmcon_vt_filter0_f1un \\
  (cxs, test, free):
  while (True):
    if XATS2PY_strmcon_vt_nilq1(cxs):
      return XATS2PY_strmcon_vt_nil()
    else:
      x01 = XATS2PY_strmcon_vt_head_raw1(cxs)
      fxs = XATS2PY_strmcon_vt_tail_raw0(cxs)
      if (test(x01)):
        return XATS2PY_strmcon_vt_cons(x01, XATS2PY_strm_vt_filter0_f1un(fxs, test, free))
      else:
        free(x01)
        cxs = XATS2PY_lazy_vt_eval(fxs)
        continue
      ## end-of-(if(test(x01))
    ## end-of-(if(XATS2PY_strmcon_vt_nilq1(cxs))
##
########################################################################.
########################################################################.
## end of [ATS3/XANADU_prelude_DATS_CATS_PY_strm000.cats]
########################################################################.
########################################################################.
`,
  "DATS/CATS/PY/strm000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2026 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Fri Jan  2 03:05:42 PM EST 2026
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#extern
fun
XATS2PY_strm_vt_forall0$f1un
{x0:vt}
( xs
: strm_vt(x0)
, test
: (~x0) -> bool): bool
= $extnam()//extern(./strm000.cats)
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
strm_vt_forall0
  (  xs  ) =
let
fun
test(x0: ~x0): bool =
(
  forall$test0<x0>(x0))
in//let
XATS2PY_strm_vt_forall0$f1un{x0}(xs, test)
end(*let*)//end-of-[strm_vt_forall0<x0>(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#extern
fun
XATS2PY_strm_vt_filter0$f1un
{x0:vt}
( xs
: strm_vt(x0)
, test
: (!x0) -> bool
, free
: (~x0) -> void): strm_vt(x0)
= $extnam()//extern(./strm000.cats)
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
strm_vt_filter0
  (  xs  ) =
let
fun
test(x0: !x0): bool =
(
  filter$test1<x0>(x0))
fun
free(x0: ~x0): void = g_free<x0>(x0)
in//let
XATS2PY_strm_vt_filter0$f1un{x0}(xs, test, free)
end(*let*)//end-of-[strm_vt_filter0<x0>(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_CATS_PY_strm000.dats] *)
(***********************************************************************)
`,
  "DATS/CATS/PY/strn000.cats": `########################################################################.
##                                                                    ##.
##                         Applied Type System                        ##.
##                                                                    ##.
########################################################################.

##
## ATS/Xanadu - Unleashing the Potential of Types!
## Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
## All rights reserved
##
## ATS is free software;  you can  redistribute it and/or modify it under
## the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
## Free Software Foundation; either version 3, or (at  your  option)  any
## later version.
## 
## ATS is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
## FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
## for more details.
## 
## You  should  have  received  a  copy of the GNU General Public License
## along  with  ATS;  see the  file COPYING.  If not, please write to the
## Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
## 02110-1301, USA.
##

########################################################################.
########################################################################.
##
## Author: Hongwei Xi
## Wed Jan  8 02:46:58 AM EST 2025
## Authoremail: gmhwxiATgmailDOTcom
##
########################################################################.
########################################################################.
##
def XATS2PY_strn_cmp(x1, x2):
  df = 0
  i0 = 0
  n1 = len(x1)
  n2 = len(x2)
  n0 = n1 if (n1 <= n2) else n2
  while (i0 < n0):
    df = ord(x1[i0]) - ord(x2[i0])
    if (df != 0):
      return df
    else:
      i0 = i0 + 1
  return (n1 - n2)
##
########################################################################.
##
def XATS2PY_strn_length(cs):
  return len(cs) # PY special [len]
def XATS000_strn_length(cs):
  return len(cs) # PY special [len]
##
########################################################################.
##
def XATS2PY_strn_print(cs):
  sys.stdout.write(cs); return None
##
########################################################################.
##
def XATS2PY_strn_get_at_raw(cs, i0):
  return ord(cs[i0]) # PY is charless
def XATS000_strn_get_at_raw(cs, i0):
  return XATS2PY_strn_get_at_raw(cs, i0)
##
########################################################################.
##
def XATS2PY_strn_fmake_fwork(fwork):
  res = []
  fwork(lambda ch: res.append(chr(ch)))
  return "".join(res)
def XATS000_strn_fmake_fwork(fwork):
  return XATS2PY_strn_fmake_fwork(fwork)
##
########################################################################.
##
def \\
XATS2PY_strn_fmake_env_fwork(env, fwork):
  res = []
  fwork(env, lambda ch: res.append(chr(ch)))
  return "".join(res)
def \\
XATS2PY_strn_fmake1_env_fwork(env, fwork):
  res = []
  fwork(env, lambda ch: res.append(chr(ch)))
  return "".join(res)
##
def XATS000_strn_fmake_env_fwork(env, fwork):
  return XATS2PY_strn_fmake_env_fwork(env, fwork)
def XATS000_strn_fmake1_env_fwork(env, fwork):
  return XATS2PY_strn_fmake1_env_fwork(env, fwork)
##
########################################################################.
########################################################################.
## end of [ATS3/XANADU_prelude_DATS_CATS_PY_strn000.cats]
########################################################################.
########################################################################.
`,
  "DATS/CATS/PY/strn000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Wed Jan  8 02:46:58 AM EST 2025
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
strn_length
  ( cs ) =
(
XATS2PY_strn_length
  ( cs )) where
{
#extern
fun
XATS2PY_strn_length
  (cs: strn): nint = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
strn_cmp
  (x1, x2) =
(
XATS2PY_strn_cmp
  (x1, x2)) where
{
#extern
fun
XATS2PY_strn_cmp
(x1: strn, x2: strn): nint = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
strn_print
  ( cs ) =
(
XATS2PY_strn_print
  ( cs )) where
{
#extern
fun
XATS2PY_strn_print(cs: strn): void = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)

(* end of [ATS3/XANADU_prelude_DATS_CATS_PY_strn000.dats] *)
`,
  "DATS/CATS/PY/strx000.cats": `########################################################################.
##                                                                    ##.
##                         Applied Type System                        ##.
##                                                                    ##.
########################################################################.

##
## ATS/Xanadu - Unleashing the Potential of Types!
## Copyright (C) 2026 Hongwei Xi, ATS Trustful Software, Inc.
## All rights reserved
##
## ATS is free software;  you can  redistribute it and/or modify it under
## the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
## Free Software Foundation; either version 3, or (at  your  option)  any
## later version.
## 
## ATS is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
## FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
## for more details.
## 
## You  should  have  received  a  copy of the GNU General Public License
## along  with  ATS;  see the  file COPYING.  If not, please write to the
## Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
## 02110-1301, USA.
##

########################################################################.
########################################################################.
##
## Author: Hongwei Xi
## Wed Jan 14 02:42:28 PM EST 2026
## Authoremail: gmhwxiATgmailDOTcom
##
########################################################################.
########################################################################.
##
def \\
XATS2PY_strx_vt_forall0_f1un \\
  (fxs, test):
  while (True):
    cxs = XATS2PY_lazy_vt_eval(fxs)
    x01 = XATS2PY_strxcon_vt_head_raw1(cxs)
    if (test(x01)):
      fxs = XATS2PY_strxcon_vt_tail_raw0(cxs)
    else:
      fxs = XATS2PY_strxcon_vt_tail_raw0(cxs)
      XATS2PY_lazy_vt_free(fxs)
      return False
    ## end-of-(if(test(x01)))
  return true ## XATS2PY_strx_vt_forall0_f1un(...)
##
########################################################################.
##
def \\
XATS2PY_strx_vt_filter0_f1un \\
  (fxs, test, free):
  return XATS2PY_lazy_vt_make_f0un(
    lambda: XATS2PY_strxcon_vt_filter0_f1un(XATS2PY_lazy_vt_eval(fxs), test, free)
  )
##
def \\
XATS2PY_strxcon_vt_filter0_f1un \\
  (cxs, test, free):
  while (True):
    x01 = XATS2PY_strxcon_vt_head_raw1(cxs)
    fxs = XATS2PY_strxcon_vt_tail_raw0(cxs)
    if (test(x01)):
      return XATS2PY_strxcon_vt_cons(x01, XATS2PY_strx_vt_filter0_f1un(fxs, test, free))
    else:
      free(x01)
      cxs = XATS2PY_lazy_vt_eval(fxs)
      continue
    ## end-of-(if(test(x01))
##
########################################################################.
########################################################################.
## end of [ATS3/XANADU_prelude_DATS_CATS_PY_strx000.cats]
########################################################################.
########################################################################.
`,
  "DATS/CATS/PY/strx000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2026 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Wed Jan 14 02:42:28 PM EST 2026
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#extern
fun
XATS2PY_strx_vt_forall0$f1un
{x0:vt}
( xs
: strx_vt(x0)
, test
: (~x0) -> bool): bool
= $extnam()//extern(./strx000.cats)
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
strx_vt_forall0
  (  xs  ) =
let
fun
test(x0: ~x0): bool =
(
  forall$test0<x0>(x0))
in//let
XATS2PY_strx_vt_forall0$f1un{x0}(xs, test)
end(*let*)//end-of-[strx_vt_forall0<x0>(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#extern
fun
XATS2PY_strx_vt_filter0$f1un
{x0:vt}
( xs
: strx_vt(x0)
, test
: (!x0) -> bool
, free
: (~x0) -> void): strx_vt(x0)
= $extnam()//extern(./strx000.cats)
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
strx_vt_filter0
  (  xs  ) =
let
fun
test(x0: !x0): bool =
(
  filter$test1<x0>(x0))
fun
free(x0: ~x0): void = g_free<x0>(x0)
in//let
XATS2PY_strx_vt_filter0$f1un{x0}(xs, test, free)
end(*let*)//end-of-[strx_vt_filter0<x0>(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_CATS_PY_strx000.dats] *)
(***********************************************************************)
`,
  "DATS/CATS/PY/xtop000.cats": `########################################################################.
##                                                                    ##.
##                         Applied Type System                        ##.
##                                                                    ##.
########################################################################.

##
## ATS/Xanadu - Unleashing the Potential of Types!
## Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
## All rights reserved
##
## ATS is free software;  you can  redistribute it and/or modify it under
## the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
## Free Software Foundation; either version 3, or (at  your  option)  any
## later version.
## 
## ATS is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
## FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
## for more details.
## 
## You  should  have  received  a  copy of the GNU General Public License
## along  with  ATS;  see the  file COPYING.  If not, please write to the
## Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
## 02110-1301, USA.
##

########################################################################.
########################################################################.
##
## Author: Hongwei Xi
## Wed Jan  8 02:38:30 AM EST 2025
## Authoremail: gmhwxiATgmailDOTcom
##
########################################################################.
########################################################################.
import sys
########################################################################.
########################################################################.
## end of [ATS3/XANADU_prelude_DATS_CATS_PY_xtop000.cats]
########################################################################.
########################################################################.
`,
  "DATS/CATS/PY/xtop000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Wed Jan  1 03:23:42 PM EST 2025
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)

(* end of [ATS3/XANADU_prelude_DATS_CATS_PY_xtop000.dats] *)
`,
  "DATS/CATS/axrf000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Mon 12 Aug 2024 09:36:20 AM EDT
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#absimpl
a0rf_vt_tx
(  a:vt  ) = $extbox("a0rf_tx")
#absimpl
a0rf_vt_vx
(  a:vt  ) = $extbox("a0rf_vx")
//
(* ****** ****** *)
//
#absimpl
a1rf_vt_i0_tx
( a:vt,n:i0 ) = $extbox("a1rf_tx")
#absimpl
a1rf_vt_i0_vx
( a:vt,n:i0 ) = $extbox("a1rf_vx")
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: vt >
a0rf_lget
  ( A ) =
(
XATS000_a0rf_lget
  ( A )) where
{
#extern
fun
XATS000_a0rf_lget
{a:vt}
( A
: a0rf(a))
: (owed(a) | a) = $extnam()
}
//
#impltmp
< a: vt >
a0rf_lset
(f | A, x) =
(
XATS000_a0rf_lset
  (f | A, x)) where
{
#extern
fun
XATS000_a0rf_lset
{a:vt}
(f:owed(a)
|A:a0rf(a), x:a): void = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: vt >
a0rf_make_1val
  ( x1 ) =
(
XATS000_a0rf_make_1val
  ( x1 )) where
{
#extern
fun
XATS000_a0rf_make_1val
{a:vt}( x1: a ): a0rf(a) = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: vt >
a1rf_lget$at
  (A, i) =
(
XATS000_a1rf_lget$at
  (A, i)) where
{
#extern
fun
XATS000_a1rf_lget$at
{a:vt}
( A
: a1rf(a)
, i: nint): (owed(a) | a) = $extnam()
}
//
#impltmp
< a: vt >
a1rf_lset$at
  (f | A, i, x) =
(
XATS000_a1rf_lset$at
  (f | A, i, x)) where
{
#extern
fun
XATS000_a1rf_lset$at
{a:vt}
(f:owed(a)
|A:a1rf(a),i:nint,x:a): void = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: t0 >
a1rf_make_ncpy
  (n, x) =
(
XATS000_a1rf_make_ncpy
  (n, x)) where
{
#extern
fun
XATS000_a1rf_make_ncpy
{a:t0}(n:nint, x:a): a1rf(a) = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
< a: vt >
a1rf_make_nfun
  (n, f) =
(
XATS000_a1rf_make_nfun
  (n, f)) where
{
#extern
fun
XATS000_a1rf_make_nfun
{a:t0}
(n:nint, f:(nint)->(a)): a1rf(a) = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(* ****** ****** *)(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)(* ****** ****** *)

(* end of [ATS3/XANADU_prelude_DATS_CATS_axrf000.dats] *)
`,
  "DATS/CATS/axsz000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Thu 15 Aug 2024 05:05:45 AM EDT
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#absimpl
a1sz_vt_i0_tx
(a: vt, n: i0) = $extbox("a1sz_tx")
#absimpl
a1sz_vt_i0_vx
(a: vt, n: i0) = $extbox("a1sz_vx")
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: vt >
a1sz_length
 {n:i0}( A ) =
(
XATS000_a1sz_length
 {a}{n}( A )) where
{
#extern
fun
XATS000_a1sz_length
{a:vt}
{n:i0}
(A: a1sz(a, n)): sint(n) = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: vt >
a1sz_lget$at
  (A, i) =
(
XATS000_a1sz_lget$at
  (A, i)) where
{
#extern
fun
XATS000_a1sz_lget$at
{a:vt}
( A
: a1sz(a)
, i: nint): (owed(a) | a) = $extnam()
}
//
#impltmp
< a: vt >
a1sz_lset$at
  (f | A, i, x) =
(
XATS000_a1sz_lset$at
  (f | A, i, x)) where
{
#extern
fun
XATS000_a1sz_lset$at
{a:vt}
(f:owed(a)
|A:a1sz(a),i:nint,x:a): void = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-06:
Fri 06 Sep 2024 03:24:35 PM EDT
*)
//
#impltmp
< x0:t0 >
a1sz_make_none
  ( asz ) =
(
XATS000_a1sz_make_none
  ( asz )) where
{
#extern
fun
XATS000_a1sz_make_none
{n:nat}
(asz: nint(n)): a1sz(x0, n) = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: t0 >
a1sz_make_ncpy
  (n, x) =
(
XATS000_a1sz_make_ncpy
  (n, x)) where
{
#extern
fun
XATS000_a1sz_make_ncpy
{a:t0}(n:nint, x:a): a1sz(a) = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
< a: vt >
a1sz_make_nfun
  (n, f) =
(
XATS000_a1sz_make_nfun
  (n, f)) where
{
#extern
fun
XATS000_a1sz_make_nfun
{a:t0}
(n:nint, f:(nint)->(a)): a1sz(a) = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-17:
Sat 17 Aug 2024 07:33:26 PM EDT
*)
//
#impltmp
< x0:vt >
a1sz_fmake_fwork
  (fwork) =
(
XATS000_a1sz_fmake_fwork
  (fwork)) where
{
#extern
fun
XATS000_a1sz_fmake_fwork
{ x0:vt }
(
fwork:
((~x0) -> void) -> void): a1sz(x0) = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(* ****** ****** *)(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)(* ****** ****** *)

(* end of [ATS3/XANADU_prelude_DATS_CATS_axsz000.dats] *)
`,
  "DATS/CATS/bool000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Sun 01 Sep 2024 04:25:37 PM EDT
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
bool_lt
(b1, b2) =
(
XATS000_bool_lt
  (b1, b2)) where
{
#extern
fun
XATS000_bool_lt
(b1: bool, b2: bool): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
bool_gt
(b1, b2) =
(
XATS000_bool_gt
  (b1, b2)) where
{
#extern
fun
XATS000_bool_gt
(b1: bool, b2: bool): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
bool_eq
(b1, b2) =
(
XATS000_bool_eq
  (b1, b2)) where
{
#extern
fun
XATS000_bool_eq
(b1: bool, b2: bool): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
bool_lte
(b1, b2) =
(
XATS000_bool_lte
  (b1, b2)) where
{
#extern
fun
XATS000_bool_lte
(b1: bool, b2: bool): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
bool_gte
(b1, b2) =
(
XATS000_bool_gte
  (b1, b2)) where
{
#extern
fun
XATS000_bool_gte
(b1: bool, b2: bool): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
bool_neq
(b1, b2) =
(
XATS000_bool_neq
  (b1, b2)) where
{
#extern
fun
XATS000_bool_neq
(b1: bool, b2: bool): bool = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-05:
Thu 05 Sep 2024 11:11:27 AM EDT
*)
//
#impltmp
<(*tmp*)>
bool_print(b0) =
(
if b0
then strn_print<>("true")
else strn_print<>("false"))//end(impl)
//
(* ****** ****** *)
(* ****** ****** *)
//
(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)

(* end of [ATS3/XANADU_prelude_DATS_CATS_bool000.dats] *)
`,
  "DATS/CATS/char000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Sun 01 Sep 2024 04:48:38 PM EDT
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
char_lt
(c1, c2) =
(
XATS000_char_lt
  (c1, c2)) where
{
#extern
fun
XATS000_char_lt
(c1: char, c2: char): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
char_gt
(c1, c2) =
(
XATS000_char_gt
  (c1, c2)) where
{
#extern
fun
XATS000_char_gt
(c1: char, c2: char): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
char_eq
(c1, c2) =
(
XATS000_char_eq
  (c1, c2)) where
{
#extern
fun
XATS000_char_eq
(c1: char, c2: char): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
char_lte
(c1, c2) =
(
XATS000_char_lte
  (c1, c2)) where
{
#extern
fun
XATS000_char_lte
(c1: char, c2: char): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
char_gte
(c1, c2) =
(
XATS000_char_gte
  (c1, c2)) where
{
#extern
fun
XATS000_char_gte
(c1: char, c2: char): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
char_neq
(c1, c2) =
(
XATS000_char_neq
  (c1, c2)) where
{
#extern
fun
XATS000_char_neq
(c1: char, c2: char): bool = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
char_add$sint
  (c1, i2) =
(
XATS000_char_add$sint
  (c1, i2)) where
{
#extern
fun
XATS000_char_add$sint
(c1: char, i2: sint): char = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
char_sub$char
  (c1, c2) =
(
XATS000_char_sub$char
  (c1, c2)) where
{
#extern
fun
XATS000_char_sub$char
(c1: char, c2: char): sint = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-05:
Thu 05 Sep 2024 11:11:27 AM EDT
*)
//
#impltmp
<(*tmp*)>
char_print
  ( c0 ) =
(
XATS000_char_print
  ( c0 )) where
{
#extern
fun
XATS000_char_print(c0: char): void = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-01-19: from gavinz
Sun Jan 19 01:11:19 AM EST 2025
*)
#impltmp
<(*tmp*)>
char_make_sint(i0) =
(
XATS000_char_make_int(i0))
where
{
#extern
fun
XATS000_char_make_int(i0: sint): char = $extnam()
}
//
(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)

(* end of [ATS3/XANADU_prelude_DATS_CATS_char000.dats] *)
`,
  "DATS/CATS/gbas000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Mon 09 Sep 2024 08:48:13 AM EDT
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#extern
fun<>
strn_sint$parse$fwork
( rep0: strn
, work: (sint)->void): void
//
#impltmp
g_parse$opt
< sint >
( rep0 ) =
list_head$opt
(
list_fmake_fwork
(
lam(work) =>
strn_sint$parse$fwork(rep0, work)))
//
#impltmp
<(*tmp*)>
strn_sint$parse$fwork
  (rep0, work) =
(
XATS000_strn_sint$parse$fwork
  (rep0, work)) where
{
#extern
fun
XATS000_strn_sint$parse$fwork
(rep0: strn, work:(sint)->void): void = $extnam()
}
//
(* ****** ****** *)
//
#extern
fun<>
strn_dflt$parse$fwork
( rep0: strn
, work: (dflt)->void): void
//
#impltmp
g_parse$opt
< dflt >
( rep0 ) =
list_head$opt
(
list_fmake_fwork
(
lam(work) =>
strn_dflt$parse$fwork(rep0, work)))
//
#impltmp
<(*tmp*)>
strn_dflt$parse$fwork
  (rep0, work) =
(
XATS000_strn_dflt$parse$fwork
  (rep0, work)) where
{
#extern
fun
XATS000_strn_dflt$parse$fwork
(rep0: strn, work:(dflt)->void): void = $extnam()
}
//
(* ****** ****** *)(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_CATS_gbas000.dats] *)
(***********************************************************************)
`,
  "DATS/CATS/gdbg000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Fri Sep 20 08:59:26 AM EDT 2024
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
bool_assert$errmsg
  (cond, emsg) =
(
XATS000_bool_assert$errmsg
  (cond, emsg)) where
{
#extern
fun
XATS000_bool_assert$errmsg
(cond: bool, emsg: strn): void = $extnam()
}
//
(* ****** ****** *)(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_CATS_gdbg000.dats] *)
(***********************************************************************)
`,
  "DATS/CATS/gflt000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Mon 09 Sep 2024 06:12:39 PM EDT
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
g_si<dflt>
  ( i1 ) =
(
XATS000_si2dflt
  ( i1 )) where
{
#extern
fcast
XATS000_si2dflt
(i1: sint): dflt = $extnam() }
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
dflt_neg
  ( f1 ) =
(
XATS000_dflt_neg
  ( f1 )) where
{
#extern
fun
XATS000_dflt_neg
(f1: dflt): dflt = $extnam() }
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
dflt_abs
  ( f1 ) =
(
XATS000_dflt_abs
  ( f1 )) where
{
#extern
fun
XATS000_dflt_abs
(f1: dflt): dflt = $extnam() }
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
dflt_sqrt
  ( f1 ) =
(
XATS000_dflt_sqrt
  ( f1 )) where
{
#extern
fun
XATS000_dflt_sqrt
(f1: dflt): dflt = $extnam() }
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
dflt_cbrt
  ( f1 ) =
(
XATS000_dflt_cbrt
  ( f1 )) where
{
#extern
fun
XATS000_dflt_cbrt
(f1: dflt): dflt = $extnam() }
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
dflt_lt$dflt
  (f1, f2) =
(
XATS000_dflt_lt$dflt
  (f1, f2)) where
{
#extern
fun
XATS000_dflt_lt$dflt
(f1: dflt, f2: dflt): bool = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_gt$dflt
  (f1, f2) =
(
XATS000_dflt_gt$dflt
  (f1, f2)) where
{
#extern
fun
XATS000_dflt_gt$dflt
(f1: dflt, f2: dflt): bool = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_eq$dflt
  (f1, f2) =
(
XATS000_dflt_eq$dflt
  (f1, f2)) where
{
#extern
fun
XATS000_dflt_eq$dflt
(f1: dflt, f2: dflt): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
dflt_lte$dflt
  (f1, f2) =
(
XATS000_dflt_lte$dflt
  (f1, f2)) where
{
#extern
fun
XATS000_dflt_lte$dflt
(f1: dflt, f2: dflt): bool = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_gte$dflt
  (f1, f2) =
(
XATS000_dflt_gte$dflt
  (f1, f2)) where
{
#extern
fun
XATS000_dflt_gte$dflt
(f1: dflt, f2: dflt): bool = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_neq$dflt
  (f1, f2) =
(
XATS000_dflt_neq$dflt
  (f1, f2)) where
{
#extern
fun
XATS000_dflt_neq$dflt
(f1: dflt, f2: dflt): bool = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
dflt_add$dflt
  (f1, f2) =
(
XATS000_dflt_add$dflt
  (f1, f2)) where
{
#extern
fun
XATS000_dflt_add$dflt
(f1: dflt, f2: dflt): dflt = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_sub$dflt
  (f1, f2) =
(
XATS000_dflt_sub$dflt
  (f1, f2)) where
{
#extern
fun
XATS000_dflt_sub$dflt
(f1: dflt, f2: dflt): dflt = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_mul$dflt
  (f1, f2) =
(
XATS000_dflt_mul$dflt
  (f1, f2)) where
{
#extern
fun
XATS000_dflt_mul$dflt
(f1: dflt, f2: dflt): dflt = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_div$dflt
  (f1, f2) =
(
XATS000_dflt_div$dflt
  (f1, f2)) where
{
#extern
fun
XATS000_dflt_div$dflt
(f1: dflt, f2: dflt): dflt = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_mod$dflt
  (f1, f2) =
(
XATS000_dflt_mod$dflt
  (f1, f2)) where
{
#extern
fun
XATS000_dflt_mod$dflt
(f1: dflt, f2: dflt): dflt = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-05:
Mon 09 Sep 2024 06:13:03 PM EDT
*)
//
#impltmp
<(*tmp*)>
dflt_print
  ( f0 ) =
(
XATS000_dflt_print
  ( f0 )) where
{
#extern
fun
XATS000_dflt_print(f0: dflt): void = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-21:
Sat Sep 21 03:31:11 PM EDT 2024
*)
//
#impltmp
<(*tmp*)>
dflt_ceil
  ( df ) =
(
XATS000_dflt_ceil
  ( df )) where
{
#extern
fun
XATS000_dflt_ceil(df: dflt): dflt = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_floor
  ( df ) =
(
XATS000_dflt_floor
  ( df )) where
{
#extern
fun
XATS000_dflt_floor(df: dflt): dflt = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_round
  ( df ) =
(
XATS000_dflt_round
  ( df )) where
{
#extern
fun
XATS000_dflt_round(df: dflt): dflt = $extnam()
}
//
#impltmp
<(*tmp*)>
dflt_trunc
  ( df ) =
(
XATS000_dflt_trunc
  ( df )) where
{
#extern
fun
XATS000_dflt_trunc(df: dflt): dflt = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)

(* end of [ATS3/XANADU_prelude_DATS_CATS_gint000.dats] *)
`,
  "DATS/CATS/gint000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Sun 01 Sep 2024 04:25:37 PM EDT
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
sint_neg
  ( i1 ) =
(
XATS000_sint_neg
  ( i1 )) where
{
#extern
fun
XATS000_sint_neg
(i1: sint): sint = $extnam() }
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
sint_lt$sint
  (i1, i2) =
(
XATS000_sint_lt$sint
  (i1, i2)) where
{
#extern
fun
XATS000_sint_lt$sint
(i1: sint, i2: sint): bool = $extnam()
}
//
#impltmp
<(*tmp*)>
sint_gt$sint
  (i1, i2) =
(
XATS000_sint_gt$sint
  (i1, i2)) where
{
#extern
fun
XATS000_sint_gt$sint
(i1: sint, i2: sint): bool = $extnam()
}
//
#impltmp
<(*tmp*)>
sint_eq$sint
  (i1, i2) =
(
XATS000_sint_eq$sint
  (i1, i2)) where
{
#extern
fun
XATS000_sint_eq$sint
(i1: sint, i2: sint): bool = $extnam()
}
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
sint_lte$sint
  (i1, i2) =
(
XATS000_sint_lte$sint
  (i1, i2)) where
{
#extern
fun
XATS000_sint_lte$sint
(i1: sint, i2: sint): bool = $extnam()
}
//
#impltmp
<(*tmp*)>
sint_gte$sint
  (i1, i2) =
(
XATS000_sint_gte$sint
  (i1, i2)) where
{
#extern
fun
XATS000_sint_gte$sint
(i1: sint, i2: sint): bool = $extnam()
}
//
#impltmp
<(*tmp*)>
sint_neq$sint
  (i1, i2) =
(
XATS000_sint_neq$sint
  (i1, i2)) where
{
#extern
fun
XATS000_sint_neq$sint
(i1: sint, i2: sint): bool = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
sint_add$sint
  (i1, i2) =
(
XATS000_sint_add$sint
  (i1, i2)) where
{
#extern
fun
XATS000_sint_add$sint
(i1: sint, i2: sint): sint = $extnam()
}
//
#impltmp
<(*tmp*)>
sint_sub$sint
  (i1, i2) =
(
XATS000_sint_sub$sint
  (i1, i2)) where
{
#extern
fun
XATS000_sint_sub$sint
(i1: sint, i2: sint): sint = $extnam()
}
//
#impltmp
<(*tmp*)>
sint_mul$sint
  (i1, i2) =
(
XATS000_sint_mul$sint
  (i1, i2)) where
{
#extern
fun
XATS000_sint_mul$sint
(i1: sint, i2: sint): sint = $extnam()
}
//
#impltmp
<(*tmp*)>
sint_div$sint
  (i1, i2) =
(
XATS000_sint_div$sint
  (i1, i2)) where
{
#extern
fun
XATS000_sint_div$sint
(i1: sint, i2: sint): sint = $extnam()
}
//
#impltmp
<(*tmp*)>
sint_mod$sint
  (i1, i2) =
(
XATS000_sint_mod$sint
  (i1, i2)) where
{
#extern
fun
XATS000_sint_mod$sint
(i1: sint, i2: sint): sint = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-05:
Thu 05 Sep 2024 11:11:27 AM EDT
*)
//
#impltmp
<(*tmp*)>
sint_print
  ( i0 ) =
(
XATS000_sint_print
  ( i0 )) where
{
#extern
fun
XATS000_sint_print(i0: sint): void = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)

(* end of [ATS3/XANADU_prelude_DATS_CATS_gint000.dats] *)
`,
  "DATS/CATS/strn000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Fri 16 Aug 2024 05:24:40 PM EDT
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
strn_length
  ( cs ) =
(
XATS000_strn_length
  ( cs )) where
{
#extern
fun
XATS000_strn_length
  (cs: strn): nint = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-04:
Wed 04 Sep 2024 04:52:34 AM EDT
*)
//
#impltmp
<(*tmp*)>
strn_cmp
  (x1, x2) =
(
XATS000_strn_cmp
  (x1, x2)) where
{
#extern
fun
XATS000_strn_cmp
(x1: strn, x2: strn): nint = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-05:
Thu 05 Sep 2024 11:11:27 AM EDT
*)
//
#impltmp
<(*tmp*)>
strn_print
  ( cs ) =
(
XATS000_strn_print
  ( cs )) where
{
#extern
fun
XATS000_strn_print(cs: strn): void = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
$UN.strn_get$at$raw
  (cs, i0) =
(
XATS000_strn_get$at$raw
  (cs, i0)) where
{
#extern
fun
XATS000_strn_get$at$raw
  (cs: strn, i0: nint): cgtz = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-16:
Fri 16 Aug 2024 05:22:41 PM EDT
*)
//
#impltmp
<(*tmp*)>
strn_fmake_fwork
  (fwork) =
(
XATS000_strn_fmake_fwork
  (fwork)) where
{
#extern
fun
XATS000_strn_fmake_fwork
( fwork
: ((cgtz)->void)->void): strn = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-04-26:
Sat Apr 26 08:48:02 PM EDT 2025
*)
//
#impltmp
<env:vt>
strn_fmake_env$fwork
  (env, fwork) =
(
XATS000_strn_fmake_env$fwork
  (env, fwork)) where
{
#extern
fun
XATS000_strn_fmake_env$fwork
( env: env
, fwork: (env, cgtz->void)->void): strn = $extnam()
}
//
#impltmp
<env:vt>
strn_fmake1_env$fwork
  (env, fwork) =
(
XATS000_strn_fmake1_env$fwork
  (env, fwork)) where
{
#extern
fun
XATS000_strn_fmake1_env$fwork
( env: !env
, fwork: (!env, cgtz->void)->void): strn = $extnam()
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(* ****** ****** *)(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)(* ****** ****** *)

(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_CATS_strn000.dats] *)
(***********************************************************************)
`,
  "DATS/VT/.keeper": ``,
  "DATS/VT/axrf000_vt.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Sun 11 Aug 2024 03:44:27 PM EDT
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
datavwtp
a0rf_vt_dt // dt: vx
(a:vwtp+) = a0rf_vt of (a)
#absimpl
a0rf_vt_vx(a:vt) = a0rf_vt_dt(a)
//
(* ****** ****** *)
//
#impltmp
< a:vt >
a0rf_vt_free(A) =
let
val ~
a0rf_vt(x) = A in g_free<a>(x)
end(*let*)//end-of-[a0rf_vt_free(A)]
//
(* ****** ****** *)
//
#impltmp
< a:t0 >
a0rf_vt_get = a0rf_vt_cget<a>
//
#impltmp
< a:vt >
a0rf_vt_cget(A) =
let
val
a0rf_vt(x) = A in g_copy<a>(x)
end(*let*)//end-of-[a0rf_vt_cget(A)]
//
#impltmp
< a:vt >
a0rf_vt_lget(A) =
let
val
a0rf_vt(x) = A in ($fold(A); x)
end(*let*)//end-of-[a0rf_vt_lget(A)]
//
(* ****** ****** *)
//
#impltmp
< a:t0 >
a0rf_vt_set = a0rf_vt_setf<a>
//
#impltmp
< a:vt >
a0rf_vt_setf(A, y) =
let
val @
a0rf_vt(x) = A
val () = (A.0 := y) in g_free<a>(x)
end(*let*)//end-of-[a0rf_vt_setf(A)]
//
#impltmp
< a:vt >
a0rf_vt_lset(A, y) =
let
val @
a0rf_vt(x) = A // x: ?a
val () = (A.0 := y) in (*  void  *)
end(*let*)//end-of-[a0rf_vt_lset(A)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a:vt >
a0rf_vt_make_1val
  (   x   ) = $UN.castxy(a0rf_vt<a>(x))
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_VT_axrf000_vt.dats] *)
(***********************************************************************)
`,
  "DATS/VT/axsz000_vt.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Sun 11 Aug 2024 05:30:58 PM EDT
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_VT_axsz000_vt.dats] *)
(***********************************************************************)
`,
  "DATS/VT/gasq000_vt.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sun 21 Jul 2024 11:39:54 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_VT_gasq001_vt.dats] *)
(***********************************************************************)
`,
  "DATS/VT/gasq001_vt.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sun 21 Jul 2024 11:39:54 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_VT_gasq001_vt.dats] *)
(***********************************************************************)
`,
  "DATS/VT/gbas000_vt.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Wed 10 Jul 2024 10:39:58 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
#impltmp
{ x0:t0 }
g_free0<x0>(obj) = ()
#impltmp
{ x0:vt }
g_free1<x0>(obj) = ()
*)
//
(*
#impltmp
{ x0:vt }
g_copy0<x0>(obj) = obj
#impltmp
{ x0:t0 }
g_copy1<x0>(obj) = obj
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
g_equal0<x0> = g_equal<x0>
#impltmp
{ x0:t0 }
g_equal1<x0> = g_equal<x0>
//
#impltmp
{ x0:t0 }
g_noteq0<x0> = g_noteq<x0>
#impltmp
{ x0:t0 }
g_noteq1<x0> = g_noteq<x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
max$nil0<x0> = max$nil<x0>(*nil*)
#impltmp
{ x0:t0 }
min$nil0<x0> = min$nil<x0>(*nil*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:vt >
get$at$exn1 = get$at$exn<xs><x0>
#impltmp
< xs:t0 >
< x0:vt >
set$at$exn1 = set$at$exn<xs><x0>
#impltmp
< xs:t0 >
< x0:t0 >
fset$at$exn1 = fset$at$exn<xs><x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_VT_gbas000_vt.dats] *)
(***********************************************************************)
`,
  "DATS/VT/gbas001_vt.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Fri 12 Jul 2024 08:39:27 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-22:
Should this kind of
routing be supported?
Mon 22 Jul 2024 08:28:43 PM EDT
*)
(*
//
#impltmp
< x0:vt >
forall$test0(x0) =
let
val r0 =
forall$test1<x0>(x0)
in//let
(
  g_free<x0>(x0); r0) end//let
//
#impltmp
< x0:vt >
forall$test1(x0) =
let
val x0 =
g_copy<x0>(x0) in//let
(forall$test0<x0>(x0)) end//let
//
*)
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
forall$test0 = forall$test<x0>
#impltmp
< x0:t0 >
forall$test1 = forall$test<x0>
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
rforall$test0 = rforall$test<x0>
#impltmp
< x0:t0 >
rforall$test1 = rforall$test<x0>
//
#impltmp
< x0:t0 >
iforall$test0 = iforall$test<x0>
#impltmp
< x0:t0 >
iforall$test1 = iforall$test<x0>
//
#impltmp
< x0:t0 >
irforall$test0 = irforall$test<x0>
#impltmp
< x0:t0 >
irforall$test1 = irforall$test<x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:t0 >
foritm$work0 = foritm$work<x0>
#impltmp
< x0:t0 >
foritm$work1 = foritm$work<x0>
//
#impltmp
< x0:t0 >
rforitm$work0 = rforitm$work<x0>
#impltmp
< x0:t0 >
rforitm$work1 = rforitm$work<x0>
//
#impltmp
< x0:t0 >
iforitm$work0 = iforitm$work<x0>
#impltmp
< x0:t0 >
iforitm$work1 = iforitm$work<x0>
//
#impltmp
< x0:t0 >
irforitm$work0 = irforitm$work<x0>
#impltmp
< x0:t0 >
irforitm$work1 = irforitm$work<x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:t0 >
< r0:vt >
folditm$fopr0 = folditm$fopr<x0><r0>
#impltmp
< x0:t0 >
< r0:vt >
folditm$fopr1 = folditm$fopr<x0><r0>
//
#impltmp
< x0:t0 >
< r0:vt >
rfolditm$fopr0 = rfolditm$fopr<x0><r0>
#impltmp
< x0:t0 >
< r0:vt >
rfolditm$fopr1 = rfolditm$fopr<x0><r0>
//
#impltmp
< x0:t0 >
< r0:vt >
ifolditm$fopr0 = ifolditm$fopr<x0><r0>
#impltmp
< x0:t0 >
< r0:vt >
ifolditm$fopr1 = ifolditm$fopr<x0><r0>
//
#impltmp
< x0:t0 >
< r0:vt >
irfolditm$fopr0 = irfolditm$fopr<x0><r0>
#impltmp
< x0:t0 >
< r0:vt >
irfolditm$fopr1 = irfolditm$fopr<x0><r0>
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:t0 >
< r0:vt >
foldall$fopr0 = foldall$fopr<x0><r0>
#impltmp
< x0:t0 >
< r0:vt >
foldall$fopr1 = foldall$fopr<x0><r0>
//
#impltmp
< x0:t0 >
< r0:vt >
rfoldall$fopr0 = rfoldall$fopr<x0><r0>
#impltmp
< x0:t0 >
< r0:vt >
rfoldall$fopr1 = rfoldall$fopr<x0><r0>
//
#impltmp
< x0:t0 >
< r0:vt >
ifoldall$fopr0 = ifoldall$fopr<x0><r0>
#impltmp
< x0:t0 >
< r0:vt >
ifoldall$fopr1 = ifoldall$fopr<x0><r0>
//
#impltmp
< x0:t0 >
< r0:vt >
irfoldall$fopr0 = irfoldall$fopr<x0><r0>
#impltmp
< x0:t0 >
< r0:vt >
irfoldall$fopr1 = irfoldall$fopr<x0><r0>
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:t0 >
< y0:vt >
map$fopr0 = map$fopr<x0><y0>
#impltmp
< x0:t0 >
< y0:vt >
map$fopr1 = map$fopr<x0><y0>
//
#impltmp
< x0:t0 >
< y0:vt >
rmap$fopr0 = rmap$fopr<x0><y0>
#impltmp
< x0:t0 >
< y0:vt >
rmap$fopr1 = rmap$fopr<x0><y0>
//
#impltmp
< x0:t0 >
< y0:vt >
imap$fopr0 = imap$fopr<x0><y0>
#impltmp
< x0:t0 >
< y0:vt >
imap$fopr1 = imap$fopr<x0><y0>
//
#impltmp
< x0:t0 >
< y0:vt >
irmap$fopr0 = irmap$fopr<x0><y0>
#impltmp
< x0:t0 >
< y0:vt >
irmap$fopr1 = irmap$fopr<x0><y0>
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
filter$test1 = filter$test<x0>
#impltmp
< x0:t0 >
rfilter$test1 = rfilter$test<x0>
#impltmp
< x0:t0 >
ifilter$test1 = ifilter$test<x0>
#impltmp
< x0:t0 >
irfilter$test1 = ifilter$test<x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-22:
Mon 22 Jul 2024 08:28:43 PM EDT
*)
//
#impltmp
< x0:t0 >
< y0:vt >
mapoptn$fopr0 = mapoptn$fopr<x0><y0>
#impltmp
< x0:t0 >
< y0:vt >
mapoptn$fopr1 = mapoptn$fopr<x0><y0>
//
#impltmp
< x0:t0 >
< y0:vt >
maplist$fopr0 = maplist$fopr<x0><y0>
#impltmp
< x0:t0 >
< y0:vt >
maplist$fopr1 = maplist$fopr<x0><y0>
//
#impltmp
< x0:t0 >
< y0:vt >
mapstrm$fopr0 = mapstrm$fopr<x0><y0>
#impltmp
< x0:t0 >
< y0:vt >
mapstrm$fopr1 = mapstrm$fopr<x0><y0>
//
#impltmp
< x0:t0 >
< y0:vt >
mapstrq$fopr0 = mapstrq$fopr<x0><y0>
#impltmp
< x0:t0 >
< y0:vt >
mapstrq$fopr1 = mapstrq$fopr<x0><y0>
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_VT_gbas001_vt.dats] *)
(***********************************************************************)
`,
  "DATS/VT/gcls000_vt.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon 29 Jul 2024 06:15:29 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#staload UN = 
"prelude/SATS/unsfx00.sats"
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_unmk0
(  gseq  ) = $UN.castxy0(gseq)
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_unmk1
(  gseq  ) = $UN.castxy1(gseq)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-13:
Tue Jan 13 12:03:35 AM EST 2026
*)
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_length0
  (gseq) =
(
gseq_length0<xs><x0>(GLSEQ_unmk0(gseq)))
//
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_length1
  (gseq) =
let
val
(pf|xs) = GLSEQ_unmk1(gseq)
val res = gseq_length1<xs><x0>(xs)
prval () = owed_vt_return0(pf, xs) in res
end(*let*)//end-of-[GLSEQ_length1<xs><x0>(gseq)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-13:
Tue Jan 13 12:03:35 AM EST 2026
*)
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_forall0
  (gseq) =
(
gseq_forall0<xs><x0>(GLSEQ_unmk0(gseq)))
//
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_forall1
  (gseq) =
let
val
(pf|xs) = GLSEQ_unmk1(gseq)
val btf = gseq_forall1<xs><x0>(xs)
prval () = owed_vt_return0(pf, xs) in btf
end(*let*)//end-of-[GLSEQ_forall1<xs><x0>(gseq)]
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_forall0$f1un
  (gseq, test) =
(
GLSEQ_forall0<xs><x0>(gseq))
where
{
#impltmp forall$test0<x0>(*x0*) = test(*x0*)
}(*where*)//end-of-[GLSEQ_forall0$f1un<xs><x0>(...)]
//
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_forall1$f1un
  (gseq, test) =
(
GLSEQ_forall1<xs><x0>(gseq))
where
{
#impltmp forall$test1<x0>(*x0*) = test(*x0*)
}(*where*)//end-of-[GLSEQ_forall1$f1un<xs><x0>(...)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-13:
Tue Jan 13 12:03:35 AM EST 2026
*)
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_rforall0
  (gseq) =
(
gseq_rforall0<xs><x0>(GLSEQ_unmk0(gseq)))
//
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_rforall1
  (gseq) =
let
val
(pf|xs) = GLSEQ_unmk1(gseq)
val btf = gseq_rforall1<xs><x0>(xs)
prval () = owed_vt_return0(pf, xs) in btf
end(*let*)//end-of-[GLSEQ_rforall1<xs><x0>(gseq)]
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_rforall0$f1un
  (gseq, test) =
(
GLSEQ_rforall0<xs><x0>(gseq))
where
{
#impltmp rforall$test0<x0>(*x0*) = test(*x0*)
}(*where*)//end-of-[GLSEQ_rforall0$f1un<xs><x0>(...)]
//
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_rforall1$f1un
  (gseq, test) =
(
GLSEQ_rforall1<xs><x0>(gseq))
where
{
#impltmp rforall$test1<x0>(*x0*) = test(*x0*)
}(*where*)//end-of-[GLSEQ_rforall1$f1un<xs><x0>(...)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-13:
Tue Jan 13 12:03:35 AM EST 2026
*)
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_iforall0
  (gseq) =
(
gseq_iforall0<xs><x0>(GLSEQ_unmk0(gseq)))
//
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_iforall1
  (gseq) =
let
val
(pf|xs) = GLSEQ_unmk1(gseq)
val btf = gseq_iforall1<xs><x0>(xs)
prval () = owed_vt_return0(pf, xs) in btf
end(*let*)//end-of-[GLSEQ_iforall1<xs><x0>(gseq)]
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_iforall0$f2un
  (gseq, test) =
(
GLSEQ_iforall0<xs><x0>(gseq))
where
{
#impltmp iforall$test0<x0>(*i0,x0*) = test(*i0,x0*)
}(*where*)//end-of-[GLSEQ_iforall0$f2un<xs><x0>(...)]
//
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_iforall1$f2un
  (gseq, test) =
(
GLSEQ_iforall1<xs><x0>(gseq))
where
{
#impltmp iforall$test1<x0>(*i0,x0*) = test(*i0,x0*)
}(*where*)//end-of-[GLSEQ_iforall1$f2un<xs><x0>(...)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-13:
Tue Jan 13 12:03:35 AM EST 2026
*)
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_irforall0
  (gseq) =
(
gseq_irforall0<xs><x0>(GLSEQ_unmk0(gseq)))
//
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_irforall1
  (gseq) =
let
val
(pf|xs) = GLSEQ_unmk1(gseq)
val btf = gseq_irforall1<xs><x0>(xs)
prval () = owed_vt_return0(pf, xs) in btf
end(*let*)//end-of-[GLSEQ_irforall1<xs><x0>(gseq)]
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_irforall0$f2un
  (gseq, test) =
(
GLSEQ_irforall0<xs><x0>(gseq))
where
{
#impltmp irforall$test0<x0>(*i0,x0*) = test(*i0,x0*)
}(*where*)//end-of-[GLSEQ_irforall0$f2un<xs><x0>(...)]
//
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_irforall1$f2un
  (gseq, test) =
(
GLSEQ_irforall1<xs><x0>(gseq))
where
{
#impltmp irforall$test1<x0>(*i0,x0*) = test(*i0,x0*)
}(*where*)//end-of-[GLSEQ_irforall1$f2un<xs><x0>(...)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-13:
Tue Jan 13 12:16:55 AM EST 2026
*)
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_foritm0
  (gseq) =
(
gseq_foritm0<xs><x0>(GLSEQ_unmk0(gseq)))
//
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_foritm1
  (gseq) =
let
val
(pf|xs) = GLSEQ_unmk1(gseq)
val emp = gseq_foritm1<xs><x0>(xs)
prval () = owed_vt_return0(pf, xs) in emp
end(*let*)//end-of-[GLSEQ_foritm1<xs><x0>(gseq)]
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_foritm0$f1un
  (gseq, work) =
(
GLSEQ_foritm0<xs><x0>(gseq))
where
{
#impltmp foritm$work0<x0>(*x0*) = work(*x0*)
}(*where*)//end-of-[GLSEQ_foritm0$f1un<xs><x0>(...)]
//
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_foritm1$f1un
  (gseq, work) =
(
GLSEQ_foritm1<xs><x0>(gseq))
where
{
#impltmp foritm$work1<x0>(*x0*) = work(*x0*)
}(*where*)//end-of-[GLSEQ_foritm1$f1un<xs><x0>(...)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-13:
Tue Jan 13 12:16:55 AM EST 2026
*)
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_rforitm0
  (gseq) =
(
gseq_rforitm0<xs><x0>(GLSEQ_unmk0(gseq)))
//
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_rforitm1
  (gseq) =
let
val
(pf|xs) = GLSEQ_unmk1(gseq)
val emp = gseq_rforitm1<xs><x0>(xs)
prval () = owed_vt_return0(pf, xs) in emp
end(*let*)//end-of-[GLSEQ_rforitm1<xs><x0>(gseq)]
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_rforitm0$f1un
  (gseq, work) =
(
GLSEQ_rforitm0<xs><x0>(gseq))
where
{
#impltmp rforitm$work0<x0>(*x0*) = work(*x0*)
}(*where*)//end-of-[GLSEQ_rforitm0$f1un<xs><x0>(...)]
//
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_rforitm1$f1un
  (gseq, work) =
(
GLSEQ_rforitm1<xs><x0>(gseq))
where
{
#impltmp rforitm$work1<x0>(*x0*) = work(*x0*)
}(*where*)//end-of-[GLSEQ_rforitm1$f1un<xs><x0>(...)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-13:
Tue Jan 13 12:16:55 AM EST 2026
*)
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_iforitm0
  (gseq) =
(
gseq_iforitm0<xs><x0>(GLSEQ_unmk0(gseq)))
//
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_iforitm1
  (gseq) =
let
val
(pf|xs) = GLSEQ_unmk1(gseq)
val btf = gseq_iforitm1<xs><x0>(xs)
prval () = owed_vt_return0(pf, xs) in btf
end(*let*)//end-of-[GLSEQ_iforitm1<xs><x0>(gseq)]
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_iforitm0$f2un
  (gseq, work) =
(
GLSEQ_iforitm0<xs><x0>(gseq))
where
{
#impltmp iforitm$work0<x0>(*i0,x0*) = work(*i0,x0*)
}(*where*)//end-of-[GLSEQ_iforitm0$f2un<xs><x0>(...)]
//
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_iforitm1$f2un
  (gseq, work) =
(
GLSEQ_iforitm1<xs><x0>(gseq))
where
{
#impltmp iforitm$work1<x0>(*i0,x0*) = work(*i0,x0*)
}(*where*)//end-of-[GLSEQ_iforitm1$f2un<xs><x0>(...)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-13:
Tue Jan 13 12:16:55 AM EST 2026
*)
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_irforitm0
  (gseq) =
(
gseq_irforitm0<xs><x0>(GLSEQ_unmk0(gseq)))
//
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_irforitm1
  (gseq) =
let
val
(pf|xs) = GLSEQ_unmk1(gseq)
val btf = gseq_irforitm1<xs><x0>(xs)
prval () = owed_vt_return0(pf, xs) in btf
end(*let*)//end-of-[GLSEQ_irforitm1<xs><x0>(gseq)]
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_irforitm0$f2un
  (gseq, work) =
(
GLSEQ_irforitm0<xs><x0>(gseq))
where
{
#impltmp irforitm$work0<x0>(*i0,x0*) = work(*i0,x0*)
}(*where*)//end-of-[GLSEQ_irforitm0$f2un<xs><x0>(...)]
//
#impltmp
< xs:vt >
< x0:vt >
GLSEQ_irforitm1$f2un
  (gseq, work) =
(
GLSEQ_irforitm1<xs><x0>(gseq))
where
{
#impltmp irforitm$work1<x0>(*i0,x0*) = work(*i0,x0*)
}(*where*)//end-of-[GLSEQ_irforitm1$f2un<xs><x0>(...)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_VT_gcls000_vt.dats] *)
(***********************************************************************)
`,
  "DATS/VT/gfun000_vt.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Tue 13 Aug 2024 04:19:16 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_VT_gfun000_vt.dats] *)
(***********************************************************************)
`,
  "DATS/VT/gnum000_vt.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Fri 12 Jul 2024 07:31:22 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
g_neg0<x0> = g_neg<x0>
#impltmp
{ x0:t0 }
g_abs0<x0> = g_abs<x0>
//
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
g_suc0<x0> = g_suc<x0>
#impltmp
{ x0:t0 }
g_pre0<x0> = g_pre<x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
g_max00<x0> = g_max<x0>
#impltmp
{ x0:t0 }
g_min00<x0> = g_min<x0>
//
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
g_add00<x0> = g_add<x0>
#impltmp
{ x0:t0 }
g_sub00<x0> = g_sub<x0>
#impltmp
{ x0:t0 }
g_mul00<x0> = g_mul<x0>
#impltmp
{ x0:t0 }
g_div00<x0> = g_div<x0>
#impltmp
{ x0:t0 }
g_mod00<x0> = g_mod<x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_VT_gnum000_vt.dats] *)
(***********************************************************************)
`,
  "DATS/VT/gord000_vt.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sat 10 Aug 2024 03:48:28 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{a:t0}
g_lt00<a> = g_lt<a>
#impltmp
{a:t0}
g_lt11<a> = g_lt<a>
//
(* ****** ****** *)
//
#impltmp
{a:t0}
g_gt00<a> = g_gt<a>
#impltmp
{a:t0}
g_gt11<a> = g_gt<a>
//
(* ****** ****** *)
//
#impltmp
{a:t0}
g_lte00<a> = g_lte<a>
#impltmp
{a:t0}
g_lte11<a> = g_lte<a>
//
(* ****** ****** *)
//
#impltmp
{a:t0}
g_gte00<a> = g_gte<a>
#impltmp
{a:t0}
g_gte11<a> = g_gte<a>
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{a:t0}
g_cmp00<a> = g_cmp<a>(*x1,x2*)
#impltmp
{a:t0}
g_cmp01<a> = g_cmp<a>(*x1,x2*)
#impltmp
{a:t0}
g_cmp10<a> = g_cmp<a>(*x1,x2*)
#impltmp
{a:t0}
g_cmp11<a> = g_cmp<a>(*x1,x2*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_VT_gord000_vt.dats] *)
(***********************************************************************)
`,
  "DATS/VT/gseq000_vt.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon 08 Jul 2024 12:53:10 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_sum0(xs) =
let
val r0 = g_0<x0>()
#impltmp
folditm$fopr0
<x0><x0>
(r0, x0) = g_add00<x0>(r0, x0)
in//let
gseq_folditm0<xs><x0><x0>(xs, r0)
end(*let*)//end-of-[gseq_sum0(xs)]
//
#impltmp
< xs:vt >
< x0:vt >
gseq_sum1(xs) =
let
val r0 = g_0<x0>()
#impltmp
folditm$fopr1
<x0><x0>
(r0, x0) = g_add01<x0>(r0, x0)
in//let
gseq_folditm1<xs><x0><x0>(xs, r0)
end(*let*)//end-of-[gseq_sum0(xs)]
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_prod0(xs) =
let
val r0 = g_1<x0>()
#impltmp
folditm$fopr0
<x0><x0>
(r0, x0) = g_mul00<x0>(r0, x0)
in//let
gseq_folditm0<xs><x0><x0>(xs, r0)
end(*let*)//end-of-[gseq_prod0(xs)]
//
#impltmp
< xs:vt >
< x0:vt >
gseq_prod1(xs) =
let
val r0 = g_1<x0>()
#impltmp
folditm$fopr1
<x0><x0>
(r0, x0) = g_mul01<x0>(r0, x0)
in//let
gseq_folditm1<xs><x0><x0>(xs, r0)
end(*let*)//end-of-[gseq_prod1(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_nilq0(xs) =
let
#impltmp
forall$test0<x0>(x0) =
(g_free<x0>(x0); false)
in//let
  gseq_forall0<xs><x0>(xs)
end(*let*)//end-of-[gseq_nilq0(xs)]
//
#impltmp
< xs:vt >
< x0:vt >
gseq_nilq1(xs) =
(
gseq_forall1<xs><x0>(xs)
) where
{
#impltmp
forall$test1<x0>(x0) = false
}(*where*)//end-of-[gseq_nilq1(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-05-08:
Thu May  8 04:13:33 PM EDT 2025
*)
#impltmp
< xs:vt >
< x0:vt >
gseq_torep0(xs) =
let
//
val xbeg =
gseq_beg<xs><x0>()
val xsep =
gseq_sep<xs><x0>()
val xend =
gseq_end<xs><x0>()
//
in//let
//
strn_fmake_env$fwork<xs>
(
xs,
lam(xs, work) =>
let
val () =
strn_foritm$f1un
(  xbeg , work  )
//
val () =
gseq_iforitm0$f2un
<   xs  ><  x0   >
(
xs,
lam(i0, x0) =>
(
if (i0 >= 1) then
strn_foritm$f1un(xsep, work)
;
let
  val
  xrep = g_torep0<x0>(x0)
in//let
(
strn_foritm$f1un(xrep, work))
end//let
)
)
//
val () =
(
  strn_foritm$f1un(xend, work))
//
end//let//end-of-[lam(xs, work)]
)
//
end(*let*)//end-of-[gseq_torep0<xs><x0>]
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_tostr0(xs) =
(
gseq_torep0<xs><x0>(xs)
) where
{
#impltmp g_torep0<x0> = g_tostr0<x0>
}(*where*)//end-of-[gseq_tostr0<xs><x0>]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
Wed 17 Jul 2024 09:55:22 PM EDT
*)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_print0(xs) =
let
//
val () =
strn_print<>
(gseq_beg<xs><x0>())
//
val () =
(
if
(n0 >= 0)
then
g_void
(
gseq_iforall0<xs><x0>(xs))
else
(
gseq_iforitm0<xs><x0>(xs))
) where
{
//
val n0 =
(
 gseq_prlen<xs><x0>((*0*)))
//
#impltmp
iforitm$work0<x0>
  (i0, x0) =
(
  g_print0<x0>(x0)) where
{
val () =
if i0 > 0 then
strn_print(gseq_sep<xs><x0>())}
//
#impltmp
iforall$test0<x0>
  (i0, x0) =
(
if
(i0>=n0)
//
then
(
  false ) where
{
val () =
strn_print
(gseq_omit<xs><x0>()) }
//
else
(
g_print0<x0>(x0); true))
where
{
val () =
if i0 > 0 then
strn_print(gseq_sep<xs><x0>())}
//
}
//
val () =
strn_print<>(gseq_end<xs><x0>())
//
endlet // end-of-[gseq_print0(xs)]
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_print1(xs) =
let
val () =
strn_print<>
(gseq_beg<xs><x0>())
val () =
(
gseq_iforitm1<xs><x0>(xs)
) where
{
#impltmp
iforitm$work1<x0>(ni, x0) =
(
  g_print1<x0>(x0)) where
{
val () =
if ni > 0 then
strn_print<>(gseq_sep<xs><x0>())
}
}
val () =
strn_print<>(gseq_end<xs><x0>())
endlet // end-of-[gseq_print1(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
#impltmp
< xs:vt >
< x0:vt >
gseq_length0(xs) =
strm_vt_length0<x0>
(
gseq_strmize0<xs><x0>(xs))
*)
#impltmp
< xs:vt >
< x0:vt >
gseq_length0(xs) =
let
#typedef r0 = nint
#impltmp
folditm$fopr0
<x0><r0>(r0, x0) =
(g_free<x0>(x0); r0 + 1)
in//let
  gseq_folditm0<xs><x0><r0>(xs, 0)
end(*let*)//end-of-[gseq_length0(xs)]
//
#impltmp
< xs:vt >
< x0:vt >
gseq_length1(xs) =
let
#typedef r0 = nint
#impltmp
folditm$fopr1
<x0><r0>(r0, x0) = r0 + 1
in//let
  gseq_folditm1<xs><x0><r0>(xs, 0)
end(*let*)//end-of-[gseq_length1(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-16:
Tue 16 Jul 2024 07:24:26 AM EDT
*)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_max0
  ( xs ) =
//
let
//
var r0: x0 // x0?
val p0 = $addr(r0)
//
val i1 =
(
gseq_ifolditm0
<xs><x0>(xs, 0)) where
{
#impltmp
ifolditm$fopr0
<x0>(i1, i0, x0) =
if
(i0 <= 0)
then (i1+1) where
{
val () =
$UN.p2tr_set<x0>(p0, x0)}
else (i1+1) where
{
val r0 =
$UN.p2tr_get<x0>(p0)
val r0 = g_max00(r0, x0)
val () =
$UN.p2tr_set<x0>(p0, r0)}
}
//
in//let
(
  if i1 <= 0
  then max$nil0<x0>()
  else $UN.p2tr_get<x0>(p0))
end(*let*)//end-of-[gseq_max0(xs)]
//
#impltmp
< xs:vt >
< x0:vt >
gseq_max1
  ( xs ) =
//
let
//
var r0: x0 // x0?
val p0 = $addr(r0)
//
val i1 =
(
gseq_ifolditm1
<xs><x0>(xs, 0)) where
{
#impltmp
ifolditm$fopr1
<x0>(i1, i0, x0) =
if
(i0 <= 0)
then (i1+1) where
{
val x0 =
(
  g_copy<x0>(x0))
val () =
$UN.p2tr_set<x0>(p0, x0)}
else (i1+1) where
{
val r0 =
$UN.p2tr_get<x0>(p0)
val r0 = g_max01(r0, x0)
val () =
$UN.p2tr_set<x0>(p0, r0)}
}
//
in//let
(
  if i1 <= 0
  then max$nil1<x0>()
  else $UN.p2tr_get<x0>(p0))
end(*let*)//end-of-[gseq_max1(xs)]
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_min0
  ( xs ) =
(
gseq_max0<xs><x0>(xs)
) where
{
#impltmp
g_max00<x0> = g_min00<x0>
#impltmp
max$nil0<x0> = min$nil0<x0>
}(*where*)//end-of-[gseq_min0(xs)]
//
#impltmp
< xs:vt >
< x0:vt >
gseq_min1
  ( xs ) =
(
gseq_max1<xs><x0>(xs)
) where
{
#impltmp
g_max01<x0> = g_min01<x0>
#impltmp
max$nil1<x0> = min$nil1<x0>
}(*where*)//end-of-[gseq_min1(xs)]
//
(* ****** ****** *)
//
(*
HX-2024-07-16
Tue 16 Jul 2024 06:43:04 PM EDT
*)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_max$opt0
  ( xs ) =
let
//
excptcon NIL of ()
//
#impltmp
max$nil0<x0>() = $raise NIL()
//
in//let
(
try
optn_vt_cons
(gseq_max0<xs><x0>(xs))
with
| ~NIL() => optn_vt_nil(*nil*))
end(*let*)//end-of-[gseq_max$opt0]
//
#impltmp
< xs:vt >
< x0:vt >
gseq_max$opt1
  ( xs ) =
let
//
excptcon NIL of ()
//
#impltmp
max$nil1<x0>() = $raise NIL()
//
in//let
try
optn_vt_cons
(gseq_max0<xs><x0>(xs))
with
| ~NIL() => optn_vt_nil(*nil*)
endtry//HX: [endtry] is optional
end(*let*)//end-of-[gseq_max$opt1]
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_min$opt0
  ( xs ) =
(
gseq_max$opt0<xs><x0>(xs)
) where
{
#impltmp
g_max00<x0> = g_min00<x0>
}(*where*)//end-of-[gseq_min$opt0]
//
#impltmp
< xs:vt >
< x0:vt >
gseq_min$opt1
  ( xs ) =
(
gseq_max$opt1<xs><x0>(xs)
) where
{
#impltmp
g_max01<x0> = g_min01<x0>
}(*where*)//end-of-[gseq_min$opt1]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-15:
Mon 15 Jul 2024 04:25:27 PM EDT
*)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_get$at0
  (xs, i0) =
let
//
var r0: x0 // x0?
val p0 = $addr(r0)
//
val b0 =
(
gseq_iforall0<xs><x0>(xs)
) where
{
#impltmp
iforall$test0
<x0>(j0, x0) =
if
(j0 < i0)
then
(g_free<x0>(x0); true)
else
($UN.p2tr_set<x0>(p0, x0); false)
}
in//let
  if
  not(b0)
  then
  $UN.p2tr_get<x0>(p0)
  else get$at$exn0<xs><x0>(xs, i0)
end//let//end-of-[gseq_get$at0(xs, i0)]
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_get$at1
  (xs, i0) =
let
//
var r0: x0 // x0?
val p0 = $addr(r0)
//
val b0 =
(
gseq_iforall1<xs><x0>(xs)
) where
{
#impltmp
iforall$test1
<x0>(j0, x0) =
if
(j0 < i0)
then true else
let
val x0 =
g_copy<x0>(x0) in
$UN.p2tr_set<x0>(p0, x0); false
end//let//end-of-[if]
}
in//let
  if not(b0)
  then $UN.p2tr_get<x0>(p0)
  else get$at$exn1<xs><x0>(xs, i0)
end//let//end-of-[gseq_get$at1(xs, i0)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-17:
Wed 17 Jul 2024 12:48:59 PM EDT
*)
//
#impltmp
< xs:vt >
< x0:vt >
< ys:vt >
gseq_append00
  (xs, ys) =
g_make_lstrm<x0><xs>
(
strm_vt_append00<x0>(xs, ys))
where
{
val xs = gseq_strmize0<xs><x0>(xs)
val ys = gseq_strmize0<ys><x0>(ys)
}
//
#impltmp
< xs:vt >
< x0:vt >
< ys:vt >
gseq_append01
  (xs, ys) =
g_make_lstrm<x0><xs>
(
strm_vt_append00<x0>(xs, ys))
where
{
val xs = gseq_strmize0<xs><x0>(xs)
val ys = gseq_strmize1<ys><x0>(ys)
}
//
#impltmp
< xs:vt >
< x0:vt >
< ys:vt >
gseq_append10
  (xs, ys) =
g_make_lstrm<x0><xs>
(
strm_vt_append00<x0>(xs, ys))
where
{
val xs = gseq_strmize1<xs><x0>(xs)
val ys = gseq_strmize0<ys><x0>(ys)
}
//
#impltmp
< xs:vt >
< x0:vt >
< ys:vt >
gseq_append11
  (xs, ys) =
g_make_lstrm<x0><xs>
(
strm_vt_append00<x0>(xs, ys))
where
{
val xs = gseq_strmize1<xs><x0>(xs)
val ys = gseq_strmize1<ys><x0>(ys)
}
//
(* ****** ****** *)
//
(*
HX-2024-07-17:
Wed 17 Jul 2024 12:48:59 PM EDT
*)
//
#impltmp
< xs:vt >
< x0:vt >
< ys:vt >
gseq_prepend00
  (xs, ys) =
g_make_lstrm<x0><xs>
(
strm_vt_append00<x0>(ys, xs))
where
{
val xs = gseq_strmize0<xs><x0>(xs)
val ys = gseq_strmize0<ys><x0>(ys)
}
//
#impltmp
< xs:vt >
< x0:vt >
< ys:vt >
gseq_prepend01
  (xs, ys) =
g_make_lstrm<x0><xs>
(
strm_vt_append00<x0>(ys, xs))
where
{
val xs = gseq_strmize0<xs><x0>(xs)
val ys = gseq_strmize1<ys><x0>(ys)
}
//
#impltmp
< xs:vt >
< x0:vt >
< ys:vt >
gseq_prepend10
  (xs, ys) =
g_make_lstrm<x0><xs>
(
strm_vt_append00<x0>(ys, xs))
where
{
val xs = gseq_strmize1<xs><x0>(xs)
val ys = gseq_strmize0<ys><x0>(ys)
}
//
#impltmp
< xs:vt >
< x0:vt >
< ys:vt >
gseq_prepend11
  (xs, ys) =
g_make_lstrm<x0><xs>
(
strm_vt_append00<x0>(ys, xs))
where
{
val xs = gseq_strmize1<xs><x0>(xs)
val ys = gseq_strmize1<ys><x0>(ys)
}
//
(* ****** ****** *)
//
(*
HX-2024-07-17:
Wed 17 Jul 2024 04:14:16 PM EDT
*)
//
#impltmp
< xs:vt >
< x0:vt >
< ys:vt >
gseq_rappend00
  (xs, ys) =
g_make_lstrm<x0><xs>
(
strm_vt_append00<x0>(xs, ys))
where
{
val ys = gseq_strmize0<ys><x0>(ys)
val xs = gseq_rstrmize0<xs><x0>(xs)
}
//
#impltmp
< xs:vt >
< x0:vt >
< ys:vt >
gseq_rappend01
  (xs, ys) =
g_make_lstrm<x0><xs>
(
strm_vt_append00<x0>(xs, ys))
where
{
val ys = gseq_strmize1<ys><x0>(ys)
val xs = gseq_rstrmize0<xs><x0>(xs)
}
//
#impltmp
< xs:vt >
< x0:vt >
< ys:vt >
gseq_rappend10
  (xs, ys) =
g_make_lstrm<x0><xs>
(
strm_vt_append00<x0>(xs, ys))
where
{
val ys = gseq_strmize0<ys><x0>(ys)
val xs = gseq_rstrmize1<xs><x0>(xs)
}
//
#impltmp
< xs:vt >
< x0:vt >
< ys:vt >
gseq_rappend11
  (xs, ys) =
g_make_lstrm<x0><xs>
(
strm_vt_append00<x0>(xs, ys))
where
{
val ys = gseq_strmize1<ys><x0>(ys)
val xs = gseq_rstrmize1<xs><x0>(xs)
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-14:
Sun Dec 14 05:20:43 PM EST 2025
*)
#impltmp
< xz:vt >
< xs:vt >
< x0:vt >
gseq_concat0_lstrm
  (   xz   ) =
let
#vwtpdef ys = strm_vt(x0)
in//let
strm_vt_lstrm$concat0<x0>(
gseq_map0$f1un_lstrm<xz><xs><ys>(xz, gseq_strmize0<xs><x0>))
end(*let*)//end-of-[gseq_concat0_lstrm(xz)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_VT_gseq000_vt.dats] *)
(***********************************************************************)
`,
  "DATS/VT/gseq001_vt.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sat 13 Jul 2024 10:56:58 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ x0:vt }
gseq_strmize0
<strm_vt(x0)><x0>(xs) = (xs)
#impltmp
{ x0:vt }
gseq_strqize0
<strq_vt(x0)><x0>(xs) = (xs)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-28:
Sun 28 Jul 2024 03:48:39 PM EDT
*)
(*
#impltmp
< xs:vt >
< x0:vt >
gseq_listize1
  ( xs ) =
let
val xs =
g_copy<xs>(xs) in
gseq_listize0<xs><x0>(xs) end
*)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_strmize1
  ( xs ) =
let
val xs =
g_copy<xs>(xs) in
gseq_strmize0<xs><x0>(xs) end
#impltmp
< xs:vt >
< x0:vt >
gseq_strqize1
  ( xs ) =
let
val xs =
g_copy<xs>(xs) in
gseq_strqize0<xs><x0>(xs) end
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_listize0
  ( xs ) =
(
gseq_rfolditm0
<xs><x0><r0>(xs, r0))
where
{
val r0 = list_vt_nil()
#vwtpdef r0 = list_vt(x0)
#impltmp
rfolditm$fopr0
<x0><r0>
(x0, r0) = list_vt_cons(x0, r0)
}(*where*)//end(gseq_listize0(xs))
//
#impltmp
< xs:vt >
< x0:vt >
gseq_listize1
  ( xs ) =
(
gseq_rfolditm1
<xs><x0><r0>(xs, r0))
where
{
val r0 = list_vt_nil()
#vwtpdef r0 = list_vt(x0)
#impltmp
rfolditm$fopr1
<x0><r0>(x0, r0) =
list_vt_cons(g_copy<x0>(x0), r0)
}(*where*)//end(gseq_listize1(xs))
//
#impltmp
{ x0:vt }
gseq_listize0
<list_vt(x0)><x0> = g_self<list_vt(x0)>
#impltmp
{ x0:vt }
gseq_listize1
<list_vt(x0)><x0> = g_copy<list_vt(x0)>
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_rlistize0
  ( xs ) =
(
gseq_folditm0
<xs><x0><r0>(xs, r0))
where
{
val r0 = list_vt_nil()
#vwtpdef r0 = list_vt(x0)
#impltmp
folditm$fopr0
<x0><r0>
(r0, x0) = list_vt_cons(x0, r0)
}(*where*)//end(gseq_rlistize0(xs))
//
#impltmp
< xs:vt >
< x0:vt >
gseq_rlistize1
  ( xs ) =
(
gseq_folditm1
<xs><x0><r0>(xs, r0))
where
{
val r0 = list_vt_nil()
#vwtpdef r0 = list_vt(x0)
#impltmp
folditm$fopr1
<x0><r0>(r0, x0) =
(
list_vt_cons(g_copy<x0>(x0), r0))
}(*where*)//end(gseq_rlistize1(xs))
//
(*
HX: a special case!
*)
#impltmp
{ x0:vt }
gseq_rlistize0
<list_vt(x0)><x0> = list_vt_reverse0<x0>
#impltmp
{ x0:vt }
gseq_rlistize1
<list_vt(x0)><x0> = list_vt_reverse1<x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-22:
This is inefficent
for random-access gseq!
*)
#impltmp
< xs:vt >
< x0:vt >
gseq_rstrmize0
  ( xs ) =
list_vt_strmize0<x0>
(
  gseq_rlistize0<xs><x0>(xs))//reverse
#impltmp
< xs:vt >
< x0:vt >
gseq_rstrqize0
  ( xs ) =
list_vt_strqize0<x0>
(
  gseq_rlistize0<xs><x0>(xs))//reverse
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_forall0
  ( xs ) =
(
strm_vt_forall0<x0>
(
gseq_strmize0<xs><x0>(xs)))
//
#impltmp
< xs:vt >
< x0:vt >
gseq_forall1
  ( xs ) =
(
strm_vt_forall0<x0>
(
gseq_strmize1<xs><x0>(xs)))
where
{
#impltmp
forall$test0<x0>(x0) =
let
val b0 =
forall$test1<x0>(x0)
in (g_free<x0>(x0); b0) end//let
}(*where*)//end-of-[gseq_forall1(xs)]
//
#impltmp
< xs:vt >
< x0:vt >
gseq_forall0$f1un
  (xs, test) =
(
gseq_forall0
<xs><x0>(xs)) where
{
#impltmp
forall$test0<x0>(x0) = test(x0)
}(*where*)//end(gseq_forall0$f1un(...))
//
#impltmp
< xs:vt >
< x0:vt >
gseq_forall1$f1un
  (xs, test) =
(
gseq_forall1
<xs><x0>(xs)) where
{
#impltmp
forall$test1<x0>(x0) = test(x0)
}(*where*)//end(gseq_forall1$f1un(...))
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_rforall0
  ( xs ) =
(
strm_vt_forall0<x0>
(gseq_rstrmize0<xs><x0>(xs)))
//
#impltmp
< xs:vt >
< x0:vt >
gseq_rforall1
  ( xs ) =
(
strm_vt_forall0<x0>
(
gseq_rstrmize1<xs><x0>(xs)))
where
{
#impltmp
forall$test0<x0>(x0) =
let
val b0 =
rforall$test1<x0>(x0)
in (g_free<x0>(x0); b0) end//let
}(*where*)//end-of[gseq_rforall1(xs)]
//
#impltmp
< xs:vt >
< x0:vt >
gseq_rforall0$f1un
  (xs, test) =
(
gseq_rforall0
<xs><x0>(xs)) where
{
#impltmp
rforall$test0<x0>(x0) = test(x0)
}(*where*)//end(gseq_rforall0$f1un(...))
//
#impltmp
< xs:vt >
< x0:vt >
gseq_rforall1$f1un
  (xs, test) =
(
gseq_rforall1
<xs><x0>(xs)) where
{
#impltmp
rforall$test1<x0>(x0) = test(x0)
}(*where*)//end(gseq_rforall1$f1un(...))
//
(* ****** ****** *)
//
(*
#impltmp
< xs:vt >
< x0:vt >
gseq_iforall0
  ( xs ) =
strm_vt_iforall0<x0>
(gseq_strmize0<xs><x0>(xs))
*)
#impltmp
< xs:vt >
< x0:vt >
gseq_iforall0
  ( xs ) = b0
where {
//
var i0: ni = (0)
//
val p0 = $addr(i0)
//
val b0 =
(
gseq_forall0<xs><x0>(xs)
) where
{
#impltmp
forall$test0<x0>(x0) =
(
$UN.p2tr_set<ni>(p0, i0+1); b0)
where
{
val i0 = $UN.p2tr_get<ni>(p0)
val b0 = iforall$test0<x0>(i0, x0) }
}
//
}(*where*)//end-of-[gseq_iforall0(xs)]
//
#impltmp
< xs:vt >
< x0:vt >
gseq_iforall1
  ( xs ) = b0
where {
//
var i0: ni = (0)
//
val p0 = $addr(i0)
//
val b0 =
(
gseq_forall1<xs><x0>(xs)
) where
{
#impltmp
forall$test1<x0>(x0) =
(
$UN.p2tr_set<ni>(p0, i0+1); b0)
where
{
val i0 = $UN.p2tr_get<ni>(p0)
val b0 = iforall$test1<x0>(i0, x0) }
}
//
}(*where*)//end-of-[gseq_iforall1(xs)]
//
#impltmp
< xs:vt >
< x0:vt >
gseq_iforall0$f2un
  (xs, test) =
(
gseq_iforall0
<xs><x0>(xs)) where
{
#impltmp
iforall$test0<x0>(i0,x0) = test(i0,x0)
}(*where*)//end(gseq_iforall0$f2un(...))
//
#impltmp
< xs:vt >
< x0:vt >
gseq_iforall1$f2un
  (xs, test) =
(
gseq_iforall1
<xs><x0>(xs)) where
{
#impltmp
iforall$test1<x0>(i0,x0) = test(i0,x0)
}(*where*)//end(gseq_iforall1$f2un(...))
//
(* ****** ****** *)
//
(*
#impltmp
< xs:vt >
< x0:vt >
gseq_irforall0
  ( xs ) =
strm_vt_irforall0<x0>
(gseq_rstrmize0<xs><x0>(xs))
*)
#impltmp
< xs:vt >
< x0:vt >
gseq_irforall0
  ( xs ) = b0
where {
//
var i0: ni = (0)
//
val p0 = $addr(i0)
//
val b0 =
(
gseq_rforall0<xs><x0>(xs)
) where
{
#impltmp
rforall$test0<x0>(x0) =
(
$UN.p2tr_set<ni>(p0, i0+1); b0)
where
{
val i0 = $UN.p2tr_get<ni>(p0)
val b0 = irforall$test0<x0>(i0, x0) }
}
//
}(*where*)//end-of-[gseq_irforall0(xs)]
//
#impltmp
< xs:vt >
< x0:vt >
gseq_irforall1
  ( xs ) = b0
where {
//
var i0: ni = (0)
//
val p0 = $addr(i0)
//
val b0 =
(
gseq_rforall1<xs><x0>(xs)
) where
{
#impltmp
rforall$test1<x0>(x0) =
(
$UN.p2tr_set<ni>(p0, i0+1); b0)
where
{
val i0 = $UN.p2tr_get<ni>(p0)
val b0 = irforall$test1<x0>(i0, x0) }
}
//
}(*where*)//end-of-[gseq_irforall1(xs)]
//
#impltmp
< xs:vt >
< x0:vt >
gseq_irforall0$f2un
  (xs, test) =
(
gseq_irforall0
<xs><x0>(xs)) where
{
#impltmp
irforall$test0<x0>(i0,x0) = test(i0,x0)
}(*where*)//end(gseq_irforall0$f2un(...))
//
#impltmp
< xs:vt >
< x0:vt >
gseq_irforall1$f2un
  (xs, test) =
(
gseq_irforall1
<xs><x0>(xs)) where
{
#impltmp
irforall$test1<x0>(i0,x0) = test(i0,x0)
}(*where*)//end(gseq_irforall1$f2un(...))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_foritm0
  ( xs ) =
(
let
val _ =
gseq_forall0
<xs><x0>(xs) end//let
) where
{
#impltmp
forall$test0<x0>(x0) =
let
val () =
foritm$work0<x0>(x0) in true end
}(*where*)//end-of-[gseq_foritm0(xs)]
//
#impltmp
< xs:vt >
< x0:vt >
gseq_foritm1
  ( xs ) =
(
let
val _ =
gseq_forall1
<xs><x0>(xs) end//let
) where
{
#impltmp
forall$test1<x0>(x0) =
let
val () =
foritm$work1<x0>(x0) in true end
}(*where*)//end-of-[gseq_foritm1(xs)]
//
#impltmp
< xs:vt >
< x0:vt >
gseq_foritm0$f1un
  (xs, work) =
(
gseq_foritm0
<xs><x0>(xs)) where
{
#impltmp
foritm$work0<x0>(x0) = work(x0)
}(*where*)//end(gseq_foritm0$f1un(...))
//
#impltmp
< xs:vt >
< x0:vt >
gseq_foritm1$f1un
  (xs, work) =
(
gseq_foritm1
<xs><x0>(xs)) where
{
#impltmp
foritm$work1<x0>(x0) = work(x0)
}(*where*)//end(gseq_foritm1$f1un(...))
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_rforitm0
  ( xs ) =
(
let
val _ =
gseq_rforall0
<xs><x0>( xs ) end//let
) where
{
#impltmp
rforall$test0<x0>(x0) =
let
val () =
  rforitm$work0<x0>(x0) in true end
}(*where*)//end-of-[gseq_rforitm0(xs)]
//
#impltmp
< xs:vt >
< x0:vt >
gseq_rforitm1
  ( xs ) =
(
let
val _ =
gseq_rforall1
<xs><x0>( xs ) end//let
) where
{
#impltmp
rforall$test1<x0>(x0) =
let
val () =
  rforitm$work1<x0>(x0) in true end
}(*where*)//end-of-[gseq_rforitm1(xs)]
//
#impltmp
< xs:vt >
< x0:vt >
gseq_rforitm0$f1un
  (xs, work) =
(
gseq_rforitm0
<xs><x0>( xs )) where
{
#impltmp
rforitm$work0<x0>(x0) = work(x0)
}(*where*)//end(gseq_rforitm0$f1un(...))
//
#impltmp
< xs:vt >
< x0:vt >
gseq_rforitm1$f1un
  (xs, work) =
(
gseq_rforitm1
<xs><x0>( xs )) where
{
#impltmp
rforitm$work1<x0>(x0) = work(x0)
}(*where*)//end(gseq_rforitm1$f1un(...))
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_iforitm0
  ( xs ) =
(
let
val _ =
gseq_iforall0
<xs><x0>( xs ) end//let
) where
{
#impltmp
iforall$test0<x0>(i0, x0) =
let
val () =
iforitm$work0<x0>(i0, x0) in true end
}(*where*)//end-of-[gseq_iforitm0(xs)]
//
#impltmp
< xs:vt >
< x0:vt >
gseq_iforitm1
  ( xs ) =
(
let
val _ =
gseq_iforall1
<xs><x0>( xs ) end//let
) where
{
#impltmp
iforall$test1<x0>(i0, x0) =
let
val () =
iforitm$work1<x0>(i0, x0) in true end
}(*where*)//end-of-[gseq_iforitm1(xs)]
//
#impltmp
< xs:vt >
< x0:vt >
gseq_iforitm0$f2un
  (xs, work) =
(
gseq_iforitm0
<xs><x0>( xs )) where
{
#impltmp
iforitm$work0<x0>(i0,x0) = work(i0,x0)
}(*where*)//end(gseq_iforitm0$f2un(...))
//
#impltmp
< xs:vt >
< x0:vt >
gseq_iforitm1$f2un
  (xs, work) =
(
gseq_iforitm1
<xs><x0>( xs )) where
{
#impltmp
iforitm$work1<x0>(i0,x0) = work(i0,x0)
}(*where*)//end(gseq_iforitm1$f2un(...))
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_irforitm0
  ( xs ) =
(
let
val _ =
gseq_irforall0
<xs><x0>( xs ) end//let
) where
{
#impltmp
irforall$test0<x0>(i0, x0) =
let
val () =
irforitm$work0<x0>(i0, x0) in true end
}(*where*)//end-of-[gseq_irforitm0(xs)]
//
#impltmp
< xs:vt >
< x0:vt >
gseq_irforitm1
  ( xs ) =
(
let
val _ =
gseq_irforall1
<xs><x0>( xs ) end//let
) where
{
#impltmp
irforall$test1<x0>(i0, x0) =
let
val () =
irforitm$work1<x0>(i0, x0) in true end
}(*where*)//end-of-[gseq_irforitm1(xs)]
//
#impltmp
< xs:vt >
< x0:vt >
gseq_irforitm0$f2un
  (xs, work) =
(
gseq_irforitm0
<xs><x0>( xs )) where
{
#impltmp
irforitm$work0<x0>(i0,x0) = work(i0,x0)
}(*where*)//end(gseq_irforitm0$f2un(...))
//
#impltmp
< xs:vt >
< x0:vt >
gseq_irforitm1$f2un
  (xs, work) =
(
gseq_irforitm1
<xs><x0>( xs )) where
{
#impltmp
irforitm$work1<x0>(i0,x0) = work(i0,x0)
}(*where*)//end(gseq_irforitm1$f2un(...))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
< r0:vt >
gseq_folditm0
  (xs, r0) = r0
where {
//
var r0: r0 = r0
//
val p0 = $addr(r0)
//
val () =
(
gseq_foritm0<xs><x0>(xs)
) where
{
#impltmp
foritm$work0<x0>(x0) =
(
  $UN.p2tr_set<r0>(p0, r0))
where
{
val r0 = $UN.p2tr_get<r0>(p0)
val r0 = folditm$fopr0<x0><r0>(r0, x0)}}
//
}(*where*)//end-of-[gseq_folditm0(xs, r0)]
//
#impltmp
< xs:vt >
< x0:vt >
< r0:vt >
gseq_folditm1
  (xs, r0) = r0
where {
//
var r0: r0 = r0
//
val p0 = $addr(r0)
//
val () =
(
gseq_foritm1<xs><x0>(xs)
) where
{
#impltmp
foritm$work1<x0>(x0) =
(
  $UN.p2tr_set<r0>(p0, r0))
where
{
val r0 = $UN.p2tr_get<r0>(p0)
val r0 = folditm$fopr1<x0><r0>(r0, x0)}}
//
}(*where*)//end-of-[gseq_folditm1(xs, r0)]
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
< r0:vt >
gseq_rfolditm0
  (xs, r0) = r0
where {
//
var r0: r0 = r0
//
val p0 = $addr(r0)
//
val () =
(
gseq_rforitm0<xs><x0>(xs)
) where
{
#impltmp
rforitm$work0<x0>(x0) =
(
  $UN.p2tr_set<r0>(p0, r0))
where
{
val r0 = $UN.p2tr_get<r0>(p0)
val r0 = rfolditm$fopr0<x0><r0>(x0, r0)}}
//
}(*where*)//end-of-[gseq_rfolditm0(xs, r0)]
//
#impltmp
< xs:vt >
< x0:vt >
< r0:vt >
gseq_rfolditm1
  (xs, r0) = r0
where {
//
var r0: r0 = r0
//
val p0 = $addr(r0)
//
val () =
(
gseq_rforitm1<xs><x0>(xs)
) where
{
#impltmp
rforitm$work1<x0>(x0) =
(
  $UN.p2tr_set<r0>(p0, r0))
where
{
val r0 = $UN.p2tr_get<r0>(p0)
val r0 = rfolditm$fopr1<x0><r0>(x0, r0)}}
//
}(*where*)//end-of-[gseq_rfolditm1(xs, r0)]
//
(* ****** ****** *)
//
(*
#impltmp
< xs:vt >
< x0:vt >
< r0:vt >
gseq_ifolditm0
  (xs, r0) =
strm_vt_ifolditm0<x0><r0>
(
gseq_strmize0<xs><x0>(xs), r0)
*)
//
#impltmp
< xs:vt >
< x0:vt >
< r0:vt >
gseq_ifolditm0
  (xs, r0) = r0
where {
//
var i0: ni = 0
var r0: r0 = r0
//
val pi = $addr(i0)
val pr = $addr(r0)
//
val () =
(
gseq_foritm0<xs><x0>(xs)
) where
{
#impltmp
foritm$work0<x0>(x0) =
(
  $UN.p2tr_set<r0>(pr, r0)
; $UN.p2tr_set<ni>(pi, i0+1))
where
{
val i0 = $UN.p2tr_get<ni>(pi)
val r0 = $UN.p2tr_get<r0>(pr)
val r0 =
(
  ifolditm$fopr0<x0><r0>(r0, i0, x0))}}
//
}(*where*)//end-of-[gseq_ifolditm0(xs, r0)]
//
#impltmp
< xs:vt >
< x0:vt >
< r0:vt >
gseq_ifolditm1
  (xs, r0) = r0
where {
//
var i0: ni = 0
var r0: r0 = r0
//
val pi = $addr(i0)
val pr = $addr(r0)
//
val () =
(
gseq_foritm1<xs><x0>(xs)
) where
{
#impltmp
foritm$work1<x0>(x0) =
(
  $UN.p2tr_set<r0>(pr, r0)
; $UN.p2tr_set<ni>(pi, i0+1))
where
{
val i0 = $UN.p2tr_get<ni>(pi)
val r0 = $UN.p2tr_get<r0>(pr)
val r0 =
(
  ifolditm$fopr1<x0><r0>(r0, i0, x0))}}
//
}(*where*)//end-of-[gseq_ifolditm1(xs, r0)]
//
(* ****** ****** *)
//
(*
#impltmp
< xs:vt >
< x0:vt >
< r0:vt >
gseq_irfolditm0
  (xs, r0) =
strm_vt_irfolditm0<x0><r0>
(
gseq_strmize0<xs><x0>(xs), r0)
*)
//
#impltmp
< xs:vt >
< x0:vt >
< r0:vt >
gseq_irfolditm0
  (xs, r0) = r0
where {
//
var i0: ni = 0
var r0: r0 = r0
//
val pi = $addr(i0)
val pr = $addr(r0)
//
val () =
(
gseq_rforitm0<xs><x0>(xs)
) where
{
#impltmp
rforitm$work0<x0>(x0) =
(
  $UN.p2tr_set<r0>(pr, r0)
; $UN.p2tr_set<ni>(pi, i0+1))
where
{
val i0 = $UN.p2tr_get<ni>(pi)
val r0 = $UN.p2tr_get<r0>(pr)
val r0 =
(
  irfolditm$fopr0<x0><r0>(i0, x0, r0))}}
//
}(*where*)//end-of-[gseq_irfolditm0(xs, r0)]
//
#impltmp
< xs:vt >
< x0:vt >
< r0:vt >
gseq_irfolditm1
  (xs, r0) = r0
where {
//
var i0: ni = 0
var r0: r0 = r0
//
val pi = $addr(i0)
val pr = $addr(r0)
//
val () =
(
gseq_rforitm1<xs><x0>(xs)
) where
{
#impltmp
rforitm$work1<x0>(x0) =
(
  $UN.p2tr_set<r0>(pr, r0)
; $UN.p2tr_set<ni>(pi, i0+1))
where
{
val i0 = $UN.p2tr_get<ni>(pi)
val r0 = $UN.p2tr_get<r0>(pr)
val r0 =
(
  irfolditm$fopr1<x0><r0>(i0, x0, r0))}}
//
}(*where*)//end-of-[gseq_irfolditm1(xs, r0)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
< r0:vt >
gseq_foldall0
  (xs, r0) = r0
where {
//
var r0: r0 = r0
//
val p0 = $addr(r0)
//
val b0 =
(
gseq_forall0<xs><x0>(xs)
) where
{
#impltmp
forall$test0<x0>(x0) =
(
$UN.p2tr_set<r0>(p0, r0); b0)
where
{
val r0 = $UN.p2tr_get<r0>(p0)
val (b0, r0) =
(
  foldall$fopr0<x0><r0>(r0, x0)) } }
//
}(*where*)//end-of-[gseq_foldall0(xs, r0)]
//
#impltmp
< xs:vt >
< x0:vt >
< r0:vt >
gseq_foldall1
  (xs, r0) = r0
where {
//
var r0: r0 = r0
//
val p0 = $addr(r0)
//
val b0 =
(
gseq_forall1<xs><x0>(xs)
) where
{
#impltmp
forall$test1<x0>(x0) =
(
$UN.p2tr_set<r0>(p0, r0); b0)
where
{
val r0 = $UN.p2tr_get<r0>(p0)
val (b0, r0) =
(
  foldall$fopr1<x0><r0>(r0, x0)) } }
//
}(*where*)//end-of-[gseq_foldall1(xs, r0)]
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
< r0:vt >
gseq_rfoldall0
  (xs, r0) = r0
where {
//
var r0: r0 = r0
//
val p0 = $addr(r0)
//
val b0 =
(
gseq_rforall0<xs><x0>(xs)
) where
{
#impltmp
rforall$test0<x0>(x0) =
(
$UN.p2tr_set<r0>(p0, r0); b0)
where
{
val r0 = $UN.p2tr_get<r0>(p0)
val (b0, r0) =
(
  rfoldall$fopr0<x0><r0>(x0, r0)) } }
//
}(*where*)//end-of-[gseq_rfoldall0(xs, r0)]
//
#impltmp
< xs:vt >
< x0:vt >
< r0:vt >
gseq_rfoldall1
  (xs, r0) = r0
where {
//
var r0: r0 = r0
//
val p0 = $addr(r0)
//
val b0 =
(
gseq_rforall1<xs><x0>(xs)
) where
{
#impltmp
rforall$test1<x0>(x0) =
(
$UN.p2tr_set<r0>(p0, r0); b0)
where
{
val r0 = $UN.p2tr_get<r0>(p0)
val (b0, r0) =
(
  rfoldall$fopr1<x0><r0>(x0, r0)) } }
//
}(*where*)//end-of-[gseq_rfoldall1(xs, r0)]
//
(* ****** ****** *)
//
(*
#impltmp
< xs:vt >
< x0:vt >
< r0:vt >
gseq_ifoldall0
  (xs, r0) =
strm_vt_ifoldall0<x0><r0>
(
gseq_strmize0<xs><x0>(xs), r0)
*)
#impltmp
< xs:vt >
< x0:vt >
< r0:vt >
gseq_ifoldall0
  (xs, r0) = r0
where {
//
var i0: ni = 0
var r0: r0 = r0
//
val pi = $addr(i0)
val pr = $addr(r0)
//
val b0 =
(
gseq_forall0<xs><x0>(xs)
) where
{
#impltmp
forall$test0
< x0 >( x0 ) = ( b0 )
where
{
val () =
$UN.p2tr_set<r0>(pr, r0)
val () =
$UN.p2tr_set<ni>(pi, i0+1)}
where
{
val i0 = $UN.p2tr_get<ni>(pi)
val r0 = $UN.p2tr_get<r0>(pr)
val (b0, r0) =
(
  ifoldall$fopr0<x0><r0>(r0, i0, x0))}}
//
}(*where*)//end-of-[gseq_ifoldall0(xs, r0)]
//
#impltmp
< xs:vt >
< x0:vt >
< r0:vt >
gseq_ifoldall1
  (xs, r0) = r0
where {
//
var i0: ni = 0
var r0: r0 = r0
//
val pi = $addr(i0)
val pr = $addr(r0)
//
val b0 =
(
gseq_forall1<xs><x0>(xs)
) where
{
#impltmp
forall$test1
< x0 >( x0 ) = ( b0 )
where
{
val () =
$UN.p2tr_set<r0>(pr, r0)
val () =
$UN.p2tr_set<ni>(pi, i0+1)}
where
{
val i0 = $UN.p2tr_get<ni>(pi)
val r0 = $UN.p2tr_get<r0>(pr)
val (b0, r0) =
(
  ifoldall$fopr1<x0><r0>(r0, i0, x0))}}
//
}(*where*)//end-of-[gseq_ifoldall1(xs, r0)]
//
(* ****** ****** *)
//
(*
#impltmp
< xs:vt >
< x0:vt >
< r0:vt >
gseq_irfoldall0
  (xs, r0) =
strm_vt_irfoldall0<x0><r0>
(
gseq_strmize0<xs><x0>(xs), r0)
*)
#impltmp
< xs:vt >
< x0:vt >
< r0:vt >
gseq_irfoldall0
  (xs, r0) = r0
where {
//
var i0: ni = 0
var r0: r0 = r0
//
val pi = $addr(i0)
val pr = $addr(r0)
//
val b0 =
(
gseq_rforall0<xs><x0>(xs)
) where
{
#impltmp
rforall$test0
< x0 >( x0 ) = ( b0 )
where
{
val () =
$UN.p2tr_set<r0>(pr, r0)
val () =
$UN.p2tr_set<ni>(pi, i0+1)}
where
{
val i0 = $UN.p2tr_get<ni>(pi)
val r0 = $UN.p2tr_get<r0>(pr)
val (b0, r0) =
(
  irfoldall$fopr0<x0><r0>(i0, x0, r0))}}
//
}(*where*)//end-of-[gseq_irfoldall0(xs, r0)]
//
#impltmp
< xs:vt >
< x0:vt >
< r0:vt >
gseq_irfoldall1
  (xs, r0) = r0
where {
//
var i0: ni = 0
var r0: r0 = r0
//
val pi = $addr(i0)
val pr = $addr(r0)
//
val b0 =
(
gseq_rforall1<xs><x0>(xs)
) where
{
#impltmp
rforall$test1
< x0 >( x0 ) = ( b0 )
where
{
val () =
$UN.p2tr_set<r0>(pr, r0)
val () =
$UN.p2tr_set<ni>(pi, i0+1)}
where
{
val i0 = $UN.p2tr_get<ni>(pi)
val r0 = $UN.p2tr_get<r0>(pr)
val (b0, r0) =
(
  irfoldall$fopr1<x0><r0>(i0, x0, r0))}}
//
}(*where*)//end-of-[gseq_irfoldall1(xs, r0)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
#impltmp
< xs:vt >
< x0:vt >
< y0:vt >
gseq_map0_llist
  ( xs ) =
list_vt_map0<x0><y0>
(gseq_listize0<xs><x0>(xs))
*)
//
#impltmp
< xs:vt >
< x0:vt >
< y0:vt >
gseq_map0_lstrm
  ( xs ) =
strm_vt_map0<x0><y0>
(gseq_strmize0<xs><x0>(xs))
#impltmp
< xs:vt >
< x0:vt >
< y0:vt >
gseq_map0_lstrq
  ( xs ) =
strq_vt_map0<x0><y0>
(gseq_strqize0<xs><x0>(xs))
//
#impltmp
< xs:vt >
< x0:vt >
< y0:vt >
gseq_map0_llist
  ( xs ) =
strm_vt_listize0<y0>
(gseq_map0_lstrm<xs><x0><y0>(xs))
//
(* ****** ****** *)
//
(*
#impltmp
< xs:vt >
< x0:vt >
< y0:vt >
gseq_rmap0_llist
  ( xs ) =
list_vt_map0<x0><y0>
(gseq_rlistize0<xs><x0>(xs))
*)
//
#impltmp
< xs:vt >
< x0:vt >
< y0:vt >
gseq_rmap0_lstrm
  ( xs ) =
strm_vt_map0<x0><y0>
(gseq_rstrmize0<xs><x0>(xs))
where {
#impltmp
map$fopr0
< x0 >< y0 > = rmap$fopr0<x0><y0>
}(*where*)
#impltmp
< xs:vt >
< x0:vt >
< y0:vt >
gseq_rmap0_lstrq
  ( xs ) =
strq_vt_map0<x0><y0>
(gseq_rstrqize0<xs><x0>(xs))
where {
#impltmp
map$fopr0
< x0 >< y0 > = rmap$fopr0<x0><y0>
}(*where*)
//
#impltmp
< xs:vt >
< x0:vt >
< y0:vt >
gseq_rmap0_llist
  ( xs ) =
strm_vt_listize0<y0>
(gseq_rmap0_lstrm<xs><x0><y0>(xs))
//
(* ****** ****** *)
//
(*
#impltmp
< xs:vt >
< x0:vt >
< y0:vt >
gseq_imap0_llist
  ( xs ) =
list_vt_imap0<x0><y0>
(gseq_listize0<xs><x0>(xs))
*)
//
#impltmp
< xs:vt >
< x0:vt >
< y0:vt >
gseq_imap0_lstrm
  ( xs ) =
strm_vt_imap0<x0><y0>
(gseq_strmize0<xs><x0>(xs))
#impltmp
< xs:vt >
< x0:vt >
< y0:vt >
gseq_imap0_lstrq
  ( xs ) =
strq_vt_imap0<x0><y0>
(gseq_strqize0<xs><x0>(xs))
//
#impltmp
< xs:vt >
< x0:vt >
< y0:vt >
gseq_imap0_llist
  ( xs ) =
strm_vt_listize0<y0>
(gseq_imap0_lstrm<xs><x0><y0>(xs))
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
< y0:vt >
gseq_irmap0_lstrm
  ( xs ) =
strm_vt_imap0<x0><y0>
(gseq_rstrmize0<xs><x0>(xs))
where {
#impltmp
imap$fopr0
< x0 >< y0 > = irmap$fopr0<x0><y0>
}(*where*)
//
#impltmp
< xs:vt >
< x0:vt >
< y0:vt >
gseq_irmap0_lstrq
  ( xs ) =
strq_vt_imap0<x0><y0>
(gseq_rstrqize0<xs><x0>(xs))
where {
#impltmp
imap$fopr0
< x0 >< y0 > = irmap$fopr0<x0><y0>
}(*where*)
//
#impltmp
< xs:vt >
< x0:vt >
< y0:vt >
gseq_irmap0_llist
  ( xs ) =
strm_vt_listize0<y0>
(gseq_irmap0_lstrm<xs><x0><y0>(xs))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_filter0_lstrm
  ( xs ) =
strm_vt_filter0<x0>
(gseq_strmize0<xs><x0>(xs))
#impltmp
< xs:vt >
< x0:vt >
gseq_filter0_lstrq
  ( xs ) =
strq_vt_filter0<x0>
(gseq_strqize0<xs><x0>(xs))
//
(*
HX-2024-07-13:
Laziness here can prevent
the creation of an unnecessarily
long list for temporary use!
*)
#impltmp
< xs:vt >
< x0:vt >
gseq_filter0_llist
  ( xs ) =
strm_vt_listize0<x0>
(
gseq_filter0_lstrm<xs><x0>(xs))
//
(* ****** ****** *)
//
(*
HX-2024-07-24:
Wed 24 Jul 2024 04:33:40 PM EDT
*)
#impltmp
< xs:vt >
< x0:vt >
gseq_rfilter0_lstrm
  ( xs ) =
strm_vt_filter0<x0>
(gseq_rstrmize0<xs><x0>(xs))
#impltmp
< xs:vt >
< x0:vt >
gseq_rfilter0_lstrq
  ( xs ) =
strq_vt_filter0<x0>
(gseq_rstrqize0<xs><x0>(xs))
//
#impltmp
< xs:vt >
< x0:vt >
gseq_rfilter0_llist
  ( xs ) =
strm_vt_listize0<x0>
(
gseq_rfilter0_lstrm<xs><x0>(xs))
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_ifilter0_lstrm
  ( xs ) =
strm_vt_ifilter0<x0>
(gseq_strmize0<xs><x0>(xs))
#impltmp
< xs:vt >
< x0:vt >
gseq_ifilter0_lstrq
  ( xs ) =
strq_vt_ifilter0<x0>
(gseq_strqize0<xs><x0>(xs))
//
(*
HX-2024-07-13:
Laziness here can prevent
the creation of an unnecessarily
long list for temporary use!
*)
#impltmp
< xs:vt >
< x0:vt >
gseq_ifilter0_llist
  ( xs ) =
strm_vt_listize0<x0>
(
gseq_ifilter0_lstrm<xs><x0>(xs))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-17:
Wed Dec 17 01:55:29 PM EST 2025
*)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_filter0$f1un_lstrm
  (xs, test) =
(
gseq_filter0_lstrm
< xs >< x0 >( xs )) where
{
#impltmp
filter$test1<x0> = test(*x0*) }
//
#impltmp
< xs:vt >
< x0:vt >
gseq_filter0$f1un_lstrq
  (xs, test) =
(
gseq_filter0_lstrq
< xs >< x0 >( xs )) where
{
#impltmp
filter$test1<x0> = test(*x0*) }
//
#impltmp
< xs:vt >
< x0:vt >
gseq_filter0$f1un_llist
  (xs, test) =
(
gseq_filter0_llist
< xs >< x0 >( xs )) where
{
#impltmp
filter$test1<x0> = test(*x0*) }
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-16:
Tue 16 Jul 2024 11:19:32 AM EDT
*)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_exists0
  ( xs ) =
let
//
#impltmp
forall$test0<x0>(x0) =
(
  not(exists$test0<x0>(x0)))
//
in//let
  not(gseq_forall0<xs><x0>(xs))
end//let//end-of-[gseq_exists0(xs)]
//
#impltmp
< xs:vt >
< x0:vt >
gseq_exists1
  ( xs ) =
let
//
#impltmp
forall$test1<x0>(x0) =
(
  not(exists$test1<x0>(x0)))
//
in//let
  not(gseq_forall1<xs><x0>(xs))
end//let//end-of-[gseq_exists1(xs)]
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_rexists0
  ( xs ) =
let
//
#impltmp
rforall$test0<x0>(x0) =
(
  not(rexists$test0<x0>(x0)))
//
in//let
  not(gseq_rforall0<xs><x0>(xs))
end(*let*)//end-of-[gseq_rexists0(xs)]
//
#impltmp
< xs:vt >
< x0:vt >
gseq_rexists1
  ( xs ) =
let
//
#impltmp
rforall$test1<x0>(x0) =
(
  not(rexists$test1<x0>(x0)))
//
in//let
  not(gseq_rforall1<xs><x0>(xs))
end(*let*)//end-of-[gseq_rexists1(xs)]
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_iexists0
  ( xs ) =
(
not(gseq_iforall0<xs><x0>(xs))
) where
{
//
#impltmp
iforall$test0<x0>(i0, x0) =
(
  not(iexists$test0<x0>(i0, x0)))
//
}(*where*)//end-of-[gseq_iexists0(xs)]
//
#impltmp
< xs:vt >
< x0:vt >
gseq_iexists1
  ( xs ) =
(
not(gseq_iforall1<xs><x0>(xs))
) where
{
//
#impltmp
iforall$test1<x0>(i0, x0) =
(
  not(iexists$test1<x0>(i0, x0)))
//
}(*where*)//end-of-[gseq_iexists1(xs)]
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_irexists0
  ( xs ) =
(
not(gseq_irforall0<xs><x0>(xs))
) where
{
//
#impltmp
irforall$test0<x0>(i0, x0) =
(
  not(irexists$test0<x0>(i0, x0)))
//
}(*where*)//end-of-[gseq_irexists0(xs)]
//
#impltmp
< xs:vt >
< x0:vt >
gseq_irexists1
  ( xs ) =
(
not(gseq_irforall1<xs><x0>(xs))
) where
{
//
#impltmp
irforall$test1<x0>(i0, x0) =
(
  not(irexists$test1<x0>(i0, x0)))
//
}(*where*)//end-of-[gseq_irexists1(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-06-01:
Sun Jun  1 08:07:55 PM EDT 2025
*)
//
#impltmp
< xs:vt >
< x0:vt >
< y0:vt >
< e1:vt >
gseq_map$e1nv0_llist
  ( xs, e1 ) =
(
gseq_map0_llist<xs><x0><y0>(xs)
) where
{
#impltmp
map$fopr0<x0><y0>(x0) =
(
  map$e1nv$fopr0<x0><y0><e1>(x0, e1))
}(*where*)//end-of-[gseq_map$e1nv0_llist(xs,e1)]
#impltmp
< xs:vt >
< x0:vt >
< y0:vt >
< e1:vt >
gseq_map$e1nv1_llist
  ( xs, e1 ) =
(
gseq_map1_llist<xs><x0><y0>(xs)
) where
{
#impltmp
map$fopr1<x0><y0>(x0) =
(
  map$e1nv$fopr1<x0><y0><e1>(x0, e1))
}(*where*)//end-of-[gseq_map$e1nv1_llist(xs,e1)]
//
#impltmp
< xs:vt >
< x0:vt >
< y0:vt >
< e1:vt >
gseq_map$e1nv0$f2un_llist
  ( xs, e1, fopr ) =
(
gseq_map$e1nv0_llist
<xs><x0><y0><e1>(xs, e1)) where
{
#impltmp map$e1nv$fopr0<x0><y0><e1> = fopr
}
#impltmp
< xs:vt >
< x0:vt >
< y0:vt >
< e1:vt >
gseq_map$e1nv1$f2un_llist
  ( xs, e1, fopr ) =
(
gseq_map$e1nv1_llist
<xs><x0><y0><e1>(xs, e1)) where
{
#impltmp map$e1nv$fopr1<x0><y0><e1> = fopr
}
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
< y0:vt >
< e1:vt >
gseq_map$e1nv0_lstrm
  ( xs, e1 ) =
(
gseq_map0_lstrm<xs><x0><y0>(xs)
) where
{
#impltmp
map$fopr0<x0><y0>(x0) =
(
  map$e1nv$fopr0<x0><y0><e1>(x0, e1))
}(*where*)//end-of-[gseq_map$e1nv0_lstrm(xs,e1)]
#impltmp
< xs:vt >
< x0:vt >
< y0:vt >
< e1:vt >
gseq_map$e1nv0_lstrq
  ( xs, e1 ) =
(
gseq_map0_lstrq<xs><x0><y0>(xs)
) where
{
#impltmp
map$fopr0<x0><y0>(x0) =
(
  map$e1nv$fopr0<x0><y0><e1>(x0, e1))
}(*where*)//end-of-[gseq_map$e1nv0_lstrq(xs,e1)]
//
#impltmp
< xs:vt >
< x0:vt >
< y0:vt >
< e1:vt >
gseq_map$e1nv0$f2un_lstrm
  ( xs, e1, fopr ) =
(
gseq_map$e1nv0_lstrm
<xs><x0><y0><e1>(xs, e1)) where
{
#impltmp map$e1nv$fopr0<x0><y0><e1> = fopr
}
#impltmp
< xs:vt >
< x0:vt >
< y0:vt >
< e1:vt >
gseq_map$e1nv0$f2un_lstrq
  ( xs, e1, fopr ) =
(
gseq_map$e1nv0_lstrq
<xs><x0><y0><e1>(xs, e1)) where
{
#impltmp map$e1nv$fopr0<x0><y0><e1> = fopr
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-16:
Fri Dec 26 01:32:57 PM EST 2025
*)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_ord$exists0
  (   xs   ) =
(
  strm_vt_ord$exists0<x0>(xs))
where
{
  val xs = gseq_strmize0<xs><x0>(xs)
}(*where*)//end-of-[gseq_ord$exists0<xs><x0>(xs)]
//
#impltmp
< xs:vt >
< x0:vt >
gseq_ord$iexists0
  (   xs   ) =
(
  strm_vt_ord$iexists0<x0>(xs))
where
{
  val xs = gseq_strmize0<xs><x0>(xs)
}(*where*)//end-of-[gseq_ord$iexists0<xs><x0>(xs)]
//
#impltmp
< xs:vt >
< x0:vt >
gseq_ord$exists0$f1un
  ( xs, tcmp ) =
(
  gseq_ord$exists0<xs><x0>(xs))
where
{
#impltmp exists$tcmp0<x0>(*x0*) = tcmp(*x0*)
}(*where*)//end-of-[gseq_ord$exists0$f1un<xs><x0>(...)]
//
#impltmp
< xs:vt >
< x0:vt >
gseq_ord$iexists0$f2un
  ( xs, tcmp ) =
(
  gseq_ord$iexists0<xs><x0>(xs))
where
{
#impltmp iexists$tcmp0<x0>(*i0,x0*) = tcmp(*i0,x0*)
}(*where*)//end-of-[gseq_ord$iexists0$f2un<xs><x0>(...)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_VT_gseq001_vt.dats] *)
(***********************************************************************)
`,
  "DATS/VT/gseq002_vt.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon 08 Jul 2024 12:53:10 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
< ys:vt >
< y0:vt >
gseq_z2forall0
  (xs, ys) =
strm_vt_z2forall0<x0><y0>
(
gseq_strmize0<xs><x0>(xs),
gseq_strmize0<ys><y0>(ys))//end-impltmp
//
#impltmp
< xs:vt >
< x0:vt >
< ys:vt >
< y0:vt >
gseq_z2forall1
  (xs, ys) =
strm_vt_z2forall0<x0><y0>
(
gseq_strmize1<xs><x0>(xs),
gseq_strmize1<ys><y0>(ys))//end-impltmp
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
< ys:vt >
< y0:vt >
gseq_z2rforall0
  (xs, ys) =
strm_vt_z2forall0<x0><y0>
(
gseq_rstrmize0<xs><x0>(xs),
gseq_rstrmize0<ys><y0>(ys))//end-impltmp
//
#impltmp
< xs:vt >
< x0:vt >
< ys:vt >
< y0:vt >
gseq_z2rforall1
  (xs, ys) =
strm_vt_z2forall0<x0><y0>
(
gseq_rstrmize1<xs><x0>(xs),
gseq_rstrmize1<ys><y0>(ys))//end-impltmp
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
< ys:vt >
< y0:vt >
gseq_z2iforall0
  (xs, ys) = b0
where {
//
var i0: ni = (0)
//
val p0 = $addr(i0)
//
val b0 =
(
gseq_z2forall0
<xs><x0><ys><y0>(xs, ys)) where
{
#impltmp
z2forall$test0
<x0><y0>(x0, y0) =
(
$UN.p2tr_set<ni>(p0, i0+1); b0)
where
{
val i0 = $UN.p2tr_get<ni>(p0)
val b0 =
  z2iforall$test0<x0><y0>(i0, x0, y0) } }
//
}(*where*)//end-of-[gseq_z2iforall0(xs,ys)]
//
#impltmp
< xs:vt >
< x0:vt >
< ys:vt >
< y0:vt >
gseq_z2iforall1
  (xs, ys) = b0
where {
//
var i0: ni = (0)
//
val p0 = $addr(i0)
//
val b0 =
(
gseq_z2forall1
<xs><x0><ys><y0>(xs, ys)) where
{
#impltmp
z2forall$test1
<x0><y0>(x0, y0) =
(
$UN.p2tr_set<ni>(p0, i0+1); b0)
where
{
val i0 = $UN.p2tr_get<ni>(p0)
val b0 =
  z2iforall$test1<x0><y0>(i0, x0, y0) } }
//
}(*where*)//end-of-[gseq_z2iforall1(xs,ys)]
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
< ys:vt >
< y0:vt >
gseq_z2irforall0
  (xs, ys) = b0
where {
//
var i0: ni = (0)
//
val p0 = $addr(i0)
//
val b0 =
(
gseq_z2rforall0
<xs><x0><ys><y0>(xs, ys)) where
{
#impltmp
z2rforall$test0
<x0><y0>(x0, y0) =
(
$UN.p2tr_set<ni>(p0, i0+1); b0)
where
{
val i0 = $UN.p2tr_get<ni>(p0)
val b0 =
  z2irforall$test0<x0><y0>(i0, x0, y0) } }
//
}(*where*)//end-of-[gseq_z2irforall0(xs,ys)]
//
#impltmp
< xs:vt >
< x0:vt >
< ys:vt >
< y0:vt >
gseq_z2irforall1
  (xs, ys) = b0
where {
//
var i0: ni = (0)
//
val p0 = $addr(i0)
//
val b0 =
(
gseq_z2rforall1
<xs><x0><ys><y0>(xs, ys)) where
{
#impltmp
z2rforall$test1
<x0><y0>(x0, y0) =
(
$UN.p2tr_set<ni>(p0, i0+1); b0)
where
{
val i0 = $UN.p2tr_get<ni>(p0)
val b0 =
  z2irforall$test1<x0><y0>(i0, x0, y0) } }
//
}(*where*)//end-of-[gseq_z2irforall1(xs,ys)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
< ys:vt >
< y0:vt >
gseq_z2foritm0
  (xs, ys) =
(
let
val _ =
gseq_z2forall0
<xs><x0><ys><y0>(xs, ys) in () end
) where
{
#impltmp
z2forall$test0<x0><y0>(x0, y0) =
let
val () =
z2foritm$work0<x0><y0>(x0, y0) in true end
}(*where*)//end-of-[gseq_z2foritm0(xs,ys)]
//
#impltmp
< xs:vt >
< x0:vt >
< ys:vt >
< y0:vt >
gseq_z2foritm1
  (xs, ys) =
(
let
val _ =
gseq_z2forall1
<xs><x0><ys><y0>(xs, ys) in () end
) where
{
#impltmp
z2forall$test1<x0><y0>(x0, y0) =
let
val () =
z2foritm$work1<x0><y0>(x0, y0) in true end
}(*where*)//end-of-[gseq_z2foritm1(xs,ys)]
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
< ys:vt >
< y0:vt >
gseq_z2rforitm0
  (xs, ys) =
(
let
val _ =
gseq_z2rforall0
<xs><x0><ys><y0>(xs, ys) in () end
) where
{
#impltmp
z2rforall$test0<x0><y0>(x0, y0) =
let
val () =
z2rforitm$work0<x0><y0>(x0, y0) in true end
}(*where*)//end-of-[gseq_z2rforitm0(xs,ys)]
//
#impltmp
< xs:vt >
< x0:vt >
< ys:vt >
< y0:vt >
gseq_z2rforitm1
  (xs, ys) =
(
let
val _ =
gseq_z2rforall1
<xs><x0><ys><y0>(xs, ys) in () end
) where
{
#impltmp
z2rforall$test1<x0><y0>(x0, y0) =
let
val () =
z2rforitm$work1<x0><y0>(x0, y0) in true end
}(*where*)//end-of-[gseq_z2rforitm1(xs,ys)]
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
< ys:vt >
< y0:vt >
gseq_z2iforitm0
  (xs, ys) =
(
let
val _ =
gseq_z2iforall0
<xs><x0><ys><y0>(xs, ys) in () end
) where
{
#impltmp
z2iforall$test0<x0><y0>(i0, x0, y0) =
let
val () =
z2iforitm$work0<x0><y0>(i0, x0, y0) in true end
}(*where*)//end-of-[gseq_z2iforitm0(xs,ys)]
//
#impltmp
< xs:vt >
< x0:vt >
< ys:vt >
< y0:vt >
gseq_z2iforitm1
  (xs, ys) =
(
let
val _ =
gseq_z2iforall1
<xs><x0><ys><y0>(xs, ys) in () end
) where
{
#impltmp
z2iforall$test1<x0><y0>(i0, x0, y0) =
let
val () =
z2iforitm$work1<x0><y0>(i0, x0, y0) in true end
}(*where*)//end-of-[gseq_z2iforitm1(xs,ys)]
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
< ys:vt >
< y0:vt >
gseq_z2irforitm0
  (xs, ys) =
(
let
val _ =
gseq_z2irforall0
<xs><x0><ys><y0>(xs, ys) in () end
) where
{
#impltmp
z2irforall$test0<x0><y0>(i0, x0, y0) =
let
val () =
z2irforitm$work0<x0><y0>(i0, x0, y0) in true end
}(*where*)//end-of-[gseq_z2irforitm0(xs,ys)]
//
#impltmp
< xs:vt >
< x0:vt >
< ys:vt >
< y0:vt >
gseq_z2irforitm1
  (xs, ys) =
(
let
val _ =
gseq_z2irforall1
<xs><x0><ys><y0>(xs, ys) in () end
) where
{
#impltmp
z2irforall$test1<x0><y0>(i0, x0, y0) =
let
val () =
z2irforitm$work1<x0><y0>(i0, x0, y0) in true end
}(*where*)//end-of-[gseq_z2irforitm1(xs,ys)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-24:
Wed 24 Jul 2024 07:03:35 PM EDT
*)
//
#impltmp
< xs:vt >
< x0:vt >
< ys:vt >
< y0:vt >
< zs:vt >
< z0:vt >
gseq_z2map0_ares
  (xs, ys) =
g_make_lstrm<z0><zs>
(
gseq_z2map0_lstrm<xs><x0><ys><y0><z0>(xs, ys))
//
#impltmp
< xs:vt >
< x0:vt >
< ys:vt >
< y0:vt >
gseq_z2map0_self
  (xs, ys) =
g_make_lstrm<x0><xs>
(
gseq_z2map0_lstrm<xs><x0><ys><y0><x0>(xs, ys))
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_VT_gseq002_vt.dats] *)
(***********************************************************************)
`,
  "DATS/VT/gsyn000_vt.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sun 28 Jul 2024 04:18:27 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
gs_print$beg0() = ()
//
#impltmp
<(*tmp*)>
gs_print$end0() = ()
(*
#impltmp
<(*tmp*)>
gs_print$end0() = strn_print("\\n")
*)
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
gs_print0_a1
  ( x0 ) =
( gs_print$beg0<>();
(
  g_print0<x0>(x0))
; gs_print$end0<>())
//
#impltmp
< x0:vt >
< x1:vt >
gs_print0_a2
  (x0, x1) =
( gs_print$beg0<>();
( g_print0<x0>(x0); g_print0<x1>(x1))
; gs_print$end0<>())
//
#impltmp
< x0:vt >
< x1:vt >
< x2:vt >
gs_print0_a3
  (x0, x1, x2) =
( gs_print$beg0<>();
( g_print0<x0>(x0)
; g_print0<x1>(x1); g_print0<x2>(x2))
; gs_print$end0<>())
//
#impltmp
< x0:vt >
< x1:vt >
< x2:vt >
< x3:vt >
gs_print0_a4
  (x0, x1, x2, x3) =
( gs_print$beg0<>();
( g_print0<x0>(x0); g_print0<x1>(x1)
; g_print0<x2>(x2); g_print0<x3>(x3))
; gs_print$end0<>())
//
#impltmp
< x0:vt >
< x1:vt >
< x2:vt >
< x3:vt >
< x4:vt >
gs_print0_a5
  (x0, x1, x2, x3, x4) =
( gs_print$beg0<>();
( g_print0<x0>(x0); g_print0<x1>(x1)
; g_print0<x2>(x2); g_print0<x3>(x3); g_print0<x4>(x4))
; gs_print$end0<>())
//
#impltmp
< x0:vt >
< x1:vt >
< x2:vt >
< x3:vt >
< x4:vt >
< x5:vt >
gs_print0_a6
  (x0, x1, x2, x3, x4, x5) =
( gs_print$beg0<>();
( g_print0<x0>(x0); g_print0<x1>(x1); g_print0<x2>(x2)
; g_print0<x3>(x3); g_print0<x4>(x4); g_print0<x5>(x5))
; gs_print$end0<>())
//
#impltmp
< x0:vt >
< x1:vt >
< x2:vt >
< x3:vt >
< x4:vt >
< x5:vt >
< x6:vt >
gs_print0_a7
  (x0, x1, x2, x3, x4, x5, x6) =
( gs_print$beg0<>();
( g_print0<x0>(x0)
; g_print0<x1>(x1); g_print0<x2>(x2); g_print0<x3>(x3)
; g_print0<x4>(x4); g_print0<x5>(x5); g_print0<x6>(x6))
; gs_print$end0<>())
//
#impltmp
< x0:vt >
< x1:vt >
< x2:vt >
< x3:vt >
< x4:vt >
< x5:vt >
< x6:vt >
< x7:vt >
gs_print0_a8
  (x0, x1, x2, x3, x4, x5, x6, x7) =
( gs_print$beg0<>();
( g_print0<x0>(x0); g_print0<x1>(x1)
; g_print0<x2>(x2); g_print0<x3>(x3); g_print0<x4>(x4)
; g_print0<x5>(x5); g_print0<x6>(x6); g_print0<x7>(x7))
; gs_print$end0<>())
//
#impltmp
< x0:vt >
< x1:vt >
< x2:vt >
< x3:vt >
< x4:vt >
< x5:vt >
< x6:vt >
< x7:vt >
< x8:vt >
gs_print0_a9
  (x0, x1, x2, x3, x4, x5, x6, x7, x8) =
( gs_print$beg0<>();
( g_print0<x0>(x0); g_print0<x1>(x1); g_print0<x2>(x2)
; g_print0<x3>(x3); g_print0<x4>(x4); g_print0<x5>(x5)
; g_print0<x6>(x6); g_print0<x7>(x7); g_print0<x8>(x8))
; gs_print$end0<>())
//
#impltmp
< x0:vt >
< x1:vt >
< x2:vt >
< x3:vt >
< x4:vt >
< x5:vt >
< x6:vt >
< x7:vt >
< x8:vt >
< x9:vt >
gs_print0_a10
  (x0, x1, x2, x3, x4, x5, x6, x7, x8, x9) =
( gs_print$beg0<>();
( g_print0<x0>(x0); g_print0<x1>(x1); g_print0<x2>(x2)
; g_print0<x3>(x3); g_print0<x4>(x4); g_print0<x5>(x5)
; g_print0<x6>(x6); g_print0<x7>(x7); g_print0<x8>(x8); g_print0<x9>(x9))
; gs_print$end0<>())
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
< x1:vt >
< x2:vt >
< x3:vt >
< x4:vt >
< x5:vt >
< x6:vt >
< x7:vt >
< x8:vt >
< x9:vt >
< x10:vt >
gs_print0_a11
  (x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10) =
( gs_print$beg0<>();
( g_print0<x0>(x0); g_print0<x1>(x1); g_print0<x2>(x2)
; g_print0<x3>(x3); g_print0<x4>(x4); g_print0<x5>(x5); g_print0<x6>(x6)
; g_print0<x7>(x7); g_print0<x8>(x8); g_print0<x9>(x9); g_print0<x10>(x10))
; gs_print$end0<>())
//
#impltmp
< x0:vt >
< x1:vt >
< x2:vt >
< x3:vt >
< x4:vt >
< x5:vt >
< x6:vt >
< x7:vt >
< x8:vt >
< x9:vt >
< x10:vt >
< x11:vt >
gs_print0_a12
  (x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11) =
( gs_print$beg0<>();
( g_print0<x0>(x0); g_print0<x1>(x1); g_print0<x2>(x2); g_print0<x3>(x3)
; g_print0<x4>(x4); g_print0<x5>(x5); g_print0<x6>(x6); g_print0<x7>(x7)
; g_print0<x8>(x8); g_print0<x9>(x9); g_print0<x10>(x10); g_print0<x11>(x11))
; gs_print$end0<>())
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
gs_print$beg1() = ()
//
#impltmp
<(*tmp*)>
gs_print$end1() = ()
(*
#impltmp
<(*tmp*)>
gs_print$end1() = strn_print("\\n")
*)
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
gs_print1_a1
  ( x0 ) =
( gs_print$beg1<>();
(
  g_print1<x0>(x0))
; gs_print$end1<>())
//
#impltmp
< x0:vt >
< x1:vt >
gs_print1_a2
  (x0, x1) =
( gs_print$beg1<>();
( g_print1<x0>(x0); g_print1<x1>(x1))
; gs_print$end1<>())
//
#impltmp
< x0:vt >
< x1:vt >
< x2:vt >
gs_print1_a3
  (x0, x1, x2) =
( gs_print$beg1<>();
( g_print1<x0>(x0)
; g_print1<x1>(x1); g_print1<x2>(x2))
; gs_print$end1<>())
//
#impltmp
< x0:vt >
< x1:vt >
< x2:vt >
< x3:vt >
gs_print1_a4
  (x0, x1, x2, x3) =
( gs_print$beg1<>();
( g_print1<x0>(x0); g_print1<x1>(x1)
; g_print1<x2>(x2); g_print1<x3>(x3))
; gs_print$end1<>())
//
#impltmp
< x0:vt >
< x1:vt >
< x2:vt >
< x3:vt >
< x4:vt >
gs_print1_a5
  (x0, x1, x2, x3, x4) =
( gs_print$beg1<>();
( g_print1<x0>(x0); g_print1<x1>(x1)
; g_print1<x2>(x2); g_print1<x3>(x3); g_print1<x4>(x4))
; gs_print$end1<>())
//
#impltmp
< x0:vt >
< x1:vt >
< x2:vt >
< x3:vt >
< x4:vt >
< x5:vt >
gs_print1_a6
  (x0, x1, x2, x3, x4, x5) =
( gs_print$beg1<>();
( g_print1<x0>(x0); g_print1<x1>(x1); g_print1<x2>(x2)
; g_print1<x3>(x3); g_print1<x4>(x4); g_print1<x5>(x5))
; gs_print$end1<>())
//
#impltmp
< x0:vt >
< x1:vt >
< x2:vt >
< x3:vt >
< x4:vt >
< x5:vt >
< x6:vt >
gs_print1_a7
  (x0, x1, x2, x3, x4, x5, x6) =
( gs_print$beg1<>();
( g_print1<x0>(x0)
; g_print1<x1>(x1); g_print1<x2>(x2); g_print1<x3>(x3)
; g_print1<x4>(x4); g_print1<x5>(x5); g_print1<x6>(x6))
; gs_print$end1<>())
//
#impltmp
< x0:vt >
< x1:vt >
< x2:vt >
< x3:vt >
< x4:vt >
< x5:vt >
< x6:vt >
< x7:vt >
gs_print1_a8
  (x0, x1, x2, x3, x4, x5, x6, x7) =
( gs_print$beg1<>();
( g_print1<x0>(x0); g_print1<x1>(x1)
; g_print1<x2>(x2); g_print1<x3>(x3); g_print1<x4>(x4)
; g_print1<x5>(x5); g_print1<x6>(x6); g_print1<x7>(x7))
; gs_print$end1<>())
//
#impltmp
< x0:vt >
< x1:vt >
< x2:vt >
< x3:vt >
< x4:vt >
< x5:vt >
< x6:vt >
< x7:vt >
< x8:vt >
gs_print1_a9
  (x0, x1, x2, x3, x4, x5, x6, x7, x8) =
( gs_print$beg1<>();
( g_print1<x0>(x0); g_print1<x1>(x1); g_print1<x2>(x2)
; g_print1<x3>(x3); g_print1<x4>(x4); g_print1<x5>(x5)
; g_print1<x6>(x6); g_print1<x7>(x7); g_print1<x8>(x8))
; gs_print$end1<>())
//
#impltmp
< x0:vt >
< x1:vt >
< x2:vt >
< x3:vt >
< x4:vt >
< x5:vt >
< x6:vt >
< x7:vt >
< x8:vt >
< x9:vt >
gs_print1_a10
  (x0, x1, x2, x3, x4, x5, x6, x7, x8, x9) =
( gs_print$beg1<>();
( g_print1<x0>(x0); g_print1<x1>(x1); g_print1<x2>(x2)
; g_print1<x3>(x3); g_print1<x4>(x4); g_print1<x5>(x5)
; g_print1<x6>(x6); g_print1<x7>(x7); g_print1<x8>(x8); g_print1<x9>(x9))
; gs_print$end1<>())
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
< x1:vt >
< x2:vt >
< x3:vt >
< x4:vt >
< x5:vt >
< x6:vt >
< x7:vt >
< x8:vt >
< x9:vt >
< x10:vt >
gs_print1_a11
  (x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10) =
( gs_print$beg1<>();
( g_print1<x0>(x0); g_print1<x1>(x1); g_print1<x2>(x2)
; g_print1<x3>(x3); g_print1<x4>(x4); g_print1<x5>(x5); g_print1<x6>(x6)
; g_print1<x7>(x7); g_print1<x8>(x8); g_print1<x9>(x9); g_print1<x10>(x10))
; gs_print$end1<>())
//
#impltmp
< x0:vt >
< x1:vt >
< x2:vt >
< x3:vt >
< x4:vt >
< x5:vt >
< x6:vt >
< x7:vt >
< x8:vt >
< x9:vt >
< x10:vt >
< x11:vt >
gs_print1_a12
  (x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11) =
( gs_print$beg1<>();
( g_print1<x0>(x0); g_print1<x1>(x1); g_print1<x2>(x2); g_print1<x3>(x3)
; g_print1<x4>(x4); g_print1<x5>(x5); g_print1<x6>(x6); g_print1<x7>(x7)
; g_print1<x8>(x8); g_print1<x9>(x9); g_print1<x10>(x10); g_print1<x11>(x11))
; gs_print$end1<>())
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_VT_gsyn000_vt.dats] *)
(***********************************************************************)
`,
  "DATS/VT/gxyz000_vt.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sat 27 Jul 2024 01:32:19 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX:
See [gbas000.dats]
#impltmp
{ x0:t0 }
g_copy<x0>(x0) = x0
#impltmp
{ x0:t0 }
g_free<x0>(x0) = ()
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
g_print0<x0> = g_print<x0>
#impltmp
{ x0:t0 }
g_print1<x0> = g_print<x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-05:
Mon 05 Aug 2024 05:49:43 PM EDT
*)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_strmize0(xs) =
(
  gseq_strmize<xs><x0>(xs))
#impltmp
< xs:t0 >
< x0:t0 >
gseq_strmize1(xs) =
(
  gseq_strmize<xs><x0>(xs))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_rstrmize0(xs) =
(
  gseq_rstrmize<xs><x0>(xs))
#impltmp
< xs:t0 >
< x0:t0 >
gseq_rstrmize1(xs) =
(
  gseq_rstrmize<xs><x0>(xs))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-29:
Sat 03 Aug 2024 05:17:37 PM EDT
*)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_forall0(xs) =
(
  gseq_forall<xs><x0>(xs))
where
{
#impltmp
forall$test<x0> = forall$test0<x0>
}
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_forall1(xs) =
(
  gseq_forall<xs><x0>(xs))
where
{
#impltmp
forall$test<x0> = forall$test1<x0>
}
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_rforall0(xs) =
(
  gseq_rforall<xs><x0>(xs))
where
{
#impltmp
rforall$test<x0> = rforall$test0<x0>
}
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_rforall1(xs) =
(
  gseq_rforall<xs><x0>(xs))
where
{
#impltmp
rforall$test<x0> = rforall$test1<x0>
}
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_iforall0(xs) =
(
  gseq_iforall<xs><x0>(xs))
where
{
#impltmp
iforall$test<x0> = iforall$test0<x0>
}
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_iforall1(xs) =
(
  gseq_iforall<xs><x0>(xs))
where
{
#impltmp
iforall$test<x0> = iforall$test1<x0>
}
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_irforall0(xs) =
(
  gseq_irforall<xs><x0>(xs))
where
{
#impltmp
irforall$test<x0> = irforall$test0<x0>
}
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_irforall1(xs) =
(
  gseq_irforall<xs><x0>(xs))
where
{
#impltmp
irforall$test<x0> = irforall$test1<x0>
}
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_forall0$f1un
  (xs, test) =
(
  gseq_forall$f1un<xs><x0>(xs, test))
#impltmp
< xs:t0 >
< x0:t0 >
gseq_forall1$f1un
  (xs, test) =
(
  gseq_forall$f1un<xs><x0>(xs, test))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_rforall0$f1un
  (xs, test) =
(
  gseq_rforall$f1un<xs><x0>(xs, test))
#impltmp
< xs:t0 >
< x0:t0 >
gseq_rforall1$f1un
  (xs, test) =
(
  gseq_rforall$f1un<xs><x0>(xs, test))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_iforall0$f2un
  (xs, test) =
(
  gseq_iforall$f2un<xs><x0>(xs, test))
#impltmp
< xs:t0 >
< x0:t0 >
gseq_iforall1$f2un
  (xs, test) =
(
  gseq_iforall$f2un<xs><x0>(xs, test))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_irforall0$f2un
  (xs, test) =
(
  gseq_irforall$f2un<xs><x0>(xs, test))
#impltmp
< xs:t0 >
< x0:t0 >
gseq_irforall1$f2un
  (xs, test) =
(
  gseq_irforall$f2un<xs><x0>(xs, test))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-03:
Sat 03 Aug 2024 05:37:49 PM EDT
*)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_foritm0(xs) =
(
  gseq_foritm<xs><x0>(xs))
where
{
#impltmp
foritm$work<x0> = foritm$work0<x0>
}
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_foritm1(xs) =
(
  gseq_foritm<xs><x0>(xs))
where
{
#impltmp
foritm$work<x0> = foritm$work1<x0>
}
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_foritm0$f1un
  (xs, work) =
(
  gseq_foritm$f1un<xs><x0>(xs, work))
#impltmp
< xs:t0 >
< x0:t0 >
gseq_foritm1$f1un
  (xs, work) =
(
  gseq_foritm$f1un<xs><x0>(xs, work))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_rforitm0(xs) =
(
  gseq_rforitm<xs><x0>(xs))
where
{
#impltmp
rforitm$work<x0> = rforitm$work0<x0>
}
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_rforitm1(xs) =
(
  gseq_rforitm<xs><x0>(xs))
where
{
#impltmp
rforitm$work<x0> = rforitm$work1<x0>
}
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_rforitm0$f1un
  (xs, work) =
(
  gseq_rforitm$f1un<xs><x0>(xs, work))
#impltmp
< xs:t0 >
< x0:t0 >
gseq_rforitm1$f1un
  (xs, work) =
(
  gseq_rforitm$f1un<xs><x0>(xs, work))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_iforitm0(xs) =
(
  gseq_iforitm<xs><x0>(xs))
where
{
#impltmp
iforitm$work<x0> = iforitm$work0<x0>
}
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_iforitm1(xs) =
(
  gseq_iforitm<xs><x0>(xs))
where
{
#impltmp
iforitm$work<x0> = iforitm$work1<x0>
}
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_iforitm0$f2un
  (xs, work) =
(
  gseq_iforitm$f2un<xs><x0>(xs, work))
#impltmp
< xs:t0 >
< x0:t0 >
gseq_iforitm1$f2un
  (xs, work) =
(
  gseq_iforitm$f2un<xs><x0>(xs, work))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_irforitm0(xs) =
(
  gseq_irforitm<xs><x0>(xs))
where
{
#impltmp
irforitm$work<x0> = irforitm$work0<x0>
}
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_irforitm1(xs) =
(
  gseq_irforitm<xs><x0>(xs))
where
{
#impltmp
irforitm$work<x0> = irforitm$work1<x0>
}
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_irforitm0$f2un
  (xs, work) =
(
  gseq_irforitm$f2un<xs><x0>(xs, work))
#impltmp
< xs:t0 >
< x0:t0 >
gseq_irforitm1$f2un
  (xs, work) =
(
  gseq_irforitm$f2un<xs><x0>(xs, work))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_folditm0(xs, r0) =
(
gseq_folditm<xs><x0><r0>(xs, r0))
where
{
#impltmp
folditm$fopr<x0><r0> = folditm$fopr0<x0><r0>
}
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_folditm1(xs, r0) =
(
gseq_folditm<xs><x0><r0>(xs, r0))
where
{
#impltmp
folditm$fopr<x0><r0> = folditm$fopr1<x0><r0>
}
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_folditm0$f2un
  (xs, r0, fopr) =
(
gseq_folditm$f2un<xs><x0><r0>(xs, r0, fopr))
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_folditm1$f2un
  (xs, r0, fopr) =
(
gseq_folditm$f2un<xs><x0><r0>(xs, r0, fopr))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_rfolditm0(xs, r0) =
(
gseq_rfolditm<xs><x0><r0>(xs, r0))
where
{
#impltmp
rfolditm$fopr<x0><r0> = rfolditm$fopr0<x0><r0>
}
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_rfolditm1(xs, r0) =
(
gseq_rfolditm<xs><x0><r0>(xs, r0))
where
{
#impltmp
rfolditm$fopr<x0><r0> = rfolditm$fopr1<x0><r0>
}
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_rfolditm0$f2un
  (xs, r0, fopr) =
(
gseq_rfolditm$f2un<xs><x0><r0>(xs, r0, fopr))
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_rfolditm1$f2un
  (xs, r0, fopr) =
(
gseq_rfolditm$f2un<xs><x0><r0>(xs, r0, fopr))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_ifolditm0(xs, r0) =
(
gseq_ifolditm<xs><x0><r0>(xs, r0))
where
{
#impltmp
ifolditm$fopr<x0><r0> = ifolditm$fopr0<x0><r0>
}
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_ifolditm1(xs, r0) =
(
gseq_ifolditm<xs><x0><r0>(xs, r0))
where
{
#impltmp
ifolditm$fopr<x0><r0> = ifolditm$fopr1<x0><r0>
}
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_ifolditm0$f3un
  (xs, r0, fopr) =
(
gseq_ifolditm$f3un<xs><x0><r0>(xs, r0, fopr))
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_ifolditm1$f3un
  (xs, r0, fopr) =
(
gseq_ifolditm$f3un<xs><x0><r0>(xs, r0, fopr))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_irfolditm0(xs, r0) =
(
gseq_irfolditm<xs><x0><r0>(xs, r0))
where
{
#impltmp
irfolditm$fopr<x0><r0> = irfolditm$fopr0<x0><r0>
}
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_irfolditm1(xs, r0) =
(
gseq_irfolditm<xs><x0><r0>(xs, r0))
where
{
#impltmp
irfolditm$fopr<x0><r0> = irfolditm$fopr1<x0><r0>
}
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_irfolditm0$f3un
  (xs, r0, fopr) =
(
gseq_irfolditm$f3un<xs><x0><r0>(xs, r0, fopr))
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_irfolditm1$f3un
  (xs, r0, fopr) =
(
gseq_irfolditm$f3un<xs><x0><r0>(xs, r0, fopr))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
//
HX-2024-08-10:
Sat 10 Aug 2024 06:58:19 AM EDT
Is it really a good ieda to allow
gasq<t0><vt>?
//
HX-2024-08-10:
Sat 10 Aug 2024 10:37:25 AM EDT
We can certainly use instead:
gasq_vt<t0><vt> for gasq<t0><vt>
It does seem that this desgin of
supporting gasq<t0><vt> makes some
sense, though. So let us keep it!
//
*)
//
#impltmp
< xs:t0 >
< x0:vt >
gasq_forall1 = gasq_forall<xs><x0>
//
#impltmp
< xs:t0 >
< x0:vt >
gasq_rforall1 = gasq_rforall<xs><x0>
//
#impltmp
< xs:t0 >
< x0:vt >
gasq_iforall1 = gasq_iforall<xs><x0>
//
#impltmp
< xs:t0 >
< x0:vt >
gasq_irforall1 = gasq_irforall<xs><x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-15:
Mon Dec 15 05:52:57 PM EST 2025
*)
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_map0_lstrm(xs) =
(
 gseq_map_lstrm<xs><x0><y0>(xs))
where
{
#impltmp
map$fopr<x0><y0> = map$fopr0<x0><y0>
}
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_map1_lstrm(xs) =
(
 gseq_map_lstrm<xs><x0><y0>(xs))
where
{
#impltmp
map$fopr<x0><y0> = map$fopr1<x0><y0>
}
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_map0$f1un_lstrm
  (xs, fopr) =
(
 gseq_map$f1un_lstrm<xs><x0><y0>(xs, fopr))
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_map1$f1un_lstrm
  (xs, fopr) =
(
 gseq_map$f1un_lstrm<xs><x0><y0>(xs, fopr))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-15:
Mon Dec 15 06:39:59 PM EST 2025
*)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_filter0_lstrm(xs) =
(
 gseq_filter_lstrm<xs><x0>(xs))
where
{
(*
HX-2025-12-16:
[test1] should be used here!
*)
#impltmp
filter$test<x0> = filter$test1<x0>
}
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_filter1_lstrm(xs) =
(
 gseq_filter_lstrm<xs><x0>(xs))
where
{
#impltmp
filter$test<x0> = filter$test1<x0>
}
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_filter0$f1un_lstrm
  (xs, test) =
(
 gseq_filter$f1un_lstrm<xs><x0>(xs, test))
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_filter1$f1un_lstrm
  (xs, test) =
(
 gseq_filter$f1un_lstrm<xs><x0>(xs, test))
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_VT_gxyz000_vt.dats] *)
(***********************************************************************)
`,
  "DATS/VT/list000_vt.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon 08 Jul 2024 05:07:13 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX:
This one is also
implemented in [gdbg000.dats]:
*)
#impltmp
{ vt:vt }
g_ptcon
<list_vt(vt)>
( (*void*) ) =
(
pstrn("list_vt"))
//
#impltmp
{ vt:vt }
g_ptype
<list_vt(vt)>
( (*void*) ) =
(
pstrn("list_vt(");
g_ptype<vt>((*0*)); pstrn(")"))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
list_vt_nilq1
  ( xs ) =
(
case+ xs of
|list_vt_nil() => true
|list_vt_cons _ => false)
//
#impltmp
<(*tmp*)>
list_vt_consq1
  ( xs ) =
(
case+ xs of
|list_vt_nil() => false
|list_vt_cons _ => (true))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-14:
Sat 14 Sep 2024 11:40:03 AM EDT
*)
//
#impltmp
< a: vt >
list_vt_make_1val
  ( x1 ) =
list_vt_cons(x1, list_vt_nil)
#impltmp
< a: vt >
list_vt_make_2val
  (x1, x2) =
list_vt_cons(x1,
list_vt_cons(x2, list_vt_nil))
#impltmp
< a: vt >
list_vt_make_3val
  (x1, x2, x3) =
list_vt_cons(x1,
list_vt_cons(x2,
list_vt_cons(x3, list_vt_nil)))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-14:
Sat 14 Sep 2024 11:40:03 AM EDT
*)
//
#impltmp
< a: vt >
list_vt_make_nfun =
nint_map$f1un_llist<a>(*void*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-17:
Wed 17 Jul 2024 10:06:19 PM EDT
*)
//
#impltmp
{ x0:vt }
gseq_sep
<list_vt(x0)><x0>() = ","
#impltmp
{ x0:vt }
gseq_end
<list_vt(x0)><x0>() = ")"
#impltmp
{ x0:vt }
gseq_beg
<list_vt(x0)><x0>() = "list_vt("
//
(* ****** ****** *)
//
#impltmp
{ x0:vt }
g_print0
<list_vt(x0)>(xs) =
(
gseq_print0<list_vt(x0)><x0>(xs)
)(*let*)//end-[g_print0<list_vt>]
//
#impltmp
{ x0:vt }
g_print1
<list_vt(x0)>(xs) =
(
gseq_print1<list_vt(x0)><x0>(xs)
)(*let*)//end-[g_print1<list_vt>]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
#impltmp
< x0:t0 >
list_vt_length0 =
gseq_length0<list_vt(x0)><x0>
*)
//
#impltmp
< x0:vt >
list_vt_length0
  (xs) =
(
  loop(xs, 0(*j0*)))
where
{
fun
loop
{i,j:i0}
(xs:
~list_vt
 (x0, i)
,j0: sint(j)): sint(i+j) =
(
case+ xs of
| ~
list_vt_nil() => j0
| ~
list_vt_cons(x1, xs) =>
(
  g_free<x0>(x1); loop(xs, j0+1)))
}
//
#impltmp
{ x0:vt }
gseq_length0
<list_vt(x0)><x0> = list_vt_length0<x0>
//
(* ****** ****** *)
//
(*
#impltmp
< x0:t0 >
list_vt_length1 =
gseq_length1<list_vt(x0)><x0>
*)
//
#impltmp
< x0:vt >
list_vt_length1
  (xs) =
(
  loop(xs, 0(*j0*)))
where
{
fun
loop
{i,j:i0}
(xs:
!list_vt
 (x0, i)
,j0: sint(j)): sint(i+j) =
(
case+ xs of
| !
list_vt_nil() => j0
| !
list_vt_cons(x1, xs) => loop(xs, j0+1))
}
//
#impltmp
{ x0:vt }
gseq_length1
<list_vt(x0)><x0> = list_vt_length1<x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-07-02:
Wed Jul  2 07:23:22 PM EDT 2025
*)
//
#impltmp
< x0:vt >
list_vt_free
  {n0}(xs) =
( loop(xs) ) where
{
//
fnx
loop
{n0:n0}.<n0>.
( xs:
~ list_vt(x0, n0)): void =
(
case+ xs of
| ~
list_vt_nil() => ()
| ~
list_vt_cons(x0, xs) =>
let
  val () =
  g_free<x0>(x0) in loop(xs) end)
//
}(*where*)//end-of-[list_vt_free(xs)]
//
#impltmp
{ x0:vt }
g_free<
list_vt(x0)> = list_vt_free<x0>(*void*)
#impltmp
{ x0:vt }
gseq_free<
list_vt(x0)><x0> = list_vt_free<x0>(*void*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-27:
Sat 27 Jul 2024 05:56:34 PM EDT
*)
//
#impltmp
< x0:vt >
list_vt_copy
  ( xs ) =
let
//
fnx
loop
{n0:n0}.<n0>.
( xs:
! list_vt(x0, n0)
, r0:
& (?list_vt(x0))>>list_vt(x0, n0)
) : void =
(
//
case+ xs of
| !
list_vt_nil() =>
(r0 := list_vt_nil())
| !
list_vt_cons(x0, xs) =>
let
val x0 = g_copy<x0>(x0)
val () =
(r0 := list_vt_cons(x0, _))
in//let
  loop(xs, r0.1); $fold(r0) end)
//
in//let
let
var r0:
list_vt(x0) in loop(xs, r0); r0 end
end (*let*) // end of [list_vt_copy]
//
#impltmp
{ x0:vt }
g_copy<
list_vt(x0)> = list_vt_copy<x0>(*void*)
#impltmp
{ x0:vt }
gseq_copy<
list_vt(x0)><x0> = list_vt_copy<x0>(*void*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-27:
Sat 27 Jul 2024 05:56:34 PM EDT
*)
//
(* ****** ****** *)
//
#impltmp
< a: vt >
list_vt_append0 =
list_vt_append00<a>(*void*)
//
(* ****** ****** *)
//
#impltmp
< a: vt >
list_vt_append00
  (xs, ys) =
let
var xs = xs
val () =
  loop(xs, ys) in (xs)
end where // end-of-[let]
{
//
fnx
loop
{m,n:nat} .<m>.
( xs:
& list_vt(a, m  )
  >>
  list_vt(a, m+n)
, ys:
~ list_vt(a, n  )) : void =
(
case+ xs of
| ~
list_vt_nil
 ((*0*)) => (xs := ys)
| @
list_vt_cons
  (_, _) =>
let
  val () = loop(xs.1, ys)
in//let
let
prval () = $fold(xs) in () end
end // end of [list_vt_cons]
) (*case*) // end of [loop(xs, ys)]
//
} (* end of [list_vt_append00(xs,ys)] *)
//
#impltmp
{ x0:vt }
gseq_append00
<list_vt(x0)>
<x0>
<list_vt(x0)> = list_vt_append00<x0>(*void*)
//
(* ****** ****** *)
//
#impltmp
< a: vt >
list_vt_append10
  (xs, ys) =
(
list_vt_append00<a>(xs, ys))
where
{
  val xs = list_vt_copy<a>(xs)
} (* end of [list_vt_append10(xs,ys)] *)
//
#impltmp
{ x0:vt }
gseq_append10
<list_vt(x0)>
<x0>
<list_vt(x0)> = list_vt_append10<x0>(*void*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: vt >
list_vt_rappend0 =
list_vt_rappend00<a>(*void*)
//
(* ****** ****** *)
//
#impltmp
< a: vt >
list_vt_rappend00
  (xs, ys) =
(
  loop(xs, ys)) where
{
//
fnx
loop
{m,n:nat} .<m>.
( xs0
: list_vt(a, m)
, ys0
: list_vt(a, n)
) : list_vt(a, m+n) =
(
case+ xs0 of
| ~
list_vt_nil
( (*void*) ) => ys0
| @
list_vt_cons(_, _) =>
let
  val xs1 = xs0.1
  val ( ) = xs0.1 := ys0
in//let
(
  $fold(xs0); loop(xs1, xs0) )
end // end of [list_vt_cons(...)]
)(*case+*)//end-of-[loop(xs0, ys0)]
//
}(*where*)//end-of-[list_vt_rappend00(...)]
//
(* ****** ****** *)
//
#impltmp
< a: vt >
list_vt_reverse0(xs) =
list_vt_rappend00<a>(xs, list_vt_nil(*void*))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-09-04:
Thu Sep  4 12:19:19 AM EDT 2025
*)
//
#impltmp
< a: vt >
list_vt_mergesort0
  (xs) = let
//
#vwtpdef
xs = list_vt(a)
//
fnx
amain
( xs: xs
, n0: nint): xs =
if
(n0 <= 1)
then xs else
(
let
  var xs: xs
in
  merge(ys, zs, xs); xs
end
) where
{
  val n2 = n0 / 2
  val n1 = n0 - n2
  var ys = xs
  val zs = split(ys, n1)
  val ys = amain(ys, n1)
  val zs = amain(zs, n2)
} (*where*) // end of [amain(xs, n0)]
//
and
split
( ys:
& xs >> xs
, n1: nint): xs =
(
if
(n1 >= 2)
then
split(ys.1, n1-1)
else
let
val zs = ys.1 in//let
(
ys.1 :=
list_vt_nil<a>(); zs)
endlet // end of [else]
) (* if *) // end of [split(ys, n1)]
//
and
merge
( ys: ~xs
, zs: ~xs
, xs: &(?xs) >> xs): void =
(
case+ ys of
| ~
list_vt_nil() =>
( xs := zs )
| @
list_vt_cons(y0, ys1) =>
(
case+ zs of
| ~
list_vt_nil() =>
($fold(ys); xs := ys)
| @
list_vt_cons(z0, zs1) =>
let
//
val
sgn = g_cmp11<a>(y0, z0)
//
in//let
//
if
(sgn <= 0)
then
let
val nd = ys
val ys = ys1
val () = $fold(zs)
in//let
  xs := nd;
  merge(ys, zs, xs.1); $fold(xs)
end // end-of-[then]
else
let
val nd = zs
val zs = zs1
val () = $fold(ys)
in//let
  xs := nd;
  merge(ys, zs, xs.1); $fold(xs)
end // end-of-[else]
//
end // list_vt_cons(...)
) (*case+*) // list_vt_cons(y0,ys1)]
) (*case+*) // end of [merge(ys,zs,xs)]
//
in//let
(
  amain(xs, list_vt_length1<a>(xs)) )
end(*let*)//end-of-[list_vt_mergesort0(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-15:
Mon Dec 15 09:47:13 PM EST 2025
*)
//
#impltmp
< x0:vt >
list_vt_llist$concat0
  (   xz   ) =
list_vt_reverse0
<      x0      >
(
list_vt_folditm0
<xs><r0>(xz, r0)) where
{
//
#vwtpdef xs = list_vt(x0)
#vwtpdef r0 = list_vt(x0)
//
val r0 = (list_vt_nil(): r0)
//
#impltmp
folditm$fopr0
<xs><r0>(r0, xs) =
(
  list_vt_rappend00<x0>(xs, r0))
//
}(*where*)//end-of-[list_vt_llist$concat0(xz)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-15:
Mon Dec 15 04:37:34 PM EST 2025
*)
//
#impltmp
< x0:vt >
list_vt_make_lstrm = strm_vt_listize0<x0>
//endof[impltmp<x0:vt>(list_vt_make_lstrm(xs))]
#impltmp
< x0:vt >
list_vt_make_lstrq = strq_vt_listize0<x0>
//endof[impltmp<x0:vt>(list_vt_make_lstrq(xs))]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-08:
Thu Jan  8 11:32:41 AM EST 2026
*)
//
#impltmp
list_vt_make'len<>() = 10
//
#impltmp
< a:vt >
list_vt_make() =
(
nint_map_llist<a>(ln)
) where
{
//
val ln = list_vt_make'len<>()
//
#impltmp map$fopr<a>(_) = g_make<a>()
//
}(*where*)//end-of-[g_make<list_vt(a)>()]
//
#impltmp
{ a:vt }
g_make<list_vt(a)>(*0*) = list_vt_make<a>(*0*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_VT_list000_vt.dats] *)
(***********************************************************************)
`,
  "DATS/VT/list001_vt.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon 08 Jul 2024 05:07:13 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:vt >
list_vt_forall0
  ( xs ) = 
(
  loop(xs) ) where
{
fun
loop
(xs: list_vt(x0)): bool =
(
case+ xs of
| ~
list_vt_nil
  ((*0*)) => (true)
| ~
list_vt_cons(x1, xs) =>
let
val test =
forall$test0<x0>(x1) in
if test then loop(xs) else false end)
}
//
#impltmp
< x0:vt >
list_vt_forall1
  ( xs ) = 
(
  loop(xs) ) where
{
fun
loop
(xs: list_vt(x0)): bool =
(
case+ xs of
|
list_vt_nil
  ((*0*)) => (true)
|
list_vt_cons(x1, xs) =>
let
val test =
forall$test1<x0>(x1) in
if test then loop(xs) else false end)
}
//
#impltmp
{ x0:vt }
gseq_forall0
<list_vt(x0)><x0> = list_vt_forall0<x0>(*void*)
#impltmp
{ x0:vt }
gseq_forall1
<list_vt(x0)><x0> = list_vt_forall1<x0>(*void*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:vt >
list_vt_rforall0
  ( xs ) = 
(
list_vt_forall0<x0>
(list_vt_reverse0<x0>(xs))) where
{
#impltmp
forall$test0<x0> = rforall$test0<x0>
}
//
#impltmp
< x0:vt >
list_vt_rforall1
  ( xs ) = 
(
list_vt_forall0<x0>
(list_vt_reverse1<x0>(xs))) where
{
#impltmp
forall$test0<x0>(x0) =
(
g_free<x0>(x0); test) where
{
  val test = rforall$test1<x0>(x0) }
}
//
#impltmp
{ x0:vt }
gseq_rforall0
<list_vt(x0)><x0> = list_vt_rforall0<x0>(*void*)
#impltmp
{ x0:vt }
gseq_rforall1
<list_vt(x0)><x0> = list_vt_rforall1<x0>(*void*)
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
list_vt_iforall0 = gseq_iforall0<list_vt(x0)><x0>
#impltmp
< x0:vt >
list_vt_iforall1 = gseq_iforall1<list_vt(x0)><x0>
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
list_vt_irforall0 = gseq_irforall0<list_vt(x0)><x0>
#impltmp
< x0:vt >
list_vt_irforall1 = gseq_irforall1<list_vt(x0)><x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:vt >
list_vt_foritm0
  (xs) = 
(
  loop(xs) ) where
{
fun
loop
(xs: list_vt(x0)): void =
(
case+ xs of
| ~
list_vt_nil
  ((*0*)) => ((*0*))
| ~
list_vt_cons(x1, xs) =>
let
val () =
foritm$work0<x0>(x1) in loop(xs) end)
}
//
#impltmp
< x0:vt >
list_vt_foritm1
  (xs) = 
(
  loop(xs) ) where
{
fun
loop
(xs: !list_vt(x0)): void =
(
case+ xs of
|list_vt_nil
  ((*0*)) => ((*0*))
|
list_vt_cons(x1, xs) =>
let
val () =
foritm$work1<x0>(x1) in loop(xs) end)
}
//
#impltmp
{ x0:vt }
gseq_foritm0
<list_vt(x0)><x0> = list_vt_foritm0<x0>(*void*)
#impltmp
{ x0:vt }
gseq_foritm1
<list_vt(x0)><x0> = list_vt_foritm1<x0>(*void*)
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
list_vt_rforitm0 = gseq_rforitm0<list_vt(x0)><x0>
#impltmp
< x0:vt >
list_vt_rforitm1 = gseq_rforitm1<list_vt(x0)><x0>
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
list_vt_iforitm0 = gseq_iforitm0<list_vt(x0)><x0>
#impltmp
< x0:vt >
list_vt_iforitm1 = gseq_iforitm1<list_vt(x0)><x0>
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
list_vt_irforitm0 = gseq_irforitm0<list_vt(x0)><x0>
#impltmp
< x0:vt >
list_vt_irforitm1 = gseq_irforitm1<list_vt(x0)><x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX: 2024-07-28:
Sun 28 Jul 2024 02:37:26 PM EDT
*)
//
#impltmp
<x0>(*tmp*)
list_vt_strmize0
  (xs) =
let
fun
auxmain(xs) =
$llazy
(
case+ xs of
| ~
list_vt_nil() =>
strmcon_vt_nil()
| ~
list_vt_cons(x0, xs) =>
strmcon_vt_cons(x0, auxmain(xs))
)
in
  auxmain(xs)
end(*let*)//end-of-[list_vt_strmize0(xs)]
//
#impltmp
{ x0:vt }
gseq_strmize0
<list_vt(x0)><x0> = list_vt_strmize0<x0>(*void*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-14:
Sat 14 Sep 2024 03:04:03 PM EDT
*)
//
#impltmp
< x0:vt >
< y0:vt >
list_vt_map0
  ( xs ) = let
//
fnx
loop
{i:nat}.<i>.
( xs
: ~list_vt(x0,i)
, r0
: &(?list_vt(y0)) >> list_vt(y0,i)
) : void =
(
case+ xs of
| ~
list_vt_nil() =>
(r0 := list_vt_nil())
| ~
list_vt_cons(x0, xs) =>
let
val y0 =
map$fopr0<x0><y0>(x0)
val () =
(r0 := list_vt_cons(y0, _))
in
(
  loop(xs, r0.1); $fold(r0))
end
) (* end of [loop] *)
//
in
//
let
  var r0: list_vt(y0)
  val () = loop(xs, r0) in r0 end//let
//
end(*let*)//end-of-[ list_vt_map0(...) ]
//
#impltmp
< x0:vt >
< y0:vt >
list_vt_map0$f1un
  (xs, f0) =
(
  list_vt_map0<x0><y0>(xs)) where
{
#impltmp map$fopr0<x0><y0>(x0) = f0(x0)
}(*where*)//end-of-[list_vt_map0$f1un(...)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<x0><y0>
list_vt_maprev0
  ( xs ) =
(
let
val ys =
list_vt_nil() in loop(xs, ys)
end//let
) where
{
//
fnx
loop
{i,j:nat}.<i>.
( xs
: list_vt(x0, i)
, ys
: list_vt(y0, j))
: list_vt(y0, i+j) =
(
case+ xs of
| ~
list_vt_nil() => ys
| ~
list_vt_cons(x0, xs) =>
let
  val y0 =
  map$fopr0<x0><y0>(x0)
in
  loop(xs, list_vt_cons(y0, ys))
end//let//end-of-[list_vt_cons(...)]
)
//
}(*where*)//end-of-[list_vt_maprev0(...)]
//
#impltmp
< x0:vt >
< y0:vt >
list_vt_maprev0$f1un
  (xs, f0) =
(
  list_vt_maprev0<x0><y0>(xs)) where
{
#impltmp map$fopr0<x0><y0>(x0) = f0(x0)
}(*where*)//end-of-[list_vt_maprev0$f1un(...)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-01-12:
Sun Jan 12 09:23:42 AM EST 2025
*)
//
#impltmp
< x0:vt >
< r0:vt >
list_vt_folditm0 =
gseq_folditm0<list_vt(x0)><x0><r0>
//
#impltmp
< x0:vt >
< r0:vt >
list_vt_rfolditm0 =
gseq_rfolditm0<list_vt(x0)><x0><r0>
//
#impltmp
< x0:vt >
< r0:vt >
list_vt_ifolditm0 =
gseq_ifolditm0<list_vt(x0)><x0><r0>
//
#impltmp
< x0:vt >
< r0:vt >
list_vt_irfolditm0 =
gseq_irfolditm0<list_vt(x0)><x0><r0>
//
(* ****** ****** *)
(* ****** ****** *)
//
//
(*
HX-2025-06-01:
Sun Jun  1 06:49:16 PM EDT 2025
*)
//
#impltmp
< x0:vt >
< y0:vt >
< e1:vt >
list_vt_map$e1nv0 =
gseq_map$e1nv0_llist<list_vt(x0)><x0><y0><e1>(*void*)
#impltmp
< x0:vt >
< y0:vt >
< e1:vt >
list_vt_map$e1nv1 =
gseq_map$e1nv1_llist<list_vt(x0)><x0><y0><e1>(*void*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_VT_list001_vt.dats] *)
(***********************************************************************)
`,
  "DATS/VT/lsrt000_vt.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Thu Dec 25 02:58:33 PM EST 2025
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_VT_lsrt000_vt.dats] *)
(***********************************************************************)
`,
  "DATS/VT/optn000_vt.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Fri 06 Sep 2024 11:49:28 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX:
This one is also
implemented in [gdbg000.dats]:
*)
#impltmp
{ vt:vt }
g_ptcon
<optn_vt(vt)>
( (*void*) ) =
(
pstrn("optn_vt("))
//
#impltmp
{ vt:vt }
g_ptype
<optn_vt(vt)>
( (*void*) ) =
(
pstrn("optn_vt(");
g_ptype<vt>((*0*)); pstrn(")"))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
optn_vt_nil_
  ((*0*)) =
  optn_vt_nil((*0*))
#impltmp
< a: vt >
optn_vt_cons_
  (  x  ) =
(
  optn_vt_cons( x ))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
optn_vt_nilq1
  (xs) =
(
case+ xs of
| // !
optn_vt_nil() => true
| // !
optn_vt_cons _ => false)
#impltmp
{ x0:vt }
gseq_nilq1
<optn_vt(x0)><x0> =
optn_vt_nilq1<>{x0}(*void*)
//
(* ****** ****** *)
//
#impltmp
< a: vt >
optn_vt_nilq0
  (xs) =
(
case+ xs of
| ~
optn_vt_nil() => true
| ~
optn_vt_cons(x0) =>
let
val () =
g_free<a>(x0) in false end
)
#impltmp
{ x0:vt }
gseq_nilq0
<optn_vt(x0)><x0> =
optn_vt_nilq0<x0>(* void *)
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
optn_vt_consq1
  ( xs ) =
(
 not(optn_vt_nilq1<>(xs)))
#impltmp
< a: vt >
optn_vt_consq0
  ( xs ) =
(
 not(optn_vt_nilq0<a>(xs)))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:vt >
optn_vt_head0
  (xs) =
(
case+ xs of
| ~
optn_vt_cons(x0) => (x0))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-06:
Fri 06 Sep 2024 11:49:42 PM EDT
*)
//
#impltmp
{ x0:vt }
gseq_sep
<optn_vt(x0)><x0>() = ","
#impltmp
{ x0:vt }
gseq_end
<optn_vt(x0)><x0>() = ")"
#impltmp
{ x0:vt }
gseq_beg
<optn_vt(x0)><x0>() = "optn_vt("
//
(* ****** ****** *)
//
#impltmp
{ x0:vt }
g_print0
<optn_vt(x0)>(xs) =
(
gseq_print0<optn_vt(x0)><x0>(xs)
)(*let*)//end-[g_print0<optn_vt>]
//
#impltmp
{ x0:vt }
g_print1
<optn_vt(x0)>(xs) =
(
gseq_print1<optn_vt(x0)><x0>(xs)
)(*let*)//end-[g_print1<optn_vt>]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
#impltmp
< a :vt >
optn_vt_length0 =
gseq_length0<optn_vt(x0)><x0>
*)
//
#impltmp
< a: vt >
optn_vt_length0
  (xs) =
(
case+ xs of
| ~
optn_vt_nil() => 0 | ~optn_vt_cons _ => 1)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
#impltmp
< a: vt >
optn_vt_length1 =
gseq_length1<optn_vt(x0)><x0>
*)
//
#impltmp
< a: vt >
optn_vt_length1
  (xs) =
(
case+ xs of
| !
optn_vt_nil() => 0 | !optn_vt_cons _ => 1)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-22:
Mon Dec 22 12:15:42 PM EST 2025
*)
//
#impltmp
< x0:vt >
optn_vt_free
(    xs    ) =
(
case+ xs of
| ~
optn_vt_nil
( (*void*) ) => ()
| ~
optn_vt_cons
(    x1    ) => g_free<x0>(x1))
//
#impltmp
{ x0:vt }
g_free<
optn_vt(x0)> = optn_vt_free<x0>(*void*)
#impltmp
{ x0:vt }
gseq_free<
optn_vt(x0)><x0> = optn_vt_free<x0>(*void*)
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
optn_vt_copy
(    xs    ) =
(
case+ xs of
|optn_vt_nil
( (*void*) ) => optn_vt_nil()
|optn_vt_cons
(    x1    ) =>
(
  optn_vt_cons(g_copy<x0>(x1))))
//
#impltmp
{ x0:vt }
g_copy<
optn_vt(x0)> = optn_vt_copy<x0>(*void*)
#impltmp
{ x0:vt }
gseq_copy<
optn_vt(x0)><x0> = optn_vt_copy<x0>(*void*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_VT_optn000_vt.dats] *)
(***********************************************************************)
`,
  "DATS/VT/optn001_vt.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Fri 06 Sep 2024 11:56:52 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:vt >
optn_vt_forall0
  ( xs ) = 
(
case+ xs of
| ~
optn_vt_nil() => true
| ~
optn_vt_cons(x0) => forall$test0<x0>(x0)
)
//
#impltmp
{ x0:vt }
gseq_forall0
<optn_vt(x0)><x0> = optn_vt_forall0<x0>(*0*)
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
optn_vt_rforall0
  ( xs ) = 
(
case+ xs of
| ~
optn_vt_nil() => true
| ~
optn_vt_cons(x0) => rforall$test0<x0>(x0)
)
//
#impltmp
{ x0:vt }
gseq_rforall0
<optn_vt(x0)><x0> = optn_vt_rforall0<x0>(*0*)
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
optn_vt_iforall0
  ( xs ) = 
(
case+ xs of
| ~
optn_vt_nil() => true
| ~
optn_vt_cons(x0) => iforall$test0<x0>(0, x0)
)
//
#impltmp
{ x0:vt }
gseq_iforall0
<optn_vt(x0)><x0> = optn_vt_iforall0<x0>(*0*)
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
optn_vt_irforall0
  ( xs ) = 
(
case+ xs of
| ~
optn_vt_nil() => true
| ~
optn_vt_cons(x0) => irforall$test0<x0>(0, x0)
)
//
#impltmp
{ x0:vt }
gseq_irforall0
<optn_vt(x0)><x0> = optn_vt_irforall0<x0>(*0*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-05-29:
Thu May 29 08:54:25 AM EDT 2025
*)
//
#impltmp
< x0:vt >
< y0:vt >
optn_vt_map0
(  xs  ) =
(
case+ xs of
| ~
optn_vt_nil() => optn_vt_nil()
| ~
optn_vt_cons(x0) =>
optn_vt_cons(map$fopr0<x0><y0>(x0)))
//
#impltmp
< x0:vt >
< y0:vt >
optn_vt_map1
(  xs  ) =
(
case+ xs of
| // !
optn_vt_nil() => optn_vt_nil()
| // !
optn_vt_cons(x0) =>
optn_vt_cons(map$fopr1<x0><y0>(x0)))
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
< y0:vt >
optn_vt_map0$f1un
( xs, fopr ) =
(
case+ xs of
| ~
optn_vt_nil() => optn_vt_nil()
| ~
optn_vt_cons(x0) => optn_vt_cons(fopr(x0)))
//
#impltmp
< x0:vt >
< y0:vt >
optn_vt_map1$f1un
( xs, fopr ) =
(
case+ xs of
| // !
optn_vt_nil() => optn_vt_nil()
| // !
optn_vt_cons(x0) => optn_vt_cons(fopr(x0)))
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_VT_optn001_vt.dats] *)
(***********************************************************************)
`,
  "DATS/VT/strm000_vt.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon 08 Jul 2024 01:04:34 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX:
This one is also
implemented in [gdbg000.dats]:
*)
#impltmp
{ vt:vt }
g_ptcon
<strm_vt(vt)>
( (*void*) ) =
(
pstrn("strm_vt"))
//
#impltmp
{ vt:vt }
g_ptype
<strm_vt(vt)>
( (*void*) ) =
(
pstrn("strm_vt(");
g_ptype<vt>((*0*)); pstrn(")"))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
strm_vt_nil() =
$llazy(
strmcon_vt_nil(*0*))
//
#impltmp
< a: vt >
strm_vt_sing(x0) =
(
strm_vt_cons
(x0, strm_vt_nil()))
#impltmp
< a: vt >
strmcon_vt_sing(x0) =
(
strmcon_vt_cons
(x0, strm_vt_nil()))
//
#impltmp
< a: vt >
strm_vt_cons(x0, xs) =
$llazy(
strmcon_vt_cons(x0, xs))
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
strq_vt_nil() =
$llazy(
strqcon_vt_nil(*0*))
//
#impltmp
< a: vt >
strq_vt_sing(x0) =
(
strq_vt_cons
(x0, strq_vt_nil()))
#impltmp
< a: vt >
strqcon_vt_sing(x0) =
(
strqcon_vt_cons
(x0, strq_vt_nil()))
//
#impltmp
< a: vt >
strq_vt_cons(x0, xs) =
$llazy(
strqcon_vt_cons(x0, xs))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: vt >
strm_vt_free(xs) = $free(xs)
#impltmp
< a: vt >
strm_vt_eval(xs) = $eval(xs)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ a: vt }
g_free//~xs
<strm_vt(a)> = strm_vt_free<a>
#impltmp
{ a: vt }
g_free//~xs
<strq_vt(a)> = strq_vt_free<a>
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-17:
Wed 17 Jul 2024 10:27:26 PM EDT
*)
//
#impltmp
{ x0:vt }
gseq_sep
<
strm_vt(x0)><x0>() = ","
#impltmp
{ x0:vt }
gseq_end
<
strm_vt(x0)><x0>() = ")"
#impltmp
{ x0:vt }
gseq_beg
<
strm_vt(x0)><x0>() = "strm_vt("
//
(* ****** ****** *)
//
#impltmp
{ x0:vt }
g_print0
<strm_vt(x0)> =
gseq_print0
<strm_vt(x0)><x0>(*strm_vt(x0)*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:vt >
g_make_lstrm
<strm_vt(x0)>(xs) = (xs)//identity
#impltmp
< x0:vt >
g_make_lstrq
<strq_vt(x0)>(xs) = (xs)//identity
//
(* ****** ****** *)
//
#impltmp
{ x0:vt }
g_make_lstrm
<x0><list_vt(x0)> = strm_vt_listize0<x0>
#impltmp
{ x0:vt }
g_make_lstrq
<x0><list_vt(x0)> = strq_vt_listize0<x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:vt >
strm_vt_append0 =
strm_vt_append00<x0>(*xs*)
//
#impltmp
< x0:vt >
strm_vt_append00
  (xs, ys) =
(
  auxmain(xs, ys)) where{
//
fun
auxmain
( xs
: strm_vt(x0)
, ys
: strm_vt(x0)): strm_vt(x0) =
$llazy
(
free(xs);
free(ys);
case+ !xs of
| ~
strmcon_vt_nil() => !ys
| ~
strmcon_vt_cons(x0, xs) =>
strmcon_vt_cons(x0, auxmain(xs, ys))
)(*case+*)//(*llazy*)//end-of(auxmain)
//
}(*where*)//end-of(strm_vt_append00(xs,ys))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-13:
Fri 13 Sep 2024 02:56:33 PM EDT
*)
//
#impltmp
< x0:vt >
strm_vt_head0
  ( xs ) =
( case- !xs of
| ~
strmcon_vt_cons
(   x1, xs   ) =>
let val () = $free(xs) in x1 end)
//
#impltmp
< x0:vt >
strm_vt_tail0
  ( xs ) =
( case- !xs of
| ~
strmcon_vt_cons
(   x1, xs   ) =>
let
val () = g_free<x0>(x1) in xs end)
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
strm_vt_head$opt0
  ( xs ) =
(
case+ !xs of
| ~
strmcon_vt_nil
(  (*void*)  ) =>
(
  optn_vt_nil(*0*))
| ~
strmcon_vt_cons
(   x1, xs   ) =>
let
val () =
$free(xs) in optn_vt_cons(x1) end
)
//
#impltmp
< x0:vt >
strm_vt_tail$opt0
  ( xs ) =
(
case+ !xs of
| ~
strmcon_vt_nil
(  (*void*)  ) =>
(
  optn_vt_nil(*0*))
| ~
strmcon_vt_cons
(   x1, xs   ) =>
let
val () =
g_free<x0>(x1) in optn_vt_cons(xs) end
)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-05:
Thu 05 Sep 2024 07:59:10 PM EDT
HX-2025-12-13
concat0 -> lstrm$concat0
Sat Dec 13 11:42:48 PM EST 2025
*)
#impltmp
< x0:vt >
strm_vt_lstrm$concat0
  ( xss ) =
(
  auxmain(xss)) where
{
fun auxmain(xss) = $llazy
(
case+ !xss of
| ~
strmcon_vt_nil() =>
strmcon_vt_nil()
| ~
strmcon_vt_cons(xs1, xss) => !
(
 strm_vt_append00<x0>(xs1, auxmain(xss)))
)
}(*where*)//end-of-[strm_vt_lstrm$concat0(xss)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-20:
Sat Dec 20 11:57:32 AM EST 2025
*)
//
#impltmp
< x0:vt >
strm_vt_length0
  (  xs  ) =
(
  loop(xs, 0)) where
{
fun
loop
( xs:
~ strm_vt(x0), ln: nint): nint =
(
case+ !xs of
| ~
strmcon_vt_nil
(  (*void*)  ) => ( ln )
| ~
strmcon_vt_cons
(   x1, xs   ) =>
let
val
( ) = g_free<x0>(x1) in loop(xs, ln+1)
end//let//end-of-[strmcon_vt_cons(x1,xs)]
)
}(*where*)//end-of-[strm_vt_length0( xs )]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-21:
Sun Dec 21 07:20:03 PM EST 2025
*)
//
(* ****** ****** *)
//
#impltmp
<>(*tmp*)
strm_vt_end() = ")"
#impltmp
<>(*tmp*)
strm_vt_sep() = ","
#impltmp
<>(*tmp*)
strm_vt_rst() = "..."
//
#impltmp
<>(*tmp*)
strm_vt_beg() = "$strm_vt("
//
(* ****** ****** *)
//
#impltmp
<>(*tmp*)
strm_vt_print$len() = (10)
#impltmp
<>(*tmp*)
strm_vt_print'len() = (10)
//
(* ****** ****** *)
//
#impltmp
<x0>(*tmp*)
strm_vt_print0(xs) =
let
val len = 
strm_vt_print$len<>()
in//let
if
(len < 0)
then strm_vt_all$print0<x0>(xs)
else strm_vt_len$print0<x0>(xs, len)
end(*let*)//end-of-[strm_vt_print0(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<x0>(*tmp*)
strm_vt_all$print0
  (xs) =
(
loop
(xs, 0(*i0*)) where
{
val () =
pstrn(strm_vt_beg<>())
}
) where
{
#vwtpdef
xs = strm_vt(x0)
fnx
loop
( xs: xs
, i0: nint): void =
(
case+ !xs of
| ~
strmcon_vt_nil
(  (*void*)  ) =>
(
pstrn(strm_vt_end<>())
)
| ~
strmcon_vt_cons
(   x0, xs   ) =>
let
//
val () =
if
(i0 > 0)
then
pstrn(strm_vt_sep<>())
//
in
(
  loop(xs, i0+1)) where
{
  val () = g_print0<x0>(x0)
}
end // end of [strmcon_vt_cons]
)
}(*where*)//end-of-(strm_vt_all$print0(xs))
//
(* ****** ****** *)
//
#impltmp
<x0>(*tmp*)
strm_vt_len$print0
  (xs, n0) =
(
loop
(xs, 0(*i0*)) where
{
val () =
pstrn(strm_vt_beg<>())
}
) where
{
//
#vwtpdef
xs = strm_vt(x0)
//
fnx
loop
( xs: xs
, i0: nint): void =
(
case+ !xs of
| ~
strmcon_vt_nil
(  (*void*)  ) =>
pstrn(strm_vt_end<>())
| ~
strmcon_vt_cons
(   x0, xs   ) =>
if
(i0 >= n0)
then
let
//
val () =
(
g_free<x0>(x0))
val () =
(
strm_vt_free<x0>(xs))
//
val () =
if
(i0 > 0)
then
pstrn(strm_vt_sep<>())
//
val () =
pstrn(strm_vt_rst<>())
//
in
(
pstrn(strm_vt_end<>()))
end // end of [if-then]
else
let
//
val () =
if
(i0 > 0)
then
pstrn(strm_vt_sep<>())
//
in//let
(
  loop(xs, i0+1)) where
{
  val () = g_print0<x0>(x0)
}
end // end of [if-else]
)(*case+*)//end-of-(loop(xs,i0))
}(*where*)//end-of-(strm_vt_len$print0(xs,ln))
//
(* ****** ****** *)
//
#impltmp
{ x0:vt }
g_print0<strm_vt(x0)> = strm_vt_print0<x0>(*xs*)
#impltmp
{ x0:vt }
gseq_print0<strm_vt(x0)><x0> = strm_vt_print0<x0>(*xs*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-26:
Fri Dec 26 05:13:01 PM EST 2025
*)
//
#impltmp
< x0:vt >
strm_vt_ndrop
  (xs, n0) =
(
auxloop(xs, n0)) where
{
//
#vwtpdef xs = strm_vt(x0)
//
fun
auxloop(xs: xs, n0: ni): xs =
(
if
(n0 <= 0)
then xs else
(
$llazy
(
case+ !xs of
| ~
strmcon_vt_nil
(  (*void*)  ) =>
(
  strmcon_vt_nil())
| ~
strmcon_vt_cons
(   x1 , xs   ) =>
(
  free(x1); !(auxloop(xs, n0-1)))))
)(*endif*)//end-of-[auxloop(xs, n0)]
//
}(*where*)//end-of-[strm_vt_ndrop(xs,n0)]
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
strm_vt_ntake
  (xs, n0) =
(
  auxmain(xs, n0)) where
{
//
#vwtpdef xs = strm_vt(x0)
//
fun
auxmain
(xs: xs, n0: ni): xs = $llazy
(
if
(n0 <= 0)
then
(
free(xs);
strmcon_vt_nil()) else
(
case+ !xs of
| ~
strmcon_vt_nil
(  (*void*)  ) => strmcon_vt_nil()
| ~
strmcon_vt_cons
(   x1, xs   ) =>
strmcon_vt_cons(x1, auxmain(xs, n0-1))))
//
}(*where*)//end-of-[strm_vt_ntake(xs, n0)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-08:
Thu Jan  8 12:13:02 PM EST 2026
*)
//
#impltmp
strm_vt_make'len<>() = 10
//
#impltmp
< a:vt >
strm_vt_make() =
(
nint_map_lstrm<a>(ln)
) where
{
//
val ln = strm_vt_make'len<>()
//
#impltmp map$fopr<a>(_) = g_make<a>()
//
}(*where*)//end-of-[g_make<strm_vt(a)>()]
//
#impltmp
{ a:t0 }
g_make<strm_vt(a)>(*0*) = strm_vt_make<a>(*0*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_VT_strm000_vt.dats] *)
(***********************************************************************)
`,
  "DATS/VT/strm001_vt.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon 08 Jul 2024 01:04:34 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
#impltmp
< x0:vt >
strm_vt_forall0 =
gseq_forall0<strm_vt(x0)><x0>
#impltmp
< x0:vt >
strm_vt_forall0$f1un =
gseq_forall0$f1un<strm_vt(x0)><x0>
//
#impltmp
< x0:vt >
strm_vt_iforall0 =
gseq_iforall0<strm_vt(x0)><x0>
#impltmp
< x0:vt >
strm_vt_iforall0$f2un =
gseq_iforall0$f2un<strm_vt(x0)><x0>
*)
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
strm_vt_foritm0 =
gseq_foritm0<strm_vt(x0)><x0>
#impltmp
< x0:vt >
strm_vt_foritm0$f1un =
gseq_foritm0$f1un<strm_vt(x0)><x0>
//
#impltmp
< x0:vt >
strm_vt_iforitm0 =
gseq_iforitm0<strm_vt(x0)><x0>
#impltmp
< x0:vt >
strm_vt_iforitm0$f2un =
gseq_iforitm0$f2un<strm_vt(x0)><x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-14:
Consuming a strm_vt should
go through [strm_vt_forall0].
If it is implemented as a loop,
we can avoid stack overflow by
turning tail-recursion into a lazy
strm of states. This is referred to
as manual tail-recursion optimization.
Wed Jan 14 08:15:06 AM EST 2026
*)
#impltmp
< x0:vt >
strm_vt_forall0
  ( xs ) =
(
  auxloop(xs)) where
{
fun
auxloop
( xs
: strm_vt(x0)): bool =
(
case+ !xs of
| ~
strmcon_vt_nil() => true
| ~
strmcon_vt_cons(x1, xs) =>
(
if
forall$test0
< x0 >( x1 )
then auxloop(xs)
else (free(xs); false)))//end-of-[if]
}(*where*)//end-of-[strm_vt_forall0(xs)]
//
#impltmp
{ x0:vt }
gseq_forall0
<strm_vt(x0)><x0> = strm_vt_forall0<x0>
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
strm_vt_forall0$f1un
  (xs, test) =
(
strm_vt_forall0
<  x0  >(  xs  )) where
{
#impltmp
forall$test0<x0> = test(*x0*)
}(*where*)//end-of-[strm_vt_forall0$f1un]
//
#impltmp
{ x0:vt }
gseq_forall0$f1un
<strm_vt(x0)><x0> = strm_vt_forall0$f1un<x0>
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
strm_vt_iforall0
  ( xs ) =
(
auxloop(0, xs)) where
{
fun
auxloop
( i0: nint
, xs: strm_vt(x0)): bool =
(
case+ !xs of
| ~
strmcon_vt_nil
  ( (*void*) ) => ( true )
| ~
strmcon_vt_cons
  (  x1, xs  ) =>
(
if
iforall$test0
<x0>( i0, x1 )
then auxloop(i0+1, xs)
else ( free(xs); false ) )//end(if)
)(*case+*)//end-of-[auxloop(i0, xs)]
}(*where*)//end-of-[strm_vt_iforall0(xs)]
//
#impltmp
{ x0:vt }
gseq_iforall0
<strm_vt(x0)><x0> = strm_vt_iforall0<x0>
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
strm_vt_iforall0$f2un
  (xs, test) =
(
strm_vt_iforall0<x0>(xs))
where
{
#impltmp
iforall$test0<x0> = test(*ni,x0*)
}
//
#impltmp
{ x0:vt }
gseq_iforall0$f2un
<strm_vt(x0)><x0> = strm_vt_iforall0$f2un<x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
(*
HX-2024-07-10:
Making use of the most general one
(unless you are sure of a specific one)
*)
#impltmp
< x0:vt >
< y0:vt >
strm_vt_map0 =
gseq_map0_ares<strm_vt(x0)><x0><strm_vt(y0)>
*)
//
#impltmp
< x0:vt >
< y0:vt >
strm_vt_map0
  ( xs ) =
(
  auxmain(xs)) where
{
fun
auxmain
( xs
: strm_vt(x0)
) : strm_vt(y0) = $llazy
(
case+ !xs of
| ~
strmcon_vt_nil() =>
strmcon_vt_nil(*void*)
| ~
strmcon_vt_cons(x1, xs) =>
strmcon_vt_cons
(map$fopr0<x0><y0>(x1), auxmain(xs))
)
}(*where*)//end-of-[strm_vt_map0(xs)]
//
#impltmp
{ x0:vt }
{ y0:vt }
strm_vt_map0$f1un
  (xs, fopr) =
(
strm_vt_map0<x0><y0>(xs))
where
{
#impltmp
map$fopr0<x0><y0>(*x0*) = fopr(*x0*)
}(*where*)//end-of-[strm_vt_map0$f1un(xs)]
//
(*
HX-2024-07-10:
Implementing the most specific one.
HX-2024-07-13:
This one is already added as the default!
There is not harm to keep it here as a reference.
*)
#impltmp
{ x0:vt }
{ y0:vt }
gseq_map0_lstrm
<strm_vt(x0)><x0><y0> = strm_vt_map0<x0><y0>(*void*)
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
< y0:vt >
strm_vt_imap0
  ( xs ) =
(
auxmain(0, xs)) where
{
fun
auxmain
( i0
: nint
, xs
: strm_vt(x0)
) : strm_vt(y0) = $llazy
(
case+ !xs of
| ~
strmcon_vt_nil() =>
strmcon_vt_nil(*void*)
| ~
strmcon_vt_cons(x1, xs) =>
let
val y1 =
imap$fopr0<x0><y0>(i0, x1)
in//let
strmcon_vt_cons(y1,auxmain(i0+1,xs))
end//let
)
}(*where*)//end-of-[strm_vt_imap0(xs)]
//
#impltmp
{ x0:vt }
{ y0:vt }
strm_vt_imap0$f1un
  (xs, fopr) =
(
strm_vt_imap0<x0><y0>(xs))
where
{
#impltmp
imap$fopr0<x0><y0>(*x0*) = fopr(*x0*)
}(*where*)//end-of-[strm_vt_imap0$f1un(xs)]
//
#impltmp
{ x0:vt }
{ y0:vt }
gseq_imap0_lstrm
<strm_vt(x0)><x0><y0> = strm_vt_imap0<x0><y0>(*void*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:vt >
strm_vt_filter0
  ( xs ) =
$llazy(
auxloop
(
strm_vt_eval(xs)))
where
{
(*
HX-2024-07-13:
[auxloop] needs to be tail-recursive!
*)
fnx
auxloop
( cs
: strmcon_vt(x0)
) : strmcon_vt(x0) =
(
case+ cs of
| ~
strmcon_vt_nil() =>
strmcon_vt_nil(*void*)
| ~
strmcon_vt_cons(x1, xs) =>
let
val
test =
filter$test1<x0>(x1)
in//let
if
test
then
strmcon_vt_cons
(x1, $llazy(auxloop(!xs)))
else
(g_free<x0>(x1); auxloop(!xs)) end
)
}(*where*)//end-of-[strm_vt_filter0(xs)]
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
strm_vt_filter0$f1un
  (xs, test) =
(
strm_vt_filter0<x0>(xs))
where
{
#impltmp
filter$test1<x0>(*x0*) = test(*x0*)
}
//
(*
HX-2024-07-10:
Implementing the most specific one.
HX-2024-07-13:
This one is already added as the default!
It is not harm to keep it here as a reference.
*)
#impltmp
{ x0:vt }
gseq_filter0_lstrm
<strm_vt(x0)><x0> = strm_vt_filter0<x0>(*void*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:vt >
strm_vt_ifilter0
  ( xs ) =
$llazy(
auxloop
(0, strm_vt_eval(xs))
) where
{
(*
HX-2024-07-13:
[auxloop] nees to be tail-recursive!
*)
fnx
auxloop
( i0
: nint
, xs
: strmcon_vt(x0)
) : strmcon_vt(x0) =
(
case+ xs of
| ~
strmcon_vt_nil() =>
strmcon_vt_nil(*void*)
| ~
strmcon_vt_cons(x1, xs) =>
let
val
test =
ifilter$test1<x0>(i0, x1)
in//let
if
test
then
strmcon_vt_cons
(x1, $llazy(auxloop(i0+1, !xs)))
else
(
g_free<x0>(x1); auxloop(i0+1, !xs)) end
)
}(*where*)//end-of-[strm_vt_ifilter0(xs)]
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
strm_vt_ifilter0$f2un
  (xs, test) =
(
strm_vt_ifilter0<x0>(xs))
where
{
#impltmp
ifilter$test1<x0>(i0, x0) = test(i0, x0)
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:vt >
strm_vt_listize0
  ( xs ) =
list_vt_reverse0<x0>
(strm_vt_rlistize0<x0>(xs))
//
#impltmp
< x0:vt >
strm_vt_rlistize0
  ( xs ) =
(
  loop(xs, rs)) where
{
//
val rs = list_vt_nil()
//
fun loop
( xs: strm_vt(x0)
, rs: list_vt(x0)): list_vt(x0) =
(
case+ !xs of
| ~
strmcon_vt_nil
  ((*void*)) => (rs)
| ~
strmcon_vt_cons
  ( x1, xs ) =>
(
  loop(xs, list_vt_cons(x1, rs))))
}(*where*)//end-of-[strm_vt_rlistize0(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-01-12:
Sun Jan 12 09:30:32 AM EST 2025
*)
//
#impltmp
< x0:vt >
< r0:vt >
strm_vt_folditm0 =
gseq_folditm0<strm_vt(x0)><x0><r0>
#impltmp
< x0:vt >
< r0:vt >
strm_vt_ifolditm0 =
gseq_ifolditm0<strm_vt(x0)><x0><r0>
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
< r0:vt >
strm_vt_folditm0$f2un =
gseq_folditm0$f2un<strm_vt(x0)><x0><r0>
#impltmp
< x0:vt >
< r0:vt >
strm_vt_ifolditm0$f3un =
gseq_ifolditm0$f3un<strm_vt(x0)><x0><r0>
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-05-31:
Sat May 31 09:00:51 PM EDT 2025
HX-2026-01-03:
This implementation is UNSAFE
as [e1] appears in two places!
Please use [strm_vt_map$e0nv0]
if possible.
Here we get to see the issue of
resource tunneling:
How can we make sure that linear
values captured inside a closure
can be released type-safely after
the closure is consumed?
Sat Jan  3 11:09:01 PM EST 2026
*)
//
#impltmp
< x0:vt >
< y0:vt >
< e1:vt >
strm_vt_map$e1nv0
  ( xs, e1 ) =
(
strm_vt_map0
<x0><y0>(xs)) where
{
#impltmp
map$fopr0<x0><y0>(x0) =
(
  map$e1nv$fopr0<x0><y0><e1>(x0, e1))
}(*where*)//end-of-[strm_vt_map$e1nv0(xs,e1)]
//
#impltmp
< x0:vt >
< y0:vt >
< e1:vt >
strq_vt_map$e1nv0
  ( xs, e1 ) =
(
strq_vt_map0
<x0><y0>(xs)) where
{
#impltmp
map$fopr0<x0><y0>(x0) =
(
  map$e1nv$fopr0<x0><y0><e1>(x0, e1))
}(*where*)//end-of-[strq_vt_map$e1nv0(xs,e1)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-26:
Fri Dec 26 01:13:30 PM EST 2025
*)
//
#impltmp
< x0:vt >
strm_vt_ord$exists0
  (    xs    ) =
(
  auxloop(xs)) where
{
//
fnx
auxloop
(xs: strm_vt(x0)): bool =
(
case+ !xs of
| ~
strmcon_vt_nil
  ((*void*)) => false
| ~
strmcon_vt_cons
  ( x1, xs ) =>
let
//
val sgn =
(
exists$tcmp0<x0>(x1))
//
in//let
//
if (sgn = 0)
then (free(xs); true) else
(
if (sgn < 1)
then auxloop(xs) else (free(xs); false))
//
end//let
//
)(*case+*)//end-of-[auxloop(xs:strm_vt(x0))]
}(*where*)//end-of-[strm_vt_ord$exists0<x0>(xs)]
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
strm_vt_ord$iexists0
  (    xs    ) =
(
auxloop(0, xs)) where
{
//
fnx
auxloop
(i0: nint
,xs: strm_vt(x0)): bool =
(
case+ !xs of
| ~
strmcon_vt_nil
  ((*void*)) => false
| ~
strmcon_vt_cons
  ( x1, xs ) =>
let
//
val sgn =
(
exists$tcmp0<x0>(x1))
//
in//let
//
if (sgn = 0)
then (free(xs); true) else
(
if (sgn < 1) then
auxloop(i0+1, xs) else (free(xs); false))
//
end//let
//
)(*case+*)//end-of-[auxloop(i0,xs:strm_vt(x0))]
}(*where*)//end-of-[strm_vt_ord$iexists0<x0>(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-03:
Sat Jan  3 02:27:10 PM EST 2026
*)
//
#impltmp
< x0:vt >
< y0:vt >
< e1:vt >
strm_vt_map$e0nv0
  ( xs, e1 ) =
(
auxmain(xs, e1)) where
{
fun
auxmain
( xs
: strm_vt(x0)
, e1: ( ~e1 )
) : strm_vt(y0) = $llazy
(
//
case+ !xs of
| ~
strmcon_vt_nil() =>
(
g_free<e1>(e1);
strmcon_vt_nil(*void*))
| ~
strmcon_vt_cons(x1, xs) =>
let
val y1 =
map$e1nv$fopr0<x0><y0>(x1, e1)
in//let
strmcon_vt_cons(y1, auxmain(xs, e1))
end//let
)
}(*where*)//end-of-[strm_vt_map$e0nv0(xs,e1)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_VT_strm001_vt.dats] *)
(***********************************************************************)
`,
  "DATS/VT/strm002_vt.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Tue 23 Jul 2024 06:07:30 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
#impltmp
< x0:vt >
< y0:vt >
strm_vt_z2forall0 =
gseq_z2forall0
<strm_vt(x0)><x0><strm_vt(y0)><y0>
*)
//
(*
#impltmp
< x0:vt >
< y0:vt >
strm_vt_z2foritm0 =
gseq_z2foritm0
<strm_vt(x0)><x0><strm_vt(y0)><y0>
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:vt >
< y0:vt >
strm_vt_z2forall0
  ( xs, ys ) =
(
  auxmain(xs, ys)) where
{
fun
auxmain
( xs
: strm_vt(x0)
, ys
: strm_vt(y0)): bool =
(
case+ !xs of
| ~
strmcon_vt_nil() =>
(free(ys); true)
| ~
strmcon_vt_cons(x1, xs) =>
(
case+ !ys of
| ~
strmcon_vt_nil() =>
(free(x1);free(xs);true)
| ~
strmcon_vt_cons(y1, ys) =>
(
if
z2forall$test0
<x0><y0>(x1, y1)
then auxmain(xs, ys)
else (free(xs);free(ys);false))))
}(*where*)//end-of-[strm_vt_z2forall0(xs,ys)]
//
#impltmp
{ x0:vt
, y0:vt }
gseq_z2forall0
<strm_vt(x0)><x0>
<strm_vt(y0)><y0> = strm_vt_z2forall0<x0><y0>
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
< y0:vt >
strm_vt_z2iforall0
  ( xs, ys ) =
(
auxmain(0, xs, ys)) where
{
fun
auxmain
( i0: nint
, xs
: strm_vt(x0)
, ys
: strm_vt(y0)): bool =
(
case+ !xs of
| ~
strmcon_vt_nil() =>
(free(ys); true)
| ~
strmcon_vt_cons(x1, xs) =>
(
case+ !ys of
| ~
strmcon_vt_nil() =>
(free(x1);free(xs);true)
| ~
strmcon_vt_cons(y1, ys) =>
(
if
z2iforall$test0
<x0><y0>(i0, x1, y1)
then auxmain(i0+1, xs, ys)
else (free(xs);free(ys);false))))
}(*where*)//end-of-[strm_vt_z2iforall0(xs,ys)]
//
#impltmp
{ x0:vt
, y0:vt }
gseq_z2iforall0
<strm_vt(x0)><x0>
<strm_vt(y0)><y0> = strm_vt_z2iforall0<x0><y0>
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-10:
Sat 10 Aug 2024 07:14:04 PM EDT
*)
#impltmp
< x0:vt >
< y0:vt >
strm_vt_z2forcmp0
  ( xs, ys ) =
(
  auxmain(xs, ys)) where
{
fun
auxmain
( xs
: strm_vt(x0)
, ys
: strm_vt(y0)): sint =
(
case+ !xs of
| ~
strmcon_vt_nil() =>
(
case+ !ys of
| ~
strmcon_vt_nil
(   (*nil*)  ) => 0
| ~
strmcon_vt_cons
(   y1 , ys   ) =>
(free(y1);free(ys);1)
)
| ~
strmcon_vt_cons
(   x1 , xs   ) =>
(
case+ !ys of
| ~
strmcon_vt_nil() =>
(free(x1);free(xs);-1)
| ~
strmcon_vt_cons
(   y1 , ys   ) =>
(
let
val sgn =
z2forcmp$test0
<x0><y0>(x1, y1) in
if sgn = 0
then auxmain(xs, ys)
else (free(xs);free(ys);sgn) end)))
}(*where*)//end-of-[strm_vt_z2forcmp0(xs,ys)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:vt >
< y0:vt >
strm_vt_z2foritm0 =
gseq_z2foritm0<strm_vt(x0)><x0><strm_vt(y0)><y0>
//
#impltmp
< x0:vt >
< y0:vt >
strm_vt_z2iforitm0 =
gseq_z2iforitm0<strm_vt(x0)><x0><strm_vt(y0)><y0>
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
#impltmp
< x0:vt >
< y0:vt >
< z0:vt >
strm_vt_z2map0 =
gseq_z2map0_lstrm
<strm_vt(x0),strm_vt(y0)><x0><y0><z0>(*void*)
*)
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
< y0:vt >
< z0:vt >
strm_vt_z2map0
  (xs, ys) =
(
  auxmain(xs, ys)) where
{
fun
auxmain
( xs
: strm_vt(x0)
, ys
: strm_vt(y0)
) : strm_vt(z0) = $llazy
(
case+ !xs of
| ~
strmcon_vt_nil() =>
(
free(ys);
strmcon_vt_nil())
| ~
strmcon_vt_cons(x1, xs) =>
(
case+ !ys of
| ~
strmcon_vt_nil() =>
(
strmcon_vt_nil())
| ~
strmcon_vt_cons(y1, ys) =>
let
val z0 =
z2map$fopr0<x0><y0><z0>(x1, y1) in
strmcon_vt_cons(z0, auxmain(xs, ys)) end
)
)(*llazy*)
}(*where*)//end-of-[strm_vt_z2map0(xs,ys)]
//
#impltmp
{ x0:vt
, y0:vt
, z0:vt }
gseq_z2map0_lstrm
<strm_vt(x0)><x0>
<strm_vt(y0)><y0><z0> = strm_vt_z2map0<x0><y0><z0>
//
(* ****** ****** *)
//
(*
#impltmp
< x0:vt >
< y0:vt >
< z0:vt >
strm_vt_z2imap0 =
gseq_z2imap0_lstrm
<strm_vt(x0),strm_vt(y0)><x0><y0><z0>(*void*)
*)
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
< y0:vt >
< z0:vt >
strm_vt_z2imap0
  (xs, ys) =
(
auxmain(0, xs, ys)) where
{
fun
auxmain
( i0: nint
, xs
: strm_vt(x0)
, ys
: strm_vt(y0)
) : strm_vt(z0) = $llazy
(
case+ !xs of
| ~
strmcon_vt_nil() =>
(
free(ys);
strmcon_vt_nil())
| ~
strmcon_vt_cons(x1, xs) =>
(
case+ !ys of
| ~
strmcon_vt_nil() =>
(
strmcon_vt_nil())
| ~
strmcon_vt_cons(y1, ys) =>
let
val z0 =
z2imap$fopr0
<x0><y0><z0>(i0, x1, y1) in//let
strmcon_vt_cons(z0, auxmain(i0+1,xs,ys))
end//let//end-of-[strmcon_vt_cons( ... )]
)
)(*llazy*)
}(*where*)//end-of-[strm_vt_z2imap0(xs,ys)]
//
#impltmp
{ x0:vt
, y0:vt
, z0:vt }
gseq_z2imap0_lstrm
<strm_vt(x0)><x0>
<strm_vt(y0)><y0><z0> = strm_vt_z2imap0<x0><y0><z0>
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-05:
Mon 05 Aug 2024 07:50:06 PM EDT
*)
//
#impltmp
< x0:t0 >
< y0:t0 >
strm_vt_z2listize0
  (xs, ys) =
list_vt_reverse0<(x0,y0)>
(
strm_vt_z2rlistize0<x0><y0>(xs, ys)
)
//
#impltmp
< x0:t0 >
< y0:t0 >
strm_vt_z2rlistize0
  (xs, ys) =
strm_vt_rlistize0<(x0,y0)>
(
 strm_vt_z2strmize0<x0><y0>(xs, ys))
//
#impltmp
< x0:t0 >
< y0:t0 >
strm_vt_z2strmize0
  (xs, ys) =
(
 strm_vt_z2map0<x0><y0><z0>(xs, ys))
where
{
//
#typedef z0 = (x0, y0)
//
#impltmp
z2map$fopr0<x0><y0><z0>(x0, y0) = @(x0, y0)
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_VT_strm002_vt.dats] *)
(***********************************************************************)
`,
  "DATS/VT/strn000_vt.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Thu 11 Jul 2024 01:17:05 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
strn_vt_gmake
<list(cgtz)> = strn_vt_make_list<>
//
#impltmp
strn_vt_gmake
<list_vt(cgtz)> = strn_vt_make_llist<>
#impltmp
strn_vt_gmake1
<list_vt(cgtz)> = strn_vt_make1_llist<>
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_VT_strn000_vt.dats] *)
(***********************************************************************)
`,
  "DATS/VT/strx000_vt.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Wed May  7 09:33:41 AM EDT 2025
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX:
This one is also
implemented in [gdbg000.dats]:
*)
#impltmp
{ vt:vt }
g_ptcon
<strx_vt(vt)>
( (*void*) ) =
(
pstrn("strx_vt"))
//
#impltmp
{ vt:vt }
g_ptype
<strx_vt(vt)>
( (*void*) ) =
(
pstrn("strx_vt(");
g_ptype<vt>((*0*)); pstrn(")"))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: vt >
strx_vt_cons(x0, xs) =
$llazy
(strxcon_vt_cons(x0, xs))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ x0:vt }
g_free//~xs
<strx_vt(x0)>(xs) = $free(xs)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-17:
Wed 17 Jul 2024 10:27:26 PM EDT
*)
//
#impltmp
{ x0:vt }
gseq_sep
<strx_vt(x0)><x0>() = ","
#impltmp
{ x0:vt }
gseq_end
<strx_vt(x0)><x0>() = ")"
#impltmp
{ x0:vt }
gseq_beg
<strx_vt(x0)><x0>() = "strx_vt("
//
(* ****** ****** *)
//
#impltmp
{ x0:vt }
g_print0
<strx_vt(x0)>(xs) =
(
gseq_print0<strx_vt(x0)><x0>(xs)
)(*let*)//end-[g_print0<strx_vt>]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:vt >
strx_vt_free(xs) = $free(xs)
#impltmp
< x0:vt >
strx_vt_eval(xs) = $eval(xs)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:vt >
strx_vt_head0
  ( xs ) =
( case+ !xs of
| ~
strxcon_vt_cons(x1, xs) =>
let val () = $free(xs) in x1 end)
//
#impltmp
< x0:vt >
strx_vt_tail0
  ( xs ) =
( case+ !xs of
| ~
strxcon_vt_cons(x1, xs) =>
let val () = g_free<x0>(x1) in xs end)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-13:
Tue Jan 13 02:45:54 AM EST 2026
*)
//
(* ****** ****** *)
//
#impltmp
<>(*tmp*)
strx_vt_end() = ")"
#impltmp
<>(*tmp*)
strx_vt_sep() = ","
#impltmp
<>(*tmp*)
strx_vt_rst() = "..."
//
#impltmp
<>(*tmp*)
strx_vt_beg() = "$strx_vt("
//
(* ****** ****** *)
//
(*
#impltmp
<>(*tmp*)
strx_vt_print$len() = (10)
*)
#impltmp
<>(*tmp*)
strx_vt_print'len() = (10)
//
(* ****** ****** *)
//
#impltmp
<x0>(*tmp*)
strx_vt_print0(xs) =
let
val len = 
strx_vt_print'len<>()
in//let
if
(len < 0)
then strx_vt_all$print0<x0>(xs)
else strx_vt_len$print0<x0>(xs, len)
end(*let*)//end-of-[strx_vt_print0(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<x0>(*tmp*)
strx_vt_all$print0
  (xs) =
(
loop
(xs, 0(*i0*)) where
{
val () =
pstrn(strx_vt_beg<>())
}
) where
{
#vwtpdef
xs = strx_vt(x0)
fnx
loop
( xs: xs
, i0: nint): void =
(
case+ !xs of
| ~
strxcon_vt_cons
(   x0 , xs   ) =>
let
//
val () =
if // if
(i0 > 0)
then//then
pstrn(strx_vt_sep<>())
//
in//let
(
  loop(xs, i0+1)) where
{
  val () = g_print0<x0>(x0)
}
end // end of [strxcon_vt_cons]
)
}(*where*)//end-of-(strx_vt_all$print0(xs))
//
(* ****** ****** *)
//
#impltmp
<x0>(*tmp*)
strx_vt_len$print0
  (xs, n0) =
(
loop
(xs, 0(*i0*)) where
{
val () =
pstrn(strx_vt_beg<>())
}
) where
{
//
#vwtpdef
xs = strx_vt(x0)
//
fnx
loop
( xs: xs
, i0: nint): void =
(
case+ !xs of
| ~
strxcon_vt_cons
(   x0 , xs   ) =>
if
(i0 >= n0)
then
let
//
val () =
g_free<x0>(x0)
val () =
strx_vt_free<x0>(xs)
//
val () =
if
(i0 > 0)
then
pstrn(strx_vt_sep<>())
//
val () =
pstrn(strx_vt_rst<>())
//
in//let//then
(
pstrn(strx_vt_end<>()))
end // end of [if-then]
else
let
//
val () =
if // if
(i0 > 0)
then//then
pstrn(strx_vt_sep<>())
//
in//let//else
(
  loop(xs, i0+1)) where
{
  val () = g_print0<x0>(x0)
}
end // end of [if-else]
)(*case+*)//end-of-(loop(xs,i0))
}(*where*)//end-of-(strx_vt_len$print0(xs,ln))
//
(* ****** ****** *)
//
#impltmp
{ x0:vt }
g_print0<strx_vt(x0)> = strx_vt_print0<x0>(*xs*)
#impltmp
{ x0:vt }
gseq_print0<strx_vt(x0)><x0> = strx_vt_print0<x0>(*xs*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_VT_strx000_vt.dats] *)
(***********************************************************************)
`,
  "DATS/VT/strx001_vt.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Wed May  7 09:54:52 AM EDT 2025
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:vt >
strx_vt_strmize0
  ( xs ) =
(
  auxmain(xs)) where
{
fun
auxmain
( xs
: strx_vt(x0)
) : strm_vt(x0) = $llazy
(
case+ !xs of
| ~
strxcon_vt_cons(x0, xs) =>
strmcon_vt_cons(x0, auxmain(xs))
)
}(*where*)//end-of-[strx_vt_strmize0]
//
#impltmp
{ x0:vt }
gseq_strmize0
<
strx_vt(x0)><x0> = strx_vt_strmize0<x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:vt >
strx_vt_forall0
  ( xs ) =
(
  auxloop(xs)) where
{
fun
auxloop
( xs
: strx_vt(x0)): bool =
(
case+ !xs of
| ~
strxcon_vt_cons(x1, xs) =>
(
if
forall$test0
< x0 >( x1 )
then auxloop(xs)
else (free(xs); false)))//end-of-[if]
}(*where*)//end-of-[strx_vt_forall0(xs)]
//
#impltmp
{ x0:vt }
gseq_forall0
<strx_vt(x0)><x0> = strx_vt_forall0<x0>
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
strx_vt_forall0$f1un
  (xs, test) =
(
strx_vt_forall0
<  x0  >(  xs  )) where
{
#impltmp
forall$test0<x0> = test(*x0*)
}(*where*)//end-of-[strx_vt_forall0$f1un]
//
#impltmp
{ x0:vt }
gseq_forall0$f1un
<strx_vt(x0)><x0> = strx_vt_forall0$f1un<x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:vt >
strx_vt_iforall0
  ( xs ) =
(
auxloop(0, xs)) where
{
fun
auxloop
( i0: nint
, xs: strx_vt(x0)): bool =
(
case+ !xs of
| ~
strxcon_vt_cons
  (  x1, xs  ) =>
(
if
iforall$test0
<x0>( i0, x1 )
then auxloop(i0+1, xs)
else ( free(xs); false ) )//end(if)
)(*case+*)//end-of-[auxloop(i0, xs)]
}(*where*)//end-of-[strx_vt_iforall0(xs)]
//
#impltmp
{ x0:vt }
gseq_iforall0
<strx_vt(x0)><x0> = strx_vt_iforall0<x0>
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
strx_vt_iforall0$f2un
  (xs, test) =
(
strx_vt_iforall0<x0>(xs))
where
{
#impltmp
iforall$test0<x0> = test(*ni,x0*)
}
//
#impltmp
{ x0:vt }
gseq_iforall0$f2un
<strx_vt(x0)><x0> = strx_vt_iforall0$f2un<x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:vt >
< y0:vt >
strx_vt_map0
  ( xs ) =
(
  auxmain(xs)) where
{
fun
auxmain
( xs
: strx_vt(x0)
) : strx_vt(y0) = $llazy
(
case+ !xs of
| ~
strxcon_vt_cons(x1, xs) =>
strxcon_vt_cons(
map$fopr0<x0><y0>(x1), auxmain(xs))
)
}(*where*)//end-of-[strx_vt_map0(xs)]
//
#impltmp
< x0:vt >
< y0:vt >
strx_vt_map0$f1un
  (xs, fopr) =
(
strx_vt_map0<x0><y0>(xs))
where
{
#impltmp
map$fopr0<x0><y0>(*x0*) = fopr(*x0*)
}(*where*)//end-of-[strx_vt_map0$f1un]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:vt >
< y0:vt >
strx_vt_imap0
  ( xs ) =
(
auxmain(0, xs)) where
{
fun
auxmain
( i0: nint
, xs
: strx_vt(x0)
) : strx_vt(y0) = $llazy
(
case+ !xs of
| ~
strxcon_vt_cons(x1, xs) =>
let
val y1 =
imap$fopr0<x0><y0>(i0, x1)
in//let
strxcon_vt_cons(y1,auxmain(i0+1,xs))
end//let
)
}(*where*)//end-of-[strx_vt_imap0(xs)]
//
#impltmp
< x0:vt >
< y0:vt >
strx_vt_imap0$f1un
  (xs, fopr) =
(
strx_vt_imap0<x0><y0>(xs))
where
{
#impltmp
imap$fopr0<x0><y0> = fopr(* ni,x0 *)
}(*where*)//end-of-[strx_vt_imap0$f2un]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:vt >
strx_vt_filter0
  ( xs ) =
$llazy
(auxloop(!xs)) where
{
(*
HX-2024-07-13:
[auxloop] needs
to be tail-recursive!
*)
fnx
auxloop
( cs
: strxcon_vt(x0)
) : strxcon_vt(x0) =
(
case+ cs of
| ~
strxcon_vt_cons
(   x1 , xs   ) =>
let
val
test =
filter$test1<x0>(x1)
in//let
if
test
then
strxcon_vt_cons
(x1, $llazy(auxloop(!xs)))
else
(g_free<x0>(x1); auxloop(!xs)) end
)
}(*where*)//end-of-[strx_vt_filter0(xs)]
//
#impltmp
< x0:vt >
strx_vt_filter0$f1un
  (xs, test) =
(
strx_vt_filter0<x0>(xs))
where
{
#impltmp
filter$test1<x0>(*x0*) = test(*x0*)
}(*where*)//end-of-[strx_vt_filter0$f1un]
//
#impltmp
{ x0:vt }
gseq_filter0_self
<
strx_vt(x0)><x0> = strx_vt_filter0<x0>(*xs*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:vt >
strx_vt_ifilter0
  ( xs ) =
$llazy
(auxloop(0, !xs)) where
{
(*
HX-2024-07-13:
[auxloop] nees to
be tail-recursive!
*)
fnx
auxloop
( i0: nint
, xs
: strxcon_vt(x0)
) : strxcon_vt(x0) =
(
case+ xs of
| ~
strxcon_vt_cons(x1, xs) =>
let
val
test =
ifilter$test1<x0>(i0, x1)
in//let
if
test
then
strxcon_vt_cons
(x1, $llazy(auxloop(i0+1, !xs)))
else
(
g_free<x0>(x1); auxloop(i0+1, !xs)) end
)
}(*where*)//end-of-[strx_vt_ifilter0(xs)]
//
#impltmp
< x0:vt >
strx_vt_ifilter0$f2un
  (xs, test) =
(
strx_vt_ifilter0<x0>(xs))
where
{
#impltmp
ifilter$test1<x0>(*i0,x0*) = test(*i0,x0*)
}(*where*)//end-of-[strx_vt_ifilter0$f2un()]
//
#impltmp
{ x0:vt }
gseq_ifilter0_self
<
strx_vt(x0)><x0> = strx_vt_ifilter0<x0>(*xs*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-14:
Wed Jan 14 10:27:11 AM EST 2026
*)
//
#impltmp
< x0:vt >
strx_vt_search0
  ( xs ) =
(
strx_vt_head0<x0>(
strx_vt_filter0<x0>(xs)))
where
{
#impltmp
filter$test1<x0> = search$test1<x0>(*x0*)
}(*where*)//end-of-[strx_vt_search0<x0>(xs)]
//
#impltmp
< x0:vt >
strx_vt_search0$f1un
  (xs, test) =
(
strx_vt_search0(xs)) where
{
#impltmp search$test1<x0>(*x0*) = test(*x0*)
}(*where*)//end-of-[strx_vt_search0$f1un<x0>()]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_VT_strx001_vt.dats] *)
(***********************************************************************)
`,
  "DATS/VT/tupl000_vt.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sat 10 Aug 2024 09:31:47 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ a0:vt
, a1:vt }
g_print0
<t0up_vt(a0,a1)>
  ( tup ) =
let
//
val () =
(
  strn_print("@("))
//
val () = g_print0<a0>(tup.0)
val () = pstrn(",")
val () = g_print0<a1>(tup.1)
//
val () = strn_print(")")
//
end // end of [g_print0<t0up2>(tup)]
//
(* ****** ****** *)
//
#impltmp
{ a0:vt
, a1:vt }
g_print1
<t0up_vt(a0,a1)>
  ( tup ) =
let
//
val () =
(
  strn_print("@("))
//
val () = g_print1<a0>(tup.0)
val () = pstrn(",")
val () = g_print1<a1>(tup.1)
//
val () = strn_print(")")
//
end // end of [g_print1<t0up2>(tup)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ a0:vt
, a1:vt
, a2:vt }
g_print0
<t0up_vt(a0,a1,a2)>
  ( tup ) =
let
//
val () =
  strn_print("@(")
//
val () = g_print0<a0>(tup.0)
val () = pstrn(",")
val () = g_print0<a1>(tup.1)
val () = pstrn(",")
val () = g_print0<a2>(tup.2)
//
val () = strn_print(")")
//
end // end of [g_print0<t0up3>(tup)]
//
(* ****** ****** *)
//
#impltmp
{ a0:vt
, a1:vt
, a2:vt }
g_print1
<t0up_vt(a0,a1,a2)>
  ( tup ) =
let
//
val () =
  strn_print("@(")
//
val () = g_print1<a0>(tup.0)
val () = pstrn(",")
val () = g_print1<a1>(tup.1)
val () = pstrn(",")
val () = g_print1<a2>(tup.2)
//
val () = strn_print(")")
//
end // end of [g_print1<t0up3>(tup)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ a0:t0
, a1:t0 }
g_copy<t0up_vt(a0,a1)>(tup) = (tup)
#impltmp
{ a0:t0
, a1:t0 }
g_free<t0up_vt(a0,a1)>(tup) = ((*0*))
//
(* ****** ****** *)
//
#impltmp
{ a0:t0
, a2:t0
, a1:t0 }
g_copy<t0up_vt(a0,a1,a2)>(tup) = (tup)
#impltmp
{ a0:t0
, a1:t0
, a2:t0 }
g_free<t0up_vt(a0,a1,a2)>(tup) = ((*0*))
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_VT_tupl000_vt.dats] *)
(***********************************************************************)
`,
  "DATS/VT/tupl001_vt.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sat 10 Aug 2024 09:38:23 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#vwtpdef
atup2(x0:vt) = @(x0,x0)
#vwtpdef
atup3(x0:vt) = @(x0,x0,x0)
#vwtpdef
atup4(x0:vt) = @(x0,x0,x0,x0)
#vwtpdef
atup5(x0:vt) = @(x0,x0,x0,x0,x0)
#vwtpdef
atup6(x0:vt) = @(x0,x0,x0,x0,x0,x0)
#vwtpdef
atup7(x0:vt) = @(x0,x0,x0,x0,x0,x0,x0)
#vwtpdef
atup8(x0:vt) = @(x0,x0,x0,x0,x0,x0,x0,x0)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ x0:vt }
gseq_forall0
<atup2(x0)><x0>
  ( tup ) =
let
val b0 =
forall$test0<x0>(tup.0)
in//let
if ~b0
then false
else forall$test0<x0>(tup.1)
end//let//end-of-[gseq_forall0<atup2(x0)><x0>(...)]
//
(* ****** ****** *)
//
#impltmp
{ x0:vt }
gseq_forall0
<atup3(x0)><x0>
  ( tup ) =
let
val b0 =
forall$test0<x0>(tup.0)
in//let
if ~b0
then false else
if ~(forall$test0<x0>(tup.1))
then false else forall$test0<x0>(tup.2)
end//let//end-of-[gseq_forall0<atup3(x0)><x0>(...)]
//
(* ****** ****** *)
//
#impltmp
{ x0:vt }
gseq_forall0
<atup4(x0)><x0>
  ( tup ) =
let
val b0 =
forall$test0<x0>(tup.0)
in//let
if ~b0
then false else
if ~(forall$test0<x0>(tup.1))
then false else
if ~(forall$test0<x0>(tup.2))
then false else forall$test0<x0>(tup.3)
end//let//end-of-[gseq_forall0<atup4(x0)><x0>(...)]
//
(* ****** ****** *)
//
#impltmp
{ x0:vt }
gseq_forall0
<atup5(x0)><x0>
  ( tup ) =
let
val b0 =
forall$test0<x0>(tup.0)
in//let
if ~b0
then false else
if ~(forall$test0<x0>(tup.1))
then false else
if ~(forall$test0<x0>(tup.2))
then false else
if ~(forall$test0<x0>(tup.3))
then false else forall$test0<x0>(tup.4)
end//let//end-of-[gseq_forall0<atup5(x0)><x0>(...)]
//
(* ****** ****** *)
//
#impltmp
{ x0:vt }
gseq_forall0
<atup6(x0)><x0>
  ( tup ) =
let
val b0 =
forall$test0<x0>(tup.0)
in//let
if ~b0
then false else
if ~(forall$test0<x0>(tup.1))
then false else
if ~(forall$test0<x0>(tup.2))
then false else
if ~(forall$test0<x0>(tup.3))
then false else
if ~(forall$test0<x0>(tup.4))
then false else forall$test0<x0>(tup.5)
end//let//end-of-[gseq_forall0<atup6(x0)><x0>(...)]
//
(* ****** ****** *)
//
#impltmp
{ x0:vt }
gseq_forall0
<atup7(x0)><x0>
  ( tup ) =
let
val b0 =
forall$test0<x0>(tup.0)
in//let
if ~b0
then false else
if ~(forall$test0<x0>(tup.1))
then false else
if ~(forall$test0<x0>(tup.2))
then false else
if ~(forall$test0<x0>(tup.3))
then false else
if ~(forall$test0<x0>(tup.4))
then false else
if ~(forall$test0<x0>(tup.5))
then false else forall$test0<x0>(tup.6)
end//let//end-of-[gseq_forall0<atup7(x0)><x0>(...)]
//
(* ****** ****** *)
//
#impltmp
{ x0:vt }
gseq_forall0
<atup8(x0)><x0>
  ( tup ) =
let
val b0 =
forall$test0<x0>(tup.0)
in//let
if ~b0
then false else
if ~(forall$test0<x0>(tup.1))
then false else
if ~(forall$test0<x0>(tup.2))
then false else
if ~(forall$test0<x0>(tup.3))
then false else
if ~(forall$test0<x0>(tup.4))
then false else
if ~(forall$test0<x0>(tup.5))
then false else
if ~(forall$test0<x0>(tup.6))
then false else forall$test0<x0>(tup.7)
end//let//end-of-[gseq_forall0<atup8(x0)><x0>(...)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_VT_tupl001_vt.dats] *)
(***********************************************************************)
`,
  "DATS/VT/unsfx00_vt.dats": `(* ****** ****** *)
(*
** HX-2020-02:
** for unsafe functions
*)
(* ****** ****** *)
(* ****** ****** *)
//
#staload UN =
"prelude/SATS/unsfx00.sats"
//
(* ****** ****** *)
(* ****** ****** *)
(*
HX-2024-07-25:
This one is already
included by [./../unsfx00.dats]
Thu 25 Jul 2024 10:36:52 AM EDT
*)
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<a>(*tmp*)
$UN.p2tr_set_list_vt_nil
  (p0) =
(
$UN.p2tr_set
<list_vt(a)>(p0, list_vt_nil())
)
#impltmp
<a>(*tmp*)
$UN.p2tr_set_list_vt_cons
  (p0, x0) =
let
#vwtpdef
xs = list_vt(a)
val xs = 
$UN.p2tr_get<xs>(p0)
in//let
$UN.p2tr_set<xs>(p0,list_vt_cons(x0,xs))
end//end-of-[$UN.p2tr_set_list_vt_nil(...)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_VT_unsfx00_vt.dats] *)
(***********************************************************************)
`,
  "DATS/asrt000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon Dec 29 12:36:34 PM EST 2025
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ vt:vt }
g_ptcon
<asrt(vt)>
( (*void*) ) =
(
pstrn("asrt"))
#impltmp
{ vt:vt }
g_ptype
<asrt(vt)>
( (*void*) ) =
(
pstrn("asrt(");
g_ptype<vt>((*0*)); pstrn(")"))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: vt >
asrt_length
  (  xs  ) =
(
  a1sz_length<a>(asrt_decd(xs)))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
//
(*
HX-2026-01-04:
This one also works!
*)
//
#impltmp
< x0: vt >
asrt_exists
  (  xs  ) =
(
asrt_length<x0>(xs) >
asrt_search$idx<0>(xs))
where
{
//
#impltmp
search$tcmp1
< x0 >(*x0*) = exists$tcmp1<x0>
//
}(*where*)//end-of-[asrt_exists(xs)]
*)
//
(* ****** ****** *)
//
#impltmp
< x0: vt >
asrt_exists
  (  xs  ) =
(
  loop(0, ln)) where
{
//
val xs =
asrt_decd(xs)
val ln =
a1sz_length<x0>(xs)
//
fnx
loop
( li: nint
, ui: nint): bool =
if
(li >= ui)
then false else
let
val mi =
(
li+(ui-li) / 2)
val (pf | mx) =
a1sz_lget$at(xs, mi)
//
val
sgn = exists$tcmp1(mx)
pvx () =
owed_vt_return0(pf, mx)
//
in//let
//
if // if
(sgn = 0)
then true else
(
if
(sgn < 0) then
loop(li,mi) else loop(mi+1,ui))
//
end(*let*)//end-of-[loop(li,ui)]
//
}(*where*)//end-of-[asrt_exists(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0: vt >
asrt_search$idx
  (  xs  ) =
(
  loop(0, ln)) where
{
//
val xs =
asrt_decd(xs)
val ln =
a1sz_length<x0>(xs)
//
fnx
loop
(li: nint
,ui: nint): sint =
if
(li >= ui)
then ( li ) else
let
val mi =
(
li + (ui-li) / 2)
val (pf | mx) =
a1sz_lget$at(xs, mi)
//
val
sgn =
search$tcmp1<x0>(mx)
pvx () =
owed_vt_return0(pf, mx)
//
in//let
//
(
if
(sgn <= 0) then
loop(li,mi) else loop(mi+1,ui))
//
end(*let*)//end-of-[loop(li,ui)]
//
}(*where*)//end-of-[asrt_search$idx(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:vt >
asrt_memberq
  (xs, x0) =
(
asrt_exists<x0>(xs)) where
{
#impltmp
exists$tcmp1<x0>(x1) = g_cmp11<x0>(x0, x1)
}(*where*)//end-of-[asrt_memberq<x0>(xs,x0)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_asrt000.dats] *)
(***********************************************************************)
`,
  "DATS/axrf000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Sun 11 Aug 2024 03:44:27 PM EDT
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ vt:vt }
g_ptype
<a0rf(vt)>
( (*void*) ) =
(
pstrn("a0rf(");
g_ptype<vt>((*0*)); pstrn(")"))
//
#impltmp
{ vt:vt }
g_ptype
<a1rf(vt)>
( (*void*) ) =
(
pstrn("a1rf(");
g_ptype<vt>((*0*)); pstrn(")"))
//
#impltmp
{ vt:vt }
g_ptype
<a2rf(vt)>
( (*void*) ) =
(
pstrn("a2rf(");
g_ptype<vt>((*0*)); pstrn(")"))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ a: vt }
g_print
<a0rf(a)>
(   xs   ) =
let
//
#vwtpdef x0 = (a)
#typedef xs = a0rf(a)
//
#impltmp
gseq_sep<xs><x0>() = ","
#impltmp
gseq_end<xs><x0>() = ")"
#impltmp
gseq_beg<xs><x0>() = "a0rf("
in//let
(
  gseq_print1<xs><x0>(xs) )
end//let//end(g_print<a0rf(a)>)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ a: vt }
g_print
<a1rf(a)>
(   xs   ) =
let
//
#vwtpdef x0 = (a)
#typedef xs = a1rf(a)
//
#impltmp
gseq_sep<xs><x0>() = ","
#impltmp
gseq_end<xs><x0>() = ")"
#impltmp
gseq_beg<xs><x0>() = "a1rf("
in//let
(
  gseq_print1<xs><x0>(xs) )
end//let//end(g_print<a1rf(a)>)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
gasq_length
<a0rf(x0)><x0>( A ) = 1 // singleton
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:t0 >
a0rf_get(A) =
let
val
(
px|x0) =
a0rf_lget<x0>(A)
pvx () =
owed_t0_elim0(px) in x0 end
#impltmp
< x0:t0 >
a0rf_set(A, x) =
let
pvx px =
owed_t0_make((*0*)) in//let
a0rf_lset<x0>(px | A, x) end//let
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
a0rf_cget(A) =
let
//
val x1 = g_copy<x0>(x0)
//
pvx () =
(
owed_vt_return0(pf,x1)) in x0 end
where
{
  val (pf | x0) = a0rf_lget<x0>(A)
}(*where*)//end-of-[a0rf_cget(...)]
//
#impltmp
< x0:vt >
a0rf_setf(A, x0) =
let
val () =
g_free<x0>(x1) in
  a0rf_lset<x0>(pf|A,x0) end//let
where
{
  val (pf | x1) = a0rf_lget<x0>(A)
}(*where*)//end-of-[a0rf_setf(...)]
//
(* ****** ****** *)
//
#impltmp
{ x0:vt }
$UN.gasq_lget$at$raw
<  a0rf(x0)  >< x0 >
 ( A, i ) = a0rf_lget<x0>(A) // i=0
#impltmp
{ x0:vt }
$UN.gasq_lset$at$raw
<  a0rf(x0)  >< x0 >
( pf | A,i,x ) = a0rf_lset<x0>(pf | A,x)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:t0 >
a1rf_get$at =
$UN.gasq_get$at$raw<a1rf(x0)><x0>
#impltmp
< x0:t0 >
a1rf_set$at =
$UN.gasq_set$at$raw<a1rf(x0)><x0>
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
a1rf_cget$at =
$UN.gasq_cget$at$raw<a1rf(x0)><x0>
#impltmp
< x0:vt >
a1rf_setf$at =
$UN.gasq_setf$at$raw<a1rf(x0)><x0>
//
(* ****** ****** *)
//
#impltmp
{ x0:vt }
$UN.gasq_lget$at$raw
<  a1rf(x0)  >< x0 >
 ( A, i ) = a1rf_lget$at<x0>(A, i)
#impltmp
{ x0:vt }
$UN.gasq_lset$at$raw
<  a1rf(x0)  >< x0 >
( pf | A,i,x ) = a1rf_lset$at<x0>(pf | A,i,x)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_axrf000.dats] *)
(***********************************************************************)
`,
  "DATS/axrf001.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Sun 11 Aug 2024 03:44:27 PM EDT
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
gseq_forall
<a0rf(x0)><x0>
 (   arf   ) =
let
val x0 =
a0rf_get<x0>(arf) in
(
  forall$test<x0>(x0)) end
#impltmp
{ x0:t0 }
gseq_rforall
<a0rf(x0)><x0>
 (   arf   ) =
let
val x0 =
a0rf_get<x0>(arf) in
(
  rforall$test<x0>(x0)) end
#impltmp
{ x0:t0 }
gseq_iforall
<a0rf(x0)><x0>
 (   arf   ) =
let
val x0 =
a0rf_get<x0>(arf) in
(
  iforall$test<x0>(0, x0)) end
#impltmp
{ x0:t0 }
gseq_irforall
<a0rf(x0)><x0>
 (   arf   ) =
let
val x0 =
a0rf_get<x0>(arf) in
(
  irforall$test<x0>(0, x0)) end
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ x0:vt }
gasq_forall
<a0rf(x0)><x0>
 (   arf   ) =
let
val
(
pf|x0) = 
a0rf_lget<x0>(arf)
val btf =
forall$test1<x0>(x0)
pvx () =
owed_vt_return0(pf, x0) in btf end
//
#impltmp
{ x0:vt }
gasq_rforall
<a0rf(x0)><x0>
 (   arf   ) =
let
val
(
pf|x0) = 
a0rf_lget<x0>(arf)
val btf =
rforall$test1<x0>(x0)
pvx () =
owed_vt_return0(pf, x0) in btf end
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:vt >
a1rf_strmize =
gasq_strmize<a1rf(x0)><x0>(*void*)
//
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
gseq_strmize
<a1rf(x0)><x0> =
gasq_strmize<a1rf(x0)><x0>(*void*)
#impltmp
{ x0:vt }
gseq_strmize1
<a1rf(x0)><x0> =
gasq_strmize<a1rf(x0)><x0>(*void*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
gseq_forall
<a1rf(x0)><x0>
  ( A ) =
(
gasq_forall
<a1rf(x0)><x0>(A)) where
{
#impltmp
forall$test1<x0> = forall$test<x0>
}
#impltmp
{ x0:vt }
gseq_forall1
<a1rf(x0)><x0> =
gasq_forall<a1rf(x0)><x0>(* void *)
//
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
gseq_rforall
<a1rf(x0)><x0>
  ( A ) =
(
gseq_rforall1
<a1rf(x0)><x0>(A)) where
{
#impltmp
rforall$test1<x0> = rforall$test<x0>
}
//
#impltmp
{ x0:vt }
gseq_rforall1
<a1rf(x0)><x0> =
gasq_rforall<a1rf(x0)><x0>(* void *)
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
a1rf_forall$size
  (A, n) =
let
#impltmp
gasq_length
<a1rf(x0)><x0>(A) = (n)
in//let
  gasq_forall<a1rf(x0)><x0>(A)
end//let//end-of-[a1rf_forall$size]
//
#impltmp
< x0:vt >
a1rf_forall$size$f1un
  (A, n, test) =
(
  a1rf_forall$size<x0>(A, n))
where
{ #impltmp
  forall$test1<x0>(x0) = test(x0) }
(*where*)//end-of-[a1rf_forall$size$f1un]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_axrf001.dats] *)
(***********************************************************************)
`,
  "DATS/axsz000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Sun 11 Aug 2024 05:30:58 PM EDT
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ vt:vt }
g_ptype
<a1sz(vt)>
( (*void*) ) =
(
pstrn("a1sz(");
g_ptype<vt>((*0*)); pstrn(")"))
//
#impltmp
{ vt:vt }
g_ptype
<a2sz(vt)>
( (*void*) ) =
(
pstrn("a2sz(");
g_ptype<vt>((*0*)); pstrn(")"))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ a: vt }
g_print<a1sz(a)>
  ( xs ) =
let
//
#vwtpdef x0 = (a)
#typedef xs = a1sz(a)
//
#impltmp
gseq_sep<xs><x0>() = ","
#impltmp
gseq_end<xs><x0>() = ")"
#impltmp
gseq_beg<xs><x0>() = "a1sz("
//
in//let
(
  gseq_print1<xs><x0>(xs) )
end//let//end(g_print<a1sz(a)>)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
gasq_length
<a1sz(x0)><x0> = a1sz_length<x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:t0 >
a1sz_get$at =
$UN.gasq_get$at$raw<a1sz(x0)><x0>
#impltmp
< x0:t0 >
a1sz_set$at =
$UN.gasq_set$at$raw<a1sz(x0)><x0>
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
a1sz_cget$at =
$UN.gasq_cget$at$raw<a1sz(x0)><x0>
#impltmp
< x0:vt >
a1sz_setf$at =
$UN.gasq_setf$at$raw<a1sz(x0)><x0>
//
(* ****** ****** *)
//
#impltmp
{ x0:vt }
$UN.gasq_lget$at$raw
<  a1sz(x0)  >< x0 >
 ( A, i ) = a1sz_lget$at<x0>(A, i)
#impltmp
{ x0:vt }
$UN.gasq_lset$at$raw
<  a1sz(x0)  >< x0 >
( pf | A,i,x ) = a1sz_lset$at<x0>(pf | A,i,x)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-06:
Fri 06 Sep 2024 04:39:23 PM EDT
*)
//
#impltmp
< a: t0 >
a1sz_make_list
  ( xs ) =
a1sz_fmake_fwork<a>
(
lam(work) =>
gseq_foritm<list(a)><a>(xs, work))
//
(* ****** ****** *)
//
#impltmp
< a: t0 >
a1sz_make_ncpy
  (n, x) =
a1sz_fmake_fwork<a>
(
lam(work) =>
nint_foritm<>(n, lam(i) => work(x)))
//
#impltmp
< a: vt >
a1sz_make_nfun
  (n, f) =
a1sz_fmake_fwork<a>(
lam(work) =>
nint_foritm<>(n, lam(i) => work(f(i)))
)(*...*)//end-of-[a1sz_make_nfun(n,f)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: vt >
a1sz_make_lstrm
  ( xs ) =
(
a1sz_fmake_fwork<a>(
lam(work) =>
(
  strm_vt_foritm0$f1un<a>(xs, work))))
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_axsz000.dats] *)
(***********************************************************************)
`,
  "DATS/axsz001.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Mon 12 Aug 2024 09:58:00 PM EDT
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:vt >
a1sz_strmize =
gasq_strmize<a1sz(x0)><x0>(*void*)
//
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
gseq_strmize
<a1sz(x0)><x0> =
gasq_strmize<a1sz(x0)><x0>(*void*)
#impltmp
{ x0:vt }
gseq_strmize1
<a1sz(x0)><x0> =
gasq_strmize<a1sz(x0)><x0>(*void*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ a: vt }
g_forall<a1sz(a)> =
gasq_forall<a1sz(a)><a>
//
#impltmp
{ a: vt }
g_foritm<a1sz(a)> =
gseq_foritm1<a1sz(a)><a>
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:vt >
a1sz_forall =
gasq_forall<a1sz(x0)><x0>
#impltmp
< x0:vt >
a1sz_forall$f1un
  (A, test) =
(
a1sz_forall<x0>(A)) where
{
#impltmp
forall$test1<x0>(x0) = test(x0)
}(*where*)//end(a1sz_forall$f1un)
//
#impltmp
{ x0:t0 }
gseq_forall
<a1sz(x0)><x0>
  ( A ) =
(
a1sz_forall<x0>(A)) where
{
#impltmp
forall$test1<x0> = forall$test<x0>
}
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
a1sz_rforall =
gasq_rforall<a1sz(x0)><x0>
#impltmp
{ x0:vt }
a1sz_rforall$f1un
  (A, test) =
(
a1sz_rforall<x0>(A)) where
{
#impltmp
rforall$test1<x0>(x0) = test(x0)
}(*where*)//end(a1sz_rforall$f1un)
//
#impltmp
{ x0:t0 }
gseq_rforall
<a1sz(x0)><x0>
  ( A ) =
(
a1sz_rforall<x0>(A)) where
{
#impltmp
rforall$test1<x0> = rforall$test<x0>
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:vt >
a1sz_mapref =
gasq_mapref<a1sz(x0)><x0>(*void*)
#impltmp
< x0:vt >
a1sz_mapref$c1bv =
gasq_mapref$c1bv<a1sz(x0)><x0>(*void*)
//
#impltmp
< x0:vt >
a1sz_imapref =
gasq_imapref<a1sz(x0)><x0>(*void*)
#impltmp
< x0:vt >
a1sz_imapref$c2bv =
gasq_imapref$c2bv<a1sz(x0)><x0>(*void*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-17:
Sat 17 Aug 2024 07:31:59 PM EDT
#impltmp
<(*tmp*)>
a1sz_fmake_fwork(fwork) = (* ...... *)
HX-2024-08-17: Externally!
For instance, one JS version
can be found in [DATS/CATS/JS/axsz000.dats]
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:vt >
< y0:vt >
gasq_map_a1sz
  ( xs ) =
let
//
val n0 =
gasq_length
<xs><x0>(xs)
//
in//let
//
a1sz_make_nfun<y0>
(
n0,
//
lam(i0):y0 =>
let
val y0 =
map$fopr1<x0><y0>(x0)
pvx () =
owed_vt_return0{x0}(pf, x0) in y0
end//endof(let)
where {
val//val
(pf|x0) =
$UN.gasq_lget$at$raw<xs><x0>(xs,i0)
// end-of-[val(...)]
}(*where*)//end-of-[lam]
//
)(*end-of-[a1sz_make_nfun(n0, ...)]*)
//
end(*let*)//end-of-[gasq_map_a1sz(xs)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:vt >
< y0:vt >
gasq_map$f1un_a1sz
  (xs, fopr) =
(
  gasq_map_a1sz<xs><x0><y0>(xs)
) where
{
#impltmp
map$fopr1<x0><y0>(x0) = fopr(  x0  ) }
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_axsz001.dats] *)
(***********************************************************************)
`,
  "DATS/bool000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Fri 12 Jul 2024 11:29:01 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
#typedef b0 = bool
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
g_0<b0>() = false
#impltmp
g_1<b0>() = (true)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
bool_print<>(b0) =
(
if (b0)
then pstrn("true")
else pstrn("false"))
//end-of-(bool_print<>(b0))
//
#impltmp
g_print<bool> = bool_print<>
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
bool_neg(b0) =
(
if b0 then false else (true))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: t0 >
bool_ifval
(b0, x1, y2) = if b0 then x1 else y2
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_bool000.dats] *)
(***********************************************************************)
`,
  "DATS/char000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Fri 12 Jul 2024 11:29:01 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
#typedef c0 = char
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
g_0<c0>() = ('\\0')
#impltmp
g_1<c0>() = ('\\1')
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
char_lt<> = g_lt<char>
#impltmp
char_gt<> = g_gt<char>
#impltmp
char_eq<> = g_eq<char>
//
#impltmp
char_lte<> = g_lte<char>
#impltmp
char_gte<> = g_gte<char>
#impltmp
char_neq<> = g_neq<char>
//
(* ****** ****** *)
//
#impltmp
g_cmp<char> = char_cmp<>
//
(* ****** ****** *)
//
#impltmp
g_equal<char> = char_eq<>
#impltmp
g_noteq<char> = char_neq<>
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX:
This is in [gdbg000.dats]:
#impltmp
g_ptype
< char >
( (*void*) ) = pstrn("char")
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
char_cmp
(c1, c2) =
(
if c1 > c2
then 1 else
if c1 < c2 then -1 else 0)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
char_lower
 ( c0 ) =
(
if
(c0 < 'A')
then c0 else
if
(c0 > 'Z')
then c0 else ('a'+(c0-'A')))
//
#impltmp
<(*tmp*)>
char_upper
 ( c0 ) =
(
if
(c0 < 'a')
then c0 else
if
(c0 > 'a')
then c0 else ('A'+(c0-'a')))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
g_print<char> = char_print<>
//
(*
HX-2025-05-08:
There is no [char_tostr]
#impltmp
g_tostr<char> = char_tostr<>
Thu May  8 11:26:55 AM EDT 2025
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-04-06:
*)
#impltmp
char_eqz<> = g_eqz<char>
#impltmp
char_neqz<>(c0) = not(char_eqz(c0))
(*
Sat Apr 26 12:51:25 PM EDT 2025
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-15:
Thu Jan 15 06:47:03 PM EST 2026
*)
#impltmp
char_to$code<> = sint_make_char<>(*ch*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_char000.dats] *)
(***********************************************************************)
`,
  "DATS/gamp000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Wed Dec 24 04:39:28 PM EST 2025
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< m0:vt >
< k0:vt >
< x0:vt >
gamp_sep((*void*)) = ","
#impltmp
< m0:vt >
< k0:vt >
< x0:vt >
gamp_end((*void*)) = "}"
#impltmp
< m0:vt >
< k0:vt >
< x0:vt >
gamp_beg((*void*)) = "gamp{"
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_gamp000.dats] *)
(***********************************************************************)
`,
  "DATS/gamp001.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
AMP: array-based map!
Wed Dec 24 05:06:15 PM EST 2025
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<amp:t0>
<key:t0>
<itm:vt>
gamp_key$strmize
  ( amp ) =
let
//
val kxs =
(
gamp_keyval$strmize
< amp >< key >< itm >(amp))
//
in//let
(
strm_vt_amp0<kx>(kxs)) where
{
#vwtpdef kx = (key,itm)
#impltmp amp$fopr0<kx>(kx) = kx.0}
end//let//end(gamp_key$strmize(amp))
//
(* ****** ****** *)
//
#impltmp
<amp:t0>
<key:t0>
<itm:vt>
gamp_val$strmize
  ( amp ) =
let
//
val kxs =
(
gamp_keyval$strmize
< amp >< key >< itm >(amp))
//
in//let
(
strm_vt_amp0<kx>(kxs)) where
{
#vwtpdef kx = (key,itm)
#impltmp amp$fopr0<kx>(kx) = kx.1}
end//let//end(gamp_val$strmize(amp))
//
(* ****** ****** *)
//
#impltmp
<amp:t0>
<key:t0>
<itm:vt>
gamp_keyval$strmize =
gseq_strmize1<amp><(key,itm)>(*void*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_gamp001.dats] *)
(***********************************************************************)
`,
  "DATS/gasq000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sun 21 Jul 2024 02:34:24 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#typedef ni = nint
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gasq_get$at
 ( xs,i0 ) =
let
val n0 =
gasq_length<xs><x0>(xs)
in//let
if
(i0 >= n0)
then
get$at$exn<xs><x0>(xs, i0)
else
let
val
(
pf|x0) =
$UN.gasq_lget$at$raw
<   xs   ><   x0   >(xs, i0)
in//let
let
pvx () = owed_t0_elim0(pf) in x0
end//let
end//let
end//let//end-of-[gasq_get$at(xs,i0)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gasq_set$at
(xs, i0, x0) =
let
val n0 =
gasq_length<xs><x0>(xs)
in//let
if
(i0 >= n0)
then
set$at$exn<xs><x0>(xs,i0,x0)
else
let
pvx pf = owed_t0_make{x0}()
in//let
$UN.gasq_lset$at$raw
<   xs   ><   x0   >(pf | xs,i0,x0)
end//let//else//end-of-[if]
//
end//let//end-of-[gasq_set$at(xs,i0,x0)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
//
HX:
This one is
moved to [unsfx00.dats]
//
#impltmp
< xs:t0 >
< x0:vt >
$UN.gasq_cget$at$raw
  (xs, i0) =
let
//
val
(
pf|x0) =
$UN.gasq_lget$at$raw
<  xs  ><  x0  >( xs, i0 )
//
in//let
//
let
val x1 = g_copy<x0>(x0)
pvx () =
  owed_vt_return0(pf, x0) in x1 end
//
end//let//end-of-[$UN.gasq_cget$at$raw]
*)
//
(* ****** ****** *)
//
(*
//
HX:
This one is
moved to [unsfx00.dats]
//
#impltmp
< xs:t0 >
< x0:vt >
$UN.gasq_setf$at$raw
  (xs, i0, x0) =
let
//
val
(pf | x1) =
$UN.gasq_lget$at$raw
<  xs  ><  x0  >( xs, i0 )
//
in//let
let
  val () = g_free< x0 >( x1 )
in//let
(
$UN.gasq_set$at$raw(pf | xs, i0, x0))
end//let
end//let//end-of-[$UN.gasq_setf$at$raw]
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_gasq000.dats] *)
(***********************************************************************)
`,
  "DATS/gasq001.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sun 21 Jul 2024 02:34:24 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#typedef ni = nint
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:vt >
gasq_listize
  ( xs ) =
let
val n0 =
gasq_length
<xs><x0>(xs)
in//let
(
nint_map_llist<x0>(n0))
where
{
#impltmp
map$fopr<ni><x0>(i0) =
(
$UN.gasq_cget$at$raw
<   xs   ><   x0   >( xs, i0 ))
}
end//let//end-of-[gasq_listize(xs)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:vt >
gasq_rlistize
  ( xs ) =
let
val n0 =
gasq_length
<xs><x0>(xs)
in//let
(
nint_rmap_llist<x0>(n0))
where
{
#impltmp
rmap$fopr<ni><x0>(i0) =
(
$UN.gasq_cget$at$raw
<   xs   ><   x0   >( xs, i0 ))
}
end//let//end-of-[gasq_rlistize(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:vt >
gasq_strmize
  ( xs ) =
let
val n0 =
gasq_length
<xs><x0>(xs)
in//let
(
nint_map_lstrm<x0>(n0))
where
{
#impltmp
map$fopr<ni><x0>(i0) =
(
$UN.gasq_cget$at$raw
<   xs   ><   x0   >( xs, i0 ))
}
end//let//end-of-[gasq_strmize(xs)]
//
#impltmp
< xs:t0 >
< x0:vt >
gasq_rstrmize
  ( xs ) =
let
val n0 =
gasq_length
<xs><x0>(xs)
in//let
(
nint_rmap_lstrm<x0>(n0))
where
{
#impltmp
rmap$fopr<ni><x0>(i0) =
(
$UN.gasq_cget$at$raw
<   xs   ><   x0   >( xs, i0 ))
}
end//let//end-of-[gasq_rstrmize(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:vt >
gasq_forall(xs) =
let
val n0 =
gasq_length
<xs><x0>(xs)
in//let
(*
HX-2024-07-22:
This example shows
the need for non-rec templates!
*)
(
nint_forall<>(n0))
where
{
#impltmp
forall$test<ni>(i0) =
(
  g_free<x0>(x0); r0)
where
{
//
val
(
pf|x0) =
$UN.gasq_lget$at$raw
< xs >< x0 >(xs, i0)
//
val r0 =
  forall$test1<x0>(x0)
//
pvx () =
(
  owed_vt_return0(pf, x0)) }
}
end//let//end-of-[gasq_forall(xs)]
//
#impltmp
< xs:t0 >
< x0:vt >
gasq_forall$f1un
  (xs, test) =
(
gasq_forall
<xs><x0>(xs)) where {
#impltmp
forall$test1<x0>(*x0*) = test(*x0*)
}(*where*)//end-of-[gasq_forall$f1un(xs)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:vt >
gasq_exists(xs) =
let
//
#impltmp
forall$test1<x0>(x0) =
(
  not(exists$test1<x0>(x0)))
//
in//let
  not(gasq_forall<xs><x0>(xs))
end//let//end-of-[gasq_exists(xs)]
//
#impltmp
< xs:t0 >
< x0:vt >
gasq_exists$f1un
  (xs, test) =
(
gasq_exists
<xs><x0>(xs)) where {
#impltmp
exists$test1<x0>(*x0*) = test(*x0*)
}(*where*)//end-of-[gasq_exists$f1un(xs)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:vt >
gasq_rforall(xs) =
let
val n0 =
(
gasq_length
<xs><x0>(xs))
val n1 = (n0-1)
in//let
(*
HX-2024-07-22:
This example shows
the need for non-rec templates!
*)
(
nint_forall<>(n0))
where
{
#impltmp
forall$test<ni>(i0) =
(
  g_free<x0>(x0); r0)
where
{
val
(pf | x0) =
$UN.gasq_lget$at$raw
< xs >< x0 >(xs, n1-i0)
val r0 =
  rforall$test1<x0>(x0)
val () =
$UN.gasq_lset$at$raw
<xs><x0>(pf | xs, i0, x0) }
}
end//let//end-of-[gasq_rforall(xs)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:vt >
gasq_rforall$f1un
  (xs, test) =
(
gasq_rforall
<xs><x0>(xs)) where
{
#impltmp
rforall$test1<x0>(*x0*) = test(*x0*)
}(*where*)//end-of-[gasq_rforall$f1un(xs)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:vt >
gasq_rexists(xs) =
let
//
#impltmp
rforall$test1<x0>(x0) =
(
  not(rexists$test1<x0>(x0)))
//
in//let
  not(gasq_rforall<xs><x0>(xs))
end//let//end-of-[gasq_rexists(xs)]
//
#impltmp
< xs:t0 >
< x0:vt >
gasq_rexists$f1un
  (xs, test) =
(
gasq_rexists
<xs><x0>(xs)) where {
#impltmp
rexists$test1<x0>(*x0*) = test(*x0*)
}(*where*)//end-of-[gasq_rexists$f1un(xs)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:vt >
gasq_iforall(xs) =
let
val n0 =
gasq_length
<xs><x0>(xs)
in//let
(*
HX-2024-07-22:
This example shows
the need for non-rec templates!
*)
(
nint_forall<>(n0))
where
{
#impltmp
forall$test<ni>(i0) =
let
val () =
g_free<x0>(x0) in r0
end where//endof(let)
{
//
val
(
pf|x0) =
$UN.gasq_lget$at$raw
< xs >< x0 >( xs, i0 )
//
val r0 =
iforall$test1<x0>(i0, x0)
//
pvx () =
(
  owed_vt_return0(pf, x0)) }
}
end//let//end-of-[gasq_iforall(xs)]
//
#impltmp
< xs:t0 >
< x0:vt >
gasq_iforall$f2un
  (xs, test) =
(
gasq_iforall
<xs><x0>(xs)) where {
#impltmp
iforall$test1<x0> = test(*i0,x0*)//impl
}(*where*)//end-of-[gasq_iforall$f2un(xs)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:vt >
gasq_irforall(xs) =
let
val n0 =
(
gasq_length
<xs><x0>(xs))
val n1 = (n0-1)
in//let
(
nint_forall<>(n0))
where
{
#impltmp
forall$test<ni>(i0) =
let
val () =
g_free<x0>(x0) in r0
end where//endof(let)
{
//
val
(
pf|x0) =
$UN.gasq_lget$at$raw
< xs >< x0 >(xs, n1-i0)
//
val r0 =
irforall$test1<x0>(i0, x0)
//
pvx () =
(
  owed_vt_return0(pf, x0)) }
}
end//let//end-of-[gasq_irforall(xs)]
//
#impltmp
< xs:t0 >
< x0:vt >
gasq_irforall$f2un
  (xs, test) =
(
gasq_irforall
<xs><x0>(xs)) where {
#impltmp
irforall$test1<x0> = test(*i0,x0*)//impl
}(*where*)//end-of-[gasq_irforall$f2un(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:vt >
gasq_foritm(xs) =
let
val n0 =
gasq_length
<xs><x0>(xs)
in//let
(
nint_foritm<>(n0))
where
{
#impltmp
foritm$work<ni>(i0) =
(
  g_free<x0>(x0); ())
where
{
//
val
(
pf|x0) =
$UN.gasq_lget$at$raw
< xs >< x0 >( xs, i0 )
//
val () =
(
  foritm$work1<x0>(x0))
//
pvx () =
(
  owed_vt_return0(pf, x0)) }
}
end//let//end-of-[gasq_foritm(xs)]
//
#impltmp
< xs:t0 >
< x0:vt >
gasq_foritm$f1un
  (xs, test) =
(
gasq_foritm
<xs><x0>(xs)) where {
#impltmp
foritm$work1<x0>(*x0*) = test(*x0*)
}(*where*)//end-of-[gasq_foritm$f1un(xs)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:vt >
gasq_rforitm(xs) =
let
val n0 =
(
gasq_length
<xs><x0>(xs))
val n1 = (n0-1)
in//let
(
nint_foritm<>(n0))
where
{
#impltmp
foritm$work<ni>(i0) =
(
  g_free<x0>(x0); ())
where
{
//
val
(
pf|x0) =
$UN.gasq_lget$at$raw
< xs >< x0 >(xs, n1-i0)
//
val () =
(
  rforitm$work1<x0>(x0))
//
pvx () =
(
  owed_vt_return0(pf, x0)) }
}
end//let//end-of-[gasq_rforitm(xs)]
//
#impltmp
< xs:t0 >
< x0:vt >
gasq_rforitm$f1un
  (xs, test) =
(
gasq_rforitm
<xs><x0>(xs)) where {
#impltmp
rforitm$work1<x0>(*x0*) = test(*x0*)
}(*where*)//end-of-[gasq_rforitm$f1un(xs)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:vt >
gasq_iforitm(xs) =
let
val n0 =
gasq_length
<xs><x0>(xs)
in//let
(
nint_foritm<>(n0))
where
{
#impltmp
foritm$work<ni>(i0) =
(
  g_free<x0>(x0); ())
where
{
//
val
(
pf|x0) =
$UN.gasq_lget$at$raw
< xs >< x0 >( xs, i0 )
//
val () =
(
iforitm$work1<x0>(i0, x0))
//
pvx () =
(
  owed_vt_return0(pf, x0)) }
}
end//let//end-of-[gasq_iforitm(xs)]
//
#impltmp
< xs:t0 >
< x0:vt >
gasq_iforitm$f2un
  (xs, test) =
(
gasq_iforitm
<xs><x0>(xs)) where {
#impltmp
iforitm$work1<x0> = test(*i0,x0*)//impl
}(*where*)//end-of-[gasq_iforitm$f2un(xs)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:vt >
gasq_irforitm(xs) =
let
val n0 =
(
gasq_length
<xs><x0>(xs))
val n1 = (n0-1)
in//let
(
nint_foritm<>(n0))
where
{
#impltmp
foritm$work<ni>(i0) =
(
  g_free<x0>(x0); ())
where
{
//
val
(
pf|x0) =
$UN.gasq_lget$at$raw
< xs >< x0 >(xs, n1-i0)
//
val () =
(
irforitm$work1<x0>(i0, x0))
//
pvx () =
(
  owed_vt_return0(pf, x0)) }
}
end//let//end-of-[gasq_irforitm(xs)]
//
#impltmp
< xs:t0 >
< x0:vt >
gasq_irforitm$f2un
  (xs, test) =
(
gasq_irforitm
<xs><x0>(xs)) where {
#impltmp
irforitm$work1<x0> = test(*i0,x0*)//impl
}(*where*)//end-of-[gasq_irforitm$f2un(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:vt >
mapref$fopr0(x0) =
let
var x0 = x0
in//let
(
mapref$fopr1x<x0>(x0);x0)
end//let//(mapref$fopr0(x0))
#impltmp
< x0:vt >
mapref$fopr1x(x0) =
(x0 := mapref$fopr0<x0>(x0))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:vt >
gasq_mapref$c1bv
  (xs, fopr) =
(
gasq_mapref
<xs><x0>(xs)) where
{
#impltmp
mapref$fopr0<x0>(*x0*) = fopr(*x0*)
}(*where*)//end-of-[gasq_mapref$c1bv]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-05:
Mon Jan  5 06:44:09 PM EST 2026
*)
//
#impltmp
< xs:t0 >
< x0:t0 >
gasq_sortedq
  ( xs ) =
let
//
val ln =
gasq_length<xs><x0>(xs)
//
fun
auxloop
(i0: nint, x0: x0): bool =
(
if
(i0 >= ln)
then true else
(
if // if
sortedq$lteq<x0>(x0, x1)
then
auxloop(i0+1, x1) else false)
where
{
val x1 =
$UN.gasq_get$at$raw<xs><x0>(xs, i0)}
)
//
in//let
//
(
if // if
(ln <= 1)
then true else
auxloop(1, 
  $UN.gasq_get$at$raw<xs><x0>(xs, 0)))
//
end(*let*)//end-of-[gasq_sortedq<xs><x0>(xs)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gasq_sortedq$f2un
  (xs, lteq) =
(
gasq_sortedq<xs><x0>(xs))
where
{
#impltmp
sortedq$lteq<x0>(*x1,x2*) = lteq(*x1,x2*)
}(*where*)//end-of-[gasq_sortedq$f2un(xs,lteq)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_gasq001.dats] *)
(***********************************************************************)
`,
  "DATS/gasq002.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Thu 08 Aug 2024 04:47:26 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
#define
GZ2ASQ(xs, ys) =
GASQ_z2make(GASQ(xs), GASQ(ys))
//
(*
#typedef
gz2asq
( xs: t0, x0: t0
, ys: t0, y0: t0) =
(
z2tup(GASQ(xs, x0), GASQ(ys, y0)))
*)
//
#impltmp
< xs:t0 >
< x0:vt >
< ys:t0 >
< y0:vt >
GASQ_z2make
(xseq, yseq) =
$UN.castxy//GASQ_make
(z2tup_make(xseq, yseq))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-05:
Thu 08 Aug 2024 04:50:03 AM EDT
*)
//
#impltmp
< xs:t0 >
< x0:vt >
< ys:t0 >
< y0:vt >
gasq_z2forall
  (xs, ys) =
let
val nx =
gasq_length<xs><x0>(xs)
val ny =
gasq_length<ys><y0>(ys)
in//let
(
nint_forall<>
(g_min<nint>(nx, ny))) where
{
#impltmp
forall$test<nint>(i0) =
let
pvx () =
  owed_vt_return0(fx, x0)
pvx () =
  owed_vt_return0(fy, y0) in btf
end where
{
//
val
(fx|x0) =
$UN.gasq_lget$at$raw<xs><x0>(xs, i0)
val
(fy|y0) =
$UN.gasq_lget$at$raw<ys><y0>(ys, i0)
//
val btf = z2forall$test1<x0><y0>(x0, y0)
//
}(*where*)
}(*where*)
end(*let*)//end-of-[gasq_z2forall(xs, ys)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:vt >
< ys:t0 >
< y0:vt >
gasq_z2rforall
  (xs, ys) =
let
val nx =
gasq_length<xs><x0>(xs)
val ny =
gasq_length<ys><y0>(ys)
in//let
(
nint_rforall<>
(g_min<nint>(nx, ny))) where
{
#impltmp
rforall$test<nint>(i0) =
let
pvx () =
  owed_vt_return0(fx, x0)
pvx () =
  owed_vt_return0(fy, y0) in btf
end where
{
//
val
(fx|x0) =
$UN.gasq_lget$at$raw<xs><x0>(xs, i0)
val
(fy|y0) =
$UN.gasq_lget$at$raw<ys><y0>(ys, i0)
//
val btf = z2rforall$test1<x0><y0>(x0, y0)
//
}(*where*)
}(*where*)
end(*let*)//end-of-[gasq_z2rforall(xs, ys)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_gasq002.dats] *)
(***********************************************************************)
`,
  "DATS/gbas000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Wed 10 Jul 2024 10:39:58 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
g_void<x0>(obj) = ()
//
(* ****** ****** *)
//
#impltmp
{ x0:vt }
g_self<x0>(obj) = obj
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-16:
g_free0 and g_copy1
are in [gbas001.dats]
*)
#impltmp
{ x0:t0 }
g_free<x0>(obj) = ( )
#impltmp
{ x0:t0 }
g_copy<x0>(obj) = obj
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
g_print
<unit>(ut) = strn_print("unit")
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:vt >
g_parse(rep) =
(
case- opt of
| ~
optn_vt_cons(x0) => x0) where
{
  val opt = g_parse$opt<x0>(rep)
}(*where*)//end-of-[g_parse(rep)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_gbas000.dats] *)
(***********************************************************************)
`,
  "DATS/gbas001.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Wed 10 Jul 2024 10:42:18 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:t0 >
max$nil() =
(
  $raise UndefinedExn())
#impltmp
< x0:t0 >
min$nil() =
(
  $raise UndefinedExn())
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
get$at$exn
  (xs, i0) =
(
$raise SubscriptExn(*void*))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
set$at$exn
  (xs, i0, x0) =
(
$raise SubscriptExn(*void*))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
fset$at$exn
  (xs, i0, x0) =
(
$raise SubscriptExn(*void*))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
#impltmp
< x0:t0 >
forall$test =
rforall$test<x0>
#impltmp
< x0:t0 >
rforall$test = forall$test<x0>
//
#impltmp
< x0:t0 >
iforall$test =
irforall$test<x0>
#impltmp
< x0:t0 >
irforall$test = iforall$test<x0>
*)
//
(* ****** ****** *)
//
(*
#impltmp
< x0:t0 >
foritm$work =
rforitm$work<x0>
#impltmp
< x0:t0 >
rforitm$work = foritm$work<x0>
//
#impltmp
< x0:t0 >
iforitm$work =
irforitm$work<x0>
#impltmp
< x0:t0 >
irforitm$work = iforitm$work<x0>
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
#impltmp
< x0:t0 >
< r0:vt >
folditm$fopr
( r0
, x0 ) =
(
rfolditm$fopr<x0><r0>(x0, r0))
#impltmp
< x0:t0 >
< r0:vt >
rfolditm$fopr
( x0
, r0 ) =
(
  folditm$fopr<x0><r0>(r0, x0))
*)
//
(* ****** ****** *)
//
(*
#impltmp
< x0:t0 >
< r0:vt >
foldall$fopr
( r0
, x0 ) =
(
rfoldall$fopr<x0><r0>(x0, r0))
#impltmp
< x0:t0 >
< r0:vt >
rfoldall$fopr
( x0
, r0 ) =
(
  foldall$fopr<x0><r0>(r0, x0))
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-16:
Tue 16 Jul 2024 10:43:39 AM EDT
*)
(*
#impltmp
< x0:t0 >
exists$test =
rexists$test<x0>
#impltmp
< x0:t0 >
rexists$test = exists$test<x0>
//
#impltmp
< x0:t0 >
iexists$test =
irexists$test<x0>
#impltmp
< x0:t0 >
irexists$test = iexists$test<x0>
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-22:
Mon 22 Jul 2024 05:20:11 PM EDT
*)
//
(*
#impltmp
< x0:t0 >
forall$test = forall$test0<x0>
#impltmp
< x0:t0 >
forall$test = forall$test1<x0>
*)
//
(*
#impltmp
< x0:t0 >
rforall$test = rforall$test0<x0>
#impltmp
< x0:t0 >
rforall$test = rforall$test1<x0>
*)
//
(*
#impltmp
< x0:t0 >
iforall$test = iforall$test0<x0>
#impltmp
< x0:t0 >
iforall$test = iforall$test1<x0>
*)
//
(*
#impltmp
< x0:t0 >
irforall$test = irforall$test0<x0>
#impltmp
< x0:t0 >
irforall$test = irforall$test1<x0>
*)
//
(* ****** ****** *)
//
(*
#impltmp
< x0:t0 >
foritm$work = foritm$work0<x0>
#impltmp
< x0:t0 >
foritm$work = foritm$work1<x0>
*)
//
(*
#impltmp
< x0:t0 >
rforitm$work = rforitm$work0<x0>
#impltmp
< x0:t0 >
rforitm$work = rforitm$work1<x0>
*)
//
(*
#impltmp
< x0:t0 >
iforitm$work = iforitm$work0<x0>
#impltmp
< x0:t0 >
iforitm$work = iforitm$work1<x0>
*)
//
(*
#impltmp
< x0:t0 >
irforitm$work = irforitm$work0<x0>
#impltmp
< x0:t0 >
irforitm$work = irforitm$work1<x0>
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-22:
Mon 22 Jul 2024 05:20:11 PM EDT
*)
//
(*
#impltmp
< x0:t0 >
< r0:vt >
folditm$fopr = folditm$fopr0<x0><r0>
#impltmp
< x0:t0 >
< r0:vt >
folditm$fopr = folditm$fopr1<x0><r0>
*)
//
(*
#impltmp
< x0:t0 >
< r0:vt >
rfolditm$fopr = rfolditm$fopr0<x0><r0>
#impltmp
< x0:t0 >
< r0:vt >
rfolditm$fopr = rfolditm$fopr1<x0><r0>
*)
//
(*
#impltmp
< x0:t0 >
< r0:vt >
ifolditm$fopr = ifolditm$fopr0<x0><r0>
#impltmp
< x0:t0 >
< r0:vt >
ifolditm$fopr = ifolditm$fopr1<x0><r0>
*)
//
(*
#impltmp
< x0:t0 >
< r0:vt >
irfolditm$fopr = irfolditm$fopr0<x0><r0>
#impltmp
< x0:t0 >
< r0:vt >
irfolditm$fopr = irfolditm$fopr1<x0><r0>
*)
//
(* ****** ****** *)
//
(*
#impltmp
< x0:t0 >
< r0:vt >
foldall$fopr = foldall$fopr0<x0><r0>
#impltmp
< x0:t0 >
< r0:vt >
foldall$fopr = foldall$fopr1<x0><r0>
*)
//
(*
#impltmp
< x0:t0 >
< r0:vt >
rfoldall$fopr = rfoldall$fopr0<x0><r0>
#impltmp
< x0:t0 >
< r0:vt >
rfoldall$fopr = rfoldall$fopr0<x0><r0>
*)
//
(*
#impltmp
< x0:t0 >
< r0:vt >
ifoldall$fopr = ifoldall$fopr0<x0><r0>
#impltmp
< x0:t0 >
< r0:vt >
ifoldall$fopr = ifoldall$fopr1<x0><r0>
*)
//
(*
#impltmp
< x0:t0 >
< r0:vt >
irfoldall$fopr = irfoldall$fopr0<x0><r0>
#impltmp
< x0:t0 >
< r0:vt >
irfoldall$fopr = irfoldall$fopr1<x0><r0>
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-22:
Mon 22 Jul 2024 05:26:27 PM EDT
*)
//
(*
#impltmp
< x0:t0 >
< y0:vt >
map$fopr = map$fopr0<x0><y0>
#impltmp
< x0:t0 >
< y0:vt >
map$fopr = map$fopr1<x0><y0>
*)
//
(*
#impltmp
< x0:t0 >
< y0:vt >
rmap$fopr = rmap$fopr0<x0><y0>
#impltmp
< x0:t0 >
< y0:vt >
rmap$fopr = rmap$fopr1<x0><y0>
*)
//
(*
#impltmp
< x0:t0 >
< y0:vt >
imap$fopr = imap$fopr0<x0><y0>
#impltmp
< x0:t0 >
< y0:vt >
imap$fopr = imap$fopr1<x0><y0>
*)
//
(*
#impltmp
< x0:t0 >
< y0:vt >
irmap$fopr = irmap$fopr0<x0><y0>
#impltmp
< x0:t0 >
< y0:vt >
irmap$fopr = irmap$fopr1<x0><y0>
*)
//
(* ****** ****** *)
//
(*
#impltmp
< x0:t0 >
filter$test = filter$test1<x0>
#impltmp
< x0:t0 >
rfilter$test = rfilter$test1<x0>
#impltmp
< x0:t0 >
ifilter$test = ifilter$test1<x0>
#impltmp
< x0:t0 >
irfilter$test = irfilter$test1<x0>
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-22:
Mon 22 Jul 2024 05:29:19 PM EDT
*)
//
(*
#impltmp
< x0:t0 >
< y0:vt >
mapoptn$fopr = mapoptn$fopr0<x0><y0>
#impltmp
< x0:t0 >
< y0:vt >
mapoptn$fopr = mapoptn$fopr0<x0><y0>
*)
//
(*
#impltmp
< x0:t0 >
< y0:vt >
maplist$fopr = maplist$fopr0<x0><y0>
#impltmp
< x0:t0 >
< y0:vt >
maplist$fopr = maplist$fopr1<x0><y0>
*)
//
(*
#impltmp
< x0:t0 >
< y0:vt >
mapstrm$fopr = mapstrm$fopr0<x0><y0>
#impltmp
< x0:t0 >
< y0:vt >
mapstrm$fopr = mapstrm$fopr1<x0><y0>
*)
//
(*
#impltmp
< x0:t0 >
< y0:vt >
mapstrq$fopr = mapstrq$fopr0<x0><y0>
#impltmp
< x0:t0 >
< y0:vt >
mapstrq$fopr = mapstrq$fopr1<x0><y0>
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-05:
Mon Jan  5 12:17:18 PM EST 2026
*)
//
#impltmp
< x0:t0 >
sortedq$lteq(*x1,x2*) = g_lte<x0>(*x1,x2*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_gbas001.dats] *)
(***********************************************************************)
`,
  "DATS/gbas002.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sun 14 Jul 2024 12:24:44 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a0:t0 >
< a1:t0 >
z2tup_make
( x1, x2 ) =
(
  $UN.castxy@(x1, x2))
#impltmp
< a0:t0 >
< a1:t0 >
z2tup_unmk
 ( ztup ) = $UN.castxy(ztup)
//
#impltmp
{ a0:t0
, a1:t0 }
g_ptype
<z2tup(a0,a1)>
(  (*void*)  ) =
( pstrn"z2tup("
; g_ptype<a0>(); pstrn(",")
; g_ptype<a1>(); pstrn(")"))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a0:t0 >
< a1:t0 >
x2tup_make
( x1, x2 ) =
(
  $UN.castxy@(x1, x2))
#impltmp
< a0:t0 >
< a1:t0 >
x2tup_unmk
 ( xtup ) = $UN.castxy(xtup)
//
#impltmp
{ a0:t0
, a1:t0 }
g_ptype
<x2tup(a0,a1)>
(  (*void*)  ) =
( pstrn"x2tup("
; g_ptype<a0>(); pstrn(",")
; g_ptype<a1>(); pstrn(")"))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
#impltmp
< x0:t0
, y0:t0 >
z2forall$test =
z2rforall$test<x0,y0>
#impltmp
< x0:t0
, y0:t0 >
z2rforall$test = z2forall$test<x0,y0>
*)
//
(*
#impltmp
< x0:t0
, y0:t0 >
z2foritm$work =
z2rforitm$work<x0,y0>
#impltmp
< x0:t0
, y0:t0 >
z2rforitm$work = z2foritm$work<x0,y0>
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_gbas002.dats] *)
(***********************************************************************)
`,
  "DATS/gcls000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon 29 Jul 2024 06:15:29 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#staload UN = 
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
GSEQ_unmk
(  gseq  ) =
(
  $UN.castxy(gseq))
//
#impltmp
{ xs:t0 }
{ x0:t0 }
g_ptype
<GSEQ(xs,x0)>
(  (*void*)  ) =
( pstrn"GSEQ("
; g_ptype<xs>(); pstrn(",")
; g_ptype<x0>(); pstrn(")"))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:vt >
GASQ_unmk
(  gasq  ) =
(
  $UN.castxy(gasq))
//
#impltmp
{ xs:t0 }
{ x0:t0 }
g_ptype
<GASQ(xs,x0)>
(  (*void*)  ) =
( pstrn"GASQ("
; g_ptype<xs>(); pstrn(",")
; g_ptype<x0>(); pstrn(")"))
//
(* ****** ****** *)
(* ****** ****** *)
(*
HX: GSEQ:
generic list-like sequences
*)
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
GSEQ_sum
  (gseq) =
(
gseq_sum
<xs><x0>(GSEQ_unmk<xs><x0>(gseq)))
//
#impltmp
< xs:t0 >
< x0:t0 >
GSEQ_prod
  (gseq) =
(
gseq_prod
<xs><x0>(GSEQ_unmk<xs><x0>(gseq)))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
GSEQ_length
  (gseq) =
(
gseq_length
<xs><x0>(GSEQ_unmk<xs><x0>(gseq)))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
GSEQ_listize
  (gseq) =
(
gseq_listize
<xs><x0>(GSEQ_unmk<xs><x0>(gseq)))
//
#impltmp
< xs:t0 >
< x0:t0 >
GSEQ_rlistize
  (gseq) =
(
gseq_rlistize
<xs><x0>(GSEQ_unmk<xs><x0>(gseq)))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
GSEQ_strmize
  (gseq) =
(
gseq_strmize
<xs><x0>(GSEQ_unmk<xs><x0>(gseq)))
//
#impltmp
< xs:t0 >
< x0:t0 >
GSEQ_rstrmize
  (gseq) =
(
gseq_rstrmize
<xs><x0>(GSEQ_unmk<xs><x0>(gseq)))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
GSEQ_forall
  (gseq) =
(
gseq_forall
<xs><x0>(GSEQ_unmk<xs><x0>(gseq)))
//
#impltmp
< xs:t0 >
< x0:t0 >
GSEQ_exists
  (gseq) =
(
gseq_exists
<xs><x0>(GSEQ_unmk<xs><x0>(gseq)))
//
#impltmp
< xs:t0 >
< x0:t0 >
GSEQ_rforall
  (gseq) =
(
gseq_rforall
<xs><x0>(GSEQ_unmk<xs><x0>(gseq)))
//
#impltmp
< xs:t0 >
< x0:t0 >
GSEQ_iforall
  (gseq) =
(
gseq_iforall
<xs><x0>(GSEQ_unmk<xs><x0>(gseq)))
//
#impltmp
< xs:t0 >
< x0:t0 >
GSEQ_irforall
  (gseq) =
(
gseq_irforall
<xs><x0>(GSEQ_unmk<xs><x0>(gseq)))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
GSEQ_forall$f1un
  (gseq, test) =
(
gseq_forall$f1un
<xs><x0>(GSEQ_unmk<xs><x0>(gseq), test))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
GSEQ_exists$f1un
  (gseq, test) =
(
gseq_exists$f1un
<xs><x0>(GSEQ_unmk<xs><x0>(gseq), test))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
GSEQ_rforall$f1un
  (gseq, test) =
(
gseq_rforall$f1un
<xs><x0>(GSEQ_unmk<xs><x0>(gseq), test))
//
#impltmp
< xs:t0 >
< x0:t0 >
GSEQ_rexists$f1un
  (gseq, test) =
(
gseq_rexists$f1un
<xs><x0>(GSEQ_unmk<xs><x0>(gseq), test))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
GSEQ_iforall$f2un
  (gseq, test) =
(
gseq_iforall$f2un
<xs><x0>(GSEQ_unmk<xs><x0>(gseq), test))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
GSEQ_irforall$f2un
  (gseq, test) =
(
gseq_irforall$f2un
<xs><x0>(GSEQ_unmk<xs><x0>(gseq), test))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
GSEQ_foritm
  (gseq) =
(
gseq_foritm
<xs><x0>(GSEQ_unmk<xs><x0>(gseq)))
//
#impltmp
< xs:t0 >
< x0:t0 >
GSEQ_rforitm
  (gseq) =
(
gseq_rforitm
<xs><x0>(GSEQ_unmk<xs><x0>(gseq)))
//
#impltmp
< xs:t0 >
< x0:t0 >
GSEQ_iforitm
  (gseq) =
(
gseq_iforitm
<xs><x0>(GSEQ_unmk<xs><x0>(gseq)))
//
#impltmp
< xs:t0 >
< x0:t0 >
GSEQ_irforitm
  (gseq) =
(
gseq_irforitm
<xs><x0>(GSEQ_unmk<xs><x0>(gseq)))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
GSEQ_foritm$f1un
  (gseq, test) =
(
gseq_foritm$f1un
<xs><x0>(GSEQ_unmk<xs><x0>(gseq), test))
//
#impltmp
< xs:t0 >
< x0:t0 >
GSEQ_rforitm$f1un
  (gseq, test) =
(
gseq_rforitm$f1un
<xs><x0>(GSEQ_unmk<xs><x0>(gseq), test))
//
#impltmp
< xs:t0 >
< x0:t0 >
GSEQ_iforitm$f2un
  (gseq, test) =
(
gseq_iforitm$f2un
<xs><x0>(GSEQ_unmk<xs><x0>(gseq), test))
//
#impltmp
< xs:t0 >
< x0:t0 >
GSEQ_irforitm$f2un
  (gseq, test) =
(
gseq_irforitm$f2un
<xs><x0>(GSEQ_unmk<xs><x0>(gseq), test))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
GSEQ_folditm
 (gseq, r0) =
(
gseq_folditm
<xs><x0><r0>(GSEQ_unmk<xs><x0>(gseq), r0))
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
GSEQ_rfolditm
 (gseq, r0) =
(
gseq_rfolditm
<xs><x0><r0>(GSEQ_unmk<xs><x0>(gseq), r0))
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
GSEQ_ifolditm
 (gseq, r0) =
(
gseq_ifolditm
<xs><x0><r0>(GSEQ_unmk<xs><x0>(gseq), r0))
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
GSEQ_irfolditm
 (gseq, r0) =
(
gseq_irfolditm
<xs><x0><r0>(GSEQ_unmk<xs><x0>(gseq), r0))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
GSEQ_folditm$f2un
 (gseq, r0, fopr) =
(
gseq_folditm$f2un
<xs><x0><r0>(GSEQ_unmk<xs><x0>(gseq), r0, fopr))
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
GSEQ_rfolditm$f2un
 (gseq, r0, fopr) =
(
gseq_rfolditm$f2un
<xs><x0><r0>(GSEQ_unmk<xs><x0>(gseq), r0, fopr))
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
GSEQ_ifolditm$f3un
 (gseq, r0, fopr) =
(
gseq_ifolditm$f3un
<xs><x0><r0>(GSEQ_unmk<xs><x0>(gseq), r0, fopr))
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
GSEQ_irfolditm$f3un
 (gseq, r0, fopr) =
(
gseq_irfolditm$f3un
<xs><x0><r0>(GSEQ_unmk<xs><x0>(gseq), r0, fopr))
//
(* ****** ****** *)
(* ****** ****** *)
(*
HX: GASQ:
generic array-like sequences
*)
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:vt >
GASQ_length
  (gasq) =
(
gasq_length
<xs><x0>(GASQ_unmk<xs><x0>(gasq)))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:vt >
GASQ_listize
  (gasq) =
(
gasq_listize
<xs><x0>(GASQ_unmk<xs><x0>(gasq)))
#impltmp
< xs:t0 >
< x0:vt >
GASQ_rlistize
  (gasq) =
(
gasq_rlistize
<xs><x0>(GASQ_unmk<xs><x0>(gasq)))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
GASQ_strmize
  (gasq) =
(
gasq_strmize
<xs><x0>(GASQ_unmk<xs><x0>(gasq)))
#impltmp
< xs:t0 >
< x0:t0 >
GASQ_rstrmize
  (gasq) =
(
gasq_rstrmize
<xs><x0>(GASQ_unmk<xs><x0>(gasq)))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:vt >
GASQ_forall
  (gasq) =
(
gasq_forall
<xs><x0>(GASQ_unmk<xs><x0>(gasq)))
#impltmp
< xs:t0 >
< x0:vt >
GASQ_exists
  (gasq) =
(
gasq_exists
<xs><x0>(GASQ_unmk<xs><x0>(gasq)))
//
#impltmp
< xs:t0 >
< x0:vt >
GASQ_rforall
  (gasq) =
(
gasq_rforall
<xs><x0>(GASQ_unmk<xs><x0>(gasq)))
//
#impltmp
< xs:t0 >
< x0:vt >
GASQ_iforall
  (gasq) =
(
gasq_iforall
<xs><x0>(GASQ_unmk<xs><x0>(gasq)))
//
#impltmp
< xs:t0 >
< x0:vt >
GASQ_irforall
  (gasq) =
(
gasq_irforall
<xs><x0>(GASQ_unmk<xs><x0>(gasq)))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:vt >
GASQ_forall$f1un
  (gasq, test) =
(
gasq_forall$f1un
<xs><x0>(GASQ_unmk<xs><x0>(gasq), test))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:vt >
GASQ_rforall$f1un
  (gasq, test) =
(
gasq_rforall$f1un
<xs><x0>(GASQ_unmk<xs><x0>(gasq), test))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:vt >
GASQ_exists$f1un
  (gasq, test) =
(
gasq_exists$f1un
<xs><x0>(GASQ_unmk<xs><x0>(gasq), test))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:vt >
GASQ_rexists$f1un
  (gasq, test) =
(
gasq_rexists$f1un
<xs><x0>(GASQ_unmk<xs><x0>(gasq), test))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
//
HX-2024-08-17:
Sat 17 Aug 2024 07:34:48 AM EDT
The following style seems to be a
superior alternative to introducing
templates like GASQ_foritm?
//
HX-2026-01-12:
Mon Jan 12 06:05:38 PM EST 2026
We still need to overload forithm with
gseq_foritm in order to use the following:
GASQ(xs).foritm(work)
I suggest for now we refrain from this
kind of overloading. I find the following
style is a bit verbose but informative:
gasq_foritm<xs><x0>(xs, work)
I have no big objection to this style at all.
//
*)
(* ****** ****** *)
(*
#impltmp
{ xs:t0
, x0:vt }
gasq_foritm
<GASQ(xs,x0)><x0>
 ( gasq ) =
gasq_foritm
<xs><x0>(GASQ_unmk<xs><x0>(gasq))
#impltmp
{ xs:t0
, x0:vt }
gasq_foritm$f1un
<GASQ(xs,x0)><x0>
 (gasq, test) =
gasq_foritm$f1un
<xs><x0>(GASQ_unmk<xs><x0>(gasq), test)
*)
(* ****** ****** *)
(*
#impltmp
{ xs:t0
, x0:vt }
gasq_rforitm
<GASQ(xs,x0)><x0>
 ( gasq ) =
gasq_rforitm
<xs><x0>(GASQ_unmk<xs><x0>(gasq))
#impltmp
{ xs:t0
, x0:vt }
gasq_rforitm$f1un
<GASQ(xs,x0)><x0>
 (gasq, test) =
gasq_rforitm$f1un
<xs><x0>(GASQ_unmk<xs><x0>(gasq), test)
*)
(* ****** ****** *)
(*
#impltmp
{ xs:t0
, x0:vt }
gasq_iforitm
<GASQ(xs,x0)><x0>
 ( gasq ) =
gasq_iforitm
<xs><x0>(GASQ_unmk<xs><x0>(gasq))
#impltmp
{ xs:t0
, x0:vt }
gasq_iforitm$f2un
<GASQ(xs,x0)><x0>
 (gasq, test) =
gasq_iforitm$f2un
<xs><x0>(GASQ_unmk<xs><x0>(gasq), test)
*)
(* ****** ****** *)
(*
#impltmp
{ xs:t0
, x0:vt }
gasq_irforitm
<GASQ(xs,x0)><x0>
 ( gasq ) =
gasq_irforitm
<xs><x0>(GASQ_unmk<xs><x0>(gasq))
#impltmp
{ xs:t0
, x0:vt }
gasq_irforitm$f2un
<GASQ(xs,x0)><x0>
 (gasq, test) =
gasq_irforitm$f2un
<xs><x0>(GASQ_unmk<xs><x0>(gasq), test)
*)
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-12:
Mon Jan 12 08:10:11 PM EST 2026
*)
//
#impltmp
< xs:t0 >
< x0:vt >
GASQ_foritm
  (gasq) =
(
gasq_foritm
<xs><x0>(GASQ_unmk<xs><x0>(gasq)))
//
#impltmp
< xs:t0 >
< x0:vt >
GASQ_rforitm
  (gasq) =
(
gasq_rforitm
<xs><x0>(GASQ_unmk<xs><x0>(gasq)))
//
#impltmp
< xs:t0 >
< x0:vt >
GASQ_iforitm
  (gasq) =
(
gasq_iforitm
<xs><x0>(GASQ_unmk<xs><x0>(gasq)))
//
#impltmp
< xs:t0 >
< x0:vt >
GASQ_irforitm
  (gasq) =
(
gasq_irforitm
<xs><x0>(GASQ_unmk<xs><x0>(gasq)))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:vt >
GASQ_foritm$f1un
  (gasq, test) =
(
gasq_foritm$f1un
<xs><x0>(GASQ_unmk<xs><x0>(gasq), test))
//
#impltmp
< xs:t0 >
< x0:vt >
GASQ_rforitm$f1un
  (gasq, test) =
(
gasq_rforitm$f1un
<xs><x0>(GASQ_unmk<xs><x0>(gasq), test))
//
#impltmp
< xs:t0 >
< x0:vt >
GASQ_iforitm$f2un
  (gasq, test) =
(
gasq_iforitm$f2un
<xs><x0>(GASQ_unmk<xs><x0>(gasq), test))
//
#impltmp
< xs:t0 >
< x0:vt >
GASQ_irforitm$f2un
  (gasq, test) =
(
gasq_irforitm$f2un
<xs><x0>(GASQ_unmk<xs><x0>(gasq), test))
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_gcls000.dats] *)
(***********************************************************************)
`,
  "DATS/gdbg000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon 05 Aug 2024 10:30:08 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
g_type
{t0:t0}(_) =
$UN.castxy(unit(*0*))
#impltmp
<(*tmp*)>
g_vwtp
{vt:vt}(_) =
$UN.castxy(unit(*0*))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< vt:vt >
g_psort() =
(
  strn_print("vwtp"))
#impltmp
< vx:vx >
g_psort() =
(
  strn_print("vtbx"))
#impltmp
< t0:t0 >
g_psort() =
(
  strn_print("type"))
#impltmp
< tx:tx >
g_psort() =
(
  strn_print("tbox"))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< vw:vw >
g_ptype() =
(
 strn_print("$typ(vw)"))
#impltmp
< pp:pp >
g_ptype() =
(
 strn_print("$typ(pp)"))
//
#impltmp
< vt:vt >
g_ptype() =
(
 strn_print("$typ(vt)"))
#impltmp
< vx:vx >
g_ptype() =
(
 strn_print("$typ(vx)"))
//
#impltmp
< t0:t0 >
g_ptype() =
(
 strn_print("$typ(t0)"))
#impltmp
< tx:tx >
g_ptype() =
(
 strn_print("$typ(tx)"))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< t0:t0 >
g_print(x0) =
( pstrn"$val("
; g_ptype<t0>(); pstrn":"
; g_psort<t0>(); pstrn")")
//
(* ****** ****** *)
//
#impltmp
< vt:vt >
g_print1(x0) =
( pstrn"$val("
; g_ptype<vt>(); pstrn":"
; g_psort<vt>(); pstrn")")
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
g_ptype
< sint >
( (*void*) ) = pstrn("sint")
#impltmp
g_ptype
< uint >
( (*void*) ) = pstrn("uint")
//
#impltmp
g_ptype
< bool >
( (*void*) ) = pstrn("bool")
#impltmp
g_ptype
< char >
( (*void*) ) = pstrn("char")
//
#impltmp
g_ptype
< strn >
( (*void*) ) = pstrn("strn")
//
#impltmp
g_ptype
< sflt >
( (*void*) ) = pstrn("sflt")
#impltmp
g_ptype
< dflt >
( (*void*) ) = pstrn("dflt")
//
(* ****** ****** *)
//
#impltmp
{ t0:t0 }
g_ptcon
<list(t0)>
( (*void*) ) =
(
pstrn("list"))
#impltmp
{ t0:t0 }
g_ptype
<list(t0)>
( (*void*) ) =
(
pstrn("list(");
g_ptype<t0>((*0*)); pstrn(")"))
//
#impltmp
{ t0:t0 }
g_ptcon
<optn(t0)>
( (*void*) ) =
(
pstrn("optn"))
#impltmp
{ t0:t0 }
g_ptype
<optn(t0)>
( (*void*) ) =
(
pstrn("optn(");
g_ptype<t0>((*0*)); pstrn(")"))
//
#impltmp
{ t0:t0 }
g_ptcon
<strm(t0)>
( (*void*) ) =
(
pstrn("strm"))
#impltmp
{ t0:t0 }
g_ptype
<strm(t0)>
( (*void*) ) =
(
pstrn("strm(");
g_ptype<t0>((*0*)); pstrn(")"))
//
#impltmp
{ t0:t0 }
g_ptcon
<strx(t0)>
( (*void*) ) =
(
pstrn("strx"))
#impltmp
{ t0:t0 }
g_ptype
<strx(t0)>
( (*void*) ) =
(
pstrn("strx(");
g_ptype<t0>((*0*)); pstrn(")"))
//
(* ****** ****** *)
//
#impltmp
{ vt:vt }
g_ptcon
<list_vt(vt)>
( (*void*) ) =
(
pstrn("list_vt("))
#impltmp
{ vt:vt }
g_ptype
<list_vt(vt)>
( (*void*) ) =
(
pstrn("list_vt(");
g_ptype<vt>((*0*)); pstrn(")"))
//
#impltmp
{ vt:vt }
g_ptcon
<optn_vt(vt)>
( (*void*) ) =
(
pstrn("optn_vt("))
#impltmp
{ vt:vt }
g_ptype
<optn_vt(vt)>
( (*void*) ) =
(
pstrn("optn_vt(");
g_ptype<vt>((*0*)); pstrn(")"))
//
#impltmp
{ vt:vt }
g_ptcon
<strm_vt(vt)>
( (*void*) ) =
(
pstrn("strm_vt("))
#impltmp
{ vt:vt }
g_ptype
<strm_vt(vt)>
( (*void*) ) =
(
pstrn("strm_vt(");
g_ptype<vt>((*0*)); pstrn(")"))
//
#impltmp
{ vt:vt }
g_ptcon
<strx_vt(vt)>
( (*void*) ) =
(
pstrn("strx_vt("))
#impltmp
{ vt:vt }
g_ptype
<strx_vt(vt)>
( (*void*) ) =
(
pstrn("strx_vt(");
g_ptype<vt>((*0*)); pstrn(")"))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-06:
Tue 06 Aug 2024 07:17:33 AM EDT
*)
//
#impltmp
{ vw:vw }
g_print
<type(vw)>(_(*0*)) =
(
g_ptype<vw>((*void*));
pstrn":";g_psort<vw>((*void*)))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
//
(*
//
HX-2026-01-06:
HX-2026-01-07:
Should be implemented locally!
Tue Jan  6 11:19:12 PM EST 2026
*)
//
#impltmp
< x0:vt >
g_debug(x0) =
(
  x0 ) where
{
val () =
(
  g_print1<x0>(x0); println())
}(*where*)//end-of-[g_debug(x0)]
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_prlen((*void*)) = 10(*default*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
assert$errmsg() =
"gdbg000: [assert] failed!"
//
#impltmp
<(*tmp*)>
bool_assert(cond) =
let
val emsg =
assert$errmsg<>() in//let
(
  bool_assert$errmsg<>(cond, emsg))
end(*let*)//end-of-[bool_assert(cond)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_gdbg000.dats] *)
(***********************************************************************)
`,
  "DATS/gflt000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon 09 Sep 2024 06:17:35 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
#typedef ni = nint
#typedef si = sint
#typedef df = dflt
(* ****** ****** *)
(* ****** ****** *)
#impltmp
g_0<df>() = (0.0)
#impltmp
g_1<df>() = (1.0)
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
g_lt<df> = dflt_lt$dflt<>
#impltmp
g_gt<df> = dflt_gt$dflt<>
#impltmp
g_eq<df> = dflt_eq$dflt<>
//
#impltmp
g_lte<df> = dflt_lte$dflt<>
#impltmp
g_gte<df> = dflt_gte$dflt<>
#impltmp
g_neq<df> = dflt_neq$dflt<>
//
#impltmp
g_cmp<df> = dflt_cmp$dflt<>
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
g_add<df> = dflt_add$dflt<>
#impltmp
g_sub<df> = dflt_sub$dflt<>
#impltmp
g_mul<df> = dflt_mul$dflt<>
#impltmp
g_div<df> = dflt_div$dflt<>
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
g_print<df> = dflt_print<>
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
dflt_lt$sint
  (f1, i2) =
dflt_lt$dflt(f1, g_si<dflt>(i2))
#impltmp
<(*tmp*)>
dflt_gt$sint
  (f1, i2) =
dflt_gt$dflt(f1, g_si<dflt>(i2))
#impltmp
<(*tmp*)>
dflt_eq$sint
  (f1, i2) =
dflt_eq$dflt(f1, g_si<dflt>(i2))
//
#impltmp
<(*tmp*)>
dflt_lte$sint
  (f1, i2) =
dflt_lte$dflt(f1, g_si<dflt>(i2))
#impltmp
<(*tmp*)>
dflt_gte$sint
  (f1, i2) =
dflt_gte$dflt(f1, g_si<dflt>(i2))
#impltmp
<(*tmp*)>
dflt_neq$sint
  (f1, i2) =
dflt_neq$dflt(f1, g_si<dflt>(i2))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
dflt_neg( f1 ) = (0.0-f1)
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
dflt_abs( f1 ) =
if
(f1 >= 0.0)
then f1 else dflt_neg<>(f1)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
dflt_suc( f1 ) = (f1+1.0)
#impltmp
<(*tmp*)>
dflt_pre( f1 ) = (f1-1.0)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
dflt_sqr( f1 ) = (f1*f1)
#impltmp
<(*tmp*)>
dflt_cbr( f1 ) = (f1*f1*f1)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
dflt_add$sint
  (f1, i2) =
dflt_add$dflt(f1, g_si<dflt>(i2))
#impltmp
<(*tmp*)>
dflt_sub$sint
  (f1, i2) =
dflt_sub$dflt(f1, g_si<dflt>(i2))
//
#impltmp
<(*tmp*)>
dflt_mul$sint
  (f1, i2) =
dflt_mul$dflt(f1, g_si<dflt>(i2))
#impltmp
<(*tmp*)>
dflt_div$sint
  (f1, i2) =
dflt_div$dflt(f1, g_si<dflt>(i2))
//
#impltmp
<(*tmp*)>
dflt_mod$sint
  (f1, i2) =
dflt_mod$dflt(f1, g_si<dflt>(i2))
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
sint_add$dflt
  (i1, f2) =
dflt_add$dflt(g_si<dflt>(i1), f2)
#impltmp
<(*tmp*)>
sint_sub$dflt
  (i1, f2) =
dflt_sub$dflt(g_si<dflt>(i1), f2)
//
#impltmp
<(*tmp*)>
sint_mul$dflt
  (i1, f2) =
dflt_mul$dflt(g_si<dflt>(i1), f2)
#impltmp
<(*tmp*)>
sint_div$dflt
  (i1, f2) =
dflt_div$dflt(g_si<dflt>(i1), f2)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_gflt000.dats] *)
(***********************************************************************)
`,
  "DATS/gfun000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Tue 06 Aug 2024 05:59:23 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#typedef ni = nint
#typedef si = sint
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ r0:vt }
g_ptype
<f0un(r0)>
(  (*void*)  ) =
( pstrn"f0un("
; g_ptype<r0>(); pstrn(")"))
//
#impltmp
{ a1:t0 }
{ r0:vt }
g_ptype
<f1un(a1,r0)>
(  (*void*)  ) =
( pstrn"f1un("
; g_ptype<a1>(); pstrn(";")
; g_ptype<r0>(); pstrn(")"))
//
#impltmp
{ a1:t0
, a2:t0 }
{ r0:vt }
g_ptype
<
f2un(a1,a2,r0)
>
(  (*void*)  ) =
( pstrn"f2un("
; g_ptype<a1>(); pstrn(",")
; g_ptype<a2>(); pstrn(";")
; g_ptype<r0>(); pstrn(")"))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<a1:t0>
f1un_not
(    f0    ) =
(
  lam(x1:a1) => not(f0(x1)) )
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
f0un_nint$repeat
(f0, times) =
nint_foritm(times) where
{
#impltmp
foritm$work<ni>(_) = f0((*void*))
}(*where*)//end(f0un_nint$repeat(f0))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-24:
Sat 24 Aug 2024 06:29:59 PM EDT
*)
//
#impltmp
< r0:vt >
f0un_trace
 (f00, msg) =
lam((*0*)) => let
//
val () =
prints(msg, ":", "\\n")
//
val r0 = f00(              )
//
val () = print1s
(msg, ": res0 = ", r0, "\\n") in r0 end
//
(* ****** ****** *)
//
#impltmp
< a1:t0 >
< r0:vt >
f1un_trace
 (f00, msg) =
lam(x1:a1) => let
//
val () = prints
(msg, ": arg1 = ", x1, "\\n")
//
val r0 = f00(      x1      )
//
val () = print1s
(msg, ": res0 = ", r0, "\\n") in r0 end
//
(* ****** ****** *)
//
#impltmp
< a1:t0 >
< a2:t0 >
< r0:vt >
f2un_trace
 (f00, msg) =
lam
(x1:a1,x2:a2) => let
//
val () = prints
(msg, ": arg1 = ", x1, "\\n")
val () = prints
(msg, ": arg2 = ", x2, "\\n")
//
val r0 = f00(    x1, x2    )
//
val () = print1s
(msg, ": res0 = ", r0, "\\n") in r0 end
//
(* ****** ****** *)
//
#impltmp
< a1:t0 >
< a2:t0 >
< a3:t0 >
< r0:vt >
f3un_trace
 (f00, msg) =
lam
(x1:a1
,x2:a2,x3:a3) => let
//
val () = prints
(msg, ": arg1 = ", x1, "\\n")
val () = prints
(msg, ": arg2 = ", x2, "\\n")
val () = prints
(msg, ": arg3 = ", x3, "\\n")
//
val r0 = f00(  x1, x2, x3  )
//
val () = print1s
(msg, ": res0 = ", r0, "\\n") in r0 end
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-31:
Sat 31 Aug 2024 10:36:59 AM EDT
*)
//
#impltmp
< a1:t0 >
< a2:t0 >
< a3:t0 >
< a4:t0 >
< r0:vt >
f4un_trace
 (f00, msg) =
lam
(x1:a1,x2:a2
,x3:a3,x4:a4) => let
//
val () = prints
(msg, ": arg1 = ", x1, "\\n")
val () = prints
(msg, ": arg2 = ", x2, "\\n")
val () = prints
(msg, ": arg3 = ", x3, "\\n")
val () = prints
(msg, ": arg4 = ", x4, "\\n")
//
val r0 = f00(x1, x2, x3, x4)
//
val () = print1s
(msg, ": res0 = ", r0, "\\n") in r0 end
//
(* ****** ****** *)
//
#impltmp
< a1:t0 >
< a2:t0 >
< a3:t0 >
< a4:t0 >
< a5:t0 >
< r0:vt >
f5un_trace
 (f00, msg) =
lam
(x1:a1
,x2:a2,x3:a3
,x4:a4,x5:a5) => let
//
val () = prints
(msg, ": arg1 = ", x1, "\\n")
val () = prints
(msg, ": arg2 = ", x2, "\\n")
val () = prints
(msg, ": arg3 = ", x3, "\\n")
val () = prints
(msg, ": arg4 = ", x4, "\\n")
val () = prints
(msg, ": arg5 = ", x5, "\\n")
//
val r0 =
(
  f00(x1 , x2 , x3 , x4 , x5))
//
val () =
print1s(msg, ": res0 = ", r0, "\\n") in r0 end
//
(* ****** ****** *)
//
#impltmp
< a1:t0 >
< a2:t0 >
< a3:t0 >
< a4:t0 >
< a5:t0 >
< a6:t0 >
< r0:vt >
f6un_trace
 (f00, msg) =
lam
(x1:a1,x2:a2
,x3:a3,x4:a4
,x5:a5,x6:a6) => let
//
val () = prints
(msg, ": arg1 = ", x1, "\\n")
val () = prints
(msg, ": arg2 = ", x2, "\\n")
val () = prints
(msg, ": arg3 = ", x3, "\\n")
val () = prints
(msg, ": arg4 = ", x4, "\\n")
val () = prints
(msg, ": arg5 = ", x5, "\\n")
val () = prints
(msg, ": arg6 = ", x6, "\\n")
//
val r0 =
(
  f00(x1, x2, x3, x4, x5, x6))
//
val () =
print1s(msg, ": res0 = ", r0, "\\n") in r0 end
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-05-29:
Thu May 29 05:22:09 PM EDT 2025
*)
//
#impltmp
< x0:t0 >
< y0:t0 >
f1un_map$list
  ( fopr ) =
lam(xs) =>
list_map$f1un<x0><y0>(xs, fopr)
//
#impltmp
< x0:t0 >
< y0:t0 >
f1un_map0$llist
  ( fopr ) =
lam(xs) =>
list_vt_map0$f1un<x0><y0>(xs, fopr)
//
#impltmp
< x0:t0 >
< y0:t0 >
f1un_map1$llist
  ( fopr ) =
lam(xs) =>
list_vt_map1$f1un<x0><y0>(xs, fopr)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:t0 >
< y0:t0 >
f1un_map$optn
  ( fopr ) =
lam(xs) =>
optn_map$f1un<x0><y0>(xs, fopr)
//
#impltmp
< x0:t0 >
< y0:t0 >
f1un_map0$loptn
  ( fopr ) =
lam(xs) =>
optn_vt_map0$f1un<x0><y0>(xs, fopr)
//
#impltmp
< x0:t0 >
< y0:t0 >
f1un_map1$loptn
  ( fopr ) =
lam(xs) =>
optn_vt_map1$f1un<x0><y0>(xs, fopr)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-06-01:
Sun Jun  1 05:34:50 PM EDT 2025
*)
//
#impltmp
< x0:t0 >
< y0:t0 >
< e1:vt >
f1un_map$e1nv$list
  ( fopr ) =
lam(xs, e1) =>
list_map$e1nv$f2un<x0><y0><e1>(xs, e1, fopr)
//
#impltmp
< x0:vt >
< y0:vt >
< e1:vt >
f1un_map$e1nv0$llist
  ( fopr ) =
lam(xs, e1) =>
list_vt_map$e1nv0$f2un<x0><y0><e1>(xs, e1, fopr)
#impltmp
< x0:vt >
< y0:vt >
< e1:vt >
f1un_map$e1nv1$llist
  ( fopr ) =
lam(xs, e1) =>
list_vt_map$e1nv1$f2un<x0><y0><e1>(xs, e1, fopr)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:t0 >
< y0:t0 >
< e1:vt >
f1un_map$e1nv$optn
  ( fopr ) =
lam(xs, e1) =>
optn_map$e1nv$f2un<x0><y0><e1>(xs, e1, fopr)
//
#impltmp
< x0:vt >
< y0:vt >
< e1:vt >
f1un_map$e1nv0$loptn
  ( fopr ) =
lam(xs, e1) =>
optn_vt_map$e1nv0$f2un<x0><y0><e1>(xs, e1, fopr)
#impltmp
< x0:vt >
< y0:vt >
< e1:vt >
f1un_map$e1nv1$loptn
  ( fopr ) =
lam(xs, e1) =>
optn_vt_map$e1nv1$f2un<x0><y0><e1>(xs, e1, fopr)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-14:
Wed Jan 14 12:44:51 PM EST 2026
*)
//
#impltmp
< r0:vt >
strx_vt_iter$make
  (fopr, r0) =
(
  auxloop(fopr, r0))
where{
//
fun
auxloop
( fopr
: (!r0)->r0, r0: r0) = $llazy
(
let
val r1 = fopr(r0) in//let
strxcon_vt_cons(r0, auxloop(fopr, r1))end)
//
}(*where*)//end-of-[strx_vt_iter$make(fopr,r0)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-15:
Thu Jan 15 07:44:43 PM EST 2026
*)
//
#impltmp
< x0:vt >
f0un_enum$make_strx_vt
  (  xs  ) =
let
//
#vwtpdef
xs = strx_vt(x0)
//
val rf = a0rf_vt<xs>(xs)
//
in//let
//
lam() =>
let
val xs =
(
  a0rf_vt_lget(rf))//val
in//let
(
  a0rf_vt_lset(rf, xs); x0)
where
{
val+
strxcon_vt_cons(x0, xs) = !xs }
end(*let*)//end-of-(lam() => ...)
//
end(*let*)//end-of-[f0un_enum$make_strx_vt(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-15:
Thu Jan 15 07:44:43 PM EST 2026
*)
//
#impltmp
< x0:vt >
f0un_enum$make_strm_vt
  (  xs  ) =
let
//
#vwtpdef
cs = strmcon_vt(x0)
//
val rf = a0rf_vt<cs>(!xs)
//
in//let
//
lam() =>
let
val cs =
(
  a0rf_vt_lget(rf))//(val)
in//let
case+ cs of
|
strmcon_vt_nil
(  (*void*)  ) =>
(
optn_vt_nil((*0*)))
where
{
// HX: this is redundant!!!
val () = a0rf_vt_lset(rf, cs) }
| ~
strmcon_vt_cons
(   x0, xs   ) =>
(
optn_vt_cons( x0 )) where
{
val () = a0rf_vt_lset(rf, !xs) }
end(*let*)//end-of-(lam() => ...)
//
end(*let*)//end-of-[f0un_enum$make_strm_vt(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_gfun000.dats] *)
(***********************************************************************)
`,
  "DATS/gint000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Fri 12 Jul 2024 11:29:01 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
#typedef ni = nint
#typedef si = sint
#typedef ut = unit
(* ****** ****** *)
(* ****** ****** *)
#impltmp
g_0<si>() = ( 0 )
#impltmp
g_1<si>() = ( 1 )
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
g_si<si>(i0) = (i0)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
g_lt<si> = sint_lt$sint<>
#impltmp
g_gt<si> = sint_gt$sint<>
#impltmp
g_eq<si> = sint_eq$sint<>
//
#impltmp
g_lte<si> = sint_lte$sint<>
#impltmp
g_gte<si> = sint_gte$sint<>
#impltmp
g_neq<si> = sint_neq$sint<>
//
(* ****** ****** *)
//
#impltmp
g_cmp<si> = sint_cmp$sint<>
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
g_add<si> = sint_add$sint<>
#impltmp
g_sub<si> = sint_sub$sint<>
#impltmp
g_mul<si> = sint_mul$sint<>
#impltmp
g_div<si> = sint_div$sint<>
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
g_print<si> = sint_print<>
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
sint_neg( i1 ) = ( 0 - i1 )
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
sint_suc( i1 ) = ( i1 + 1 )
#impltmp
<(*tmp*)>
sint_pre( i1 ) = ( i1 - 1 )
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
sint_abs( i1 ) =
(
if i1 >= 0 then i1 else -i1)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
sint_cmp$sint
  (i1, i2) =
(
if
(i1 < i2) then -1 else
(if (i1 > i2) then 1 else 0))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
gasq_length<ni><ut>(ni) = (ni)
#impltmp
gseq_length<ni><ut>(ni) = (ni)
//
#impltmp
gasq_length<ni><ni>(ni) = (ni)
#impltmp
gseq_length<ni><ni>(ni) = (ni)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-07:
For some unsafe stuff:
Wed 07 Aug 2024 03:56:12 PM EDT
*)
//
#impltmp
$UN.gasq_get$at$raw
< nint >< unit >(ni, i0) = unit
#impltmp
$UN.gasq_lget$at$raw
< nint >< unit >(ni, i0) =
let
pvx pf =
owed_t0_make{unit}() in (pf|unit) end
//let//end($UN.gasq_get$at$raw<strn><cgtz>)
//
(* ****** ****** *)
//
#impltmp
$UN.gasq_get$at$raw
< nint >< nint >(ni, i0) = (i0)
#impltmp
$UN.gasq_lget$at$raw
< nint >< nint >(ni, i0) =
let
pvx pf =
owed_t0_make{nint}() in (pf|(i0)) end
//let//end($UN.gasq_get$at$raw<strn><cgtz>)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2016-01-05:
Mon Jan  5 01:22:47 AM EST 2026
*)
#impltmp
g_equal<si> = sint_eq$sint<(*0*)>(*i1,i2*)
#impltmp
g_noteq<si> = sint_neq$sint<(*0*)>(*i1,i2*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_gint000.dats] *)
(***********************************************************************)
`,
  "DATS/gint001.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Fri 12 Jul 2024 11:29:01 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#typedef ut = unit
#typedef ni = nint
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
gseq_forall
<nint><ut>(ni) =
(
nint_forall(ni)) where
{
#impltmp
forall$test<ni>(i0) = 
(
forall$test<ut>(unit()))}//where
//
#impltmp
gasq_forall
<nint><ut>(ni) =
(
nint_forall(ni)) where
{
#impltmp
forall$test<ni>(i0) = 
(
forall$test1<ut>(unit()))}//where
//
(* ****** ****** *)
//
#impltmp
gseq_rforall
<nint><ut>(ni) =
(
nint_rforall(ni)) where
{
#impltmp
rforall$test<ni>(i0) = 
(
rforall$test<ut>(unit()))}//where
//
#impltmp
gasq_rforall
<nint><ut>(ni) =
(
nint_rforall(ni)) where
{
#impltmp
rforall$test<ni>(i0) = 
(
rforall$test1<ut>(unit()))}//where
//
(* ****** ****** *)
//
#impltmp
gseq_iforall
<nint><ut>(ni) =
(
nint_forall(ni)) where
{
#impltmp
forall$test<ni>(i0) =
(
iforall$test<ut>(i0,unit()))}//whr
//
#impltmp
gasq_iforall
<nint><ut>(ni) =
(
nint_forall(ni)) where
{
#impltmp
forall$test<ni>(i0) =
(
iforall$test1<ut>(i0,unit()))}//whr
//
(* ****** ****** *)
//
#impltmp
gseq_irforall
<nint><ut>(ni) =
(
nint_rforall(ni)) where
{
#impltmp
rforall$test<ni>(i0) =
(
irforall$test<ut>(i0,unit()))}//whr
//
#impltmp
gasq_irforall
<nint><ut>(ni) =
(
nint_rforall(ni)) where
{
#impltmp
rforall$test<ni>(i0) =
(
irforall$test1<ut>(i0,unit()))}//whr
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
nint_forall(xs) =
loop(xs, 0(*i0*)) where
{
fun
loop
(xs: ni, i0: ni): bool =
if
(i0 >= xs)
then (true) else
(
if
forall$test<ni>(i0)
then loop(xs, i0+1) else false)}
//
#impltmp
gasq_forall
<nint><ni>(ni) =
(
  nint_forall<>(ni)) where
{
#impltmp
forall$test<ni> = forall$test1<ni>
}
//
#impltmp
gseq_forall<nint><ni> = nint_forall<>
//
(* ****** ****** *)
//
#impltmp
<>(*tmp*)
nint_forall$f1un
  (ni, test) =
(
  nint_forall<>(ni)) where
{
#impltmp
forall$test<ni>(i0) = test(   i0   )
}(*where*)//end-of-[nint_forall$f1un]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
nint_rforall(xs) =
loop(xs, 0(*i0*)) where
{
fun
loop
(xs: ni, i0: ni): bool =
if
(i0 >= xs)
then (true) else
(
if
rforall$test<ni>(xs-1-i0)
then loop(xs, i0+1) else false)}
//
#impltmp
gasq_rforall
<nint><ni>(ni) =
(
  nint_rforall<>(ni)) where
{
#impltmp
rforall$test<ni> = rforall$test1<ni>
}
//
(* ****** ****** *)
//
#impltmp
<>(*tmp*)
nint_rforall$f1un
  (ni, test) =
(
  nint_rforall<>(ni)) where
{
#impltmp
rforall$test<ni>(i0) = test(   i0   )
}(*where*)//end-of-[nint_rforall$f1un]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<>(*tmp*)
nint_foritm =
gseq_foritm<nint><ni>(*void*)
#impltmp
<>(*tmp*)
nint_foritm$f1un
  (cs, work) =
(
  nint_foritm<>(cs)) where
{
#impltmp
foritm$work<ni>(i0) = work(   i0   )
}(*where*)//end-of-[nint_foritm$f1un]
//
(* ****** ****** *)
//
#impltmp
<>(*tmp*)
nint_rforitm =
gseq_rforitm<nint><ni>(*void*)
#impltmp
<>(*tmp*)
nint_rforitm$f1un
  (cs, work) =
(
  nint_rforitm<>(cs)) where
{
#impltmp
rforitm$work<ni>(i0) = work(   i0   )
}(*where*)//end-of-[nint_rforitm$f1un]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-22:
Mon 22 Jul 2024 09:02:06 AM EDT
*)
//
(*
#impltmp
<(*tmp*)>
nint_strmize(ni) =
(
  auxmain(0)) where
{
fun
auxmain
(i0: nint):
strm_vt(ni) = $llazy
(
if
(i0 >= ni)
then strmcon_vt_nil() else
strmcon_vt_cons(i0, auxmain(i0+1))
)
}(*where*)//end-[nint_strmize(ni)]
*)
//
(* ****** ****** *)
//
(*
HX-2024-07-22:
Mon 22 Jul 2024 11:48:37 AM EDT
*)
#impltmp
<(*tmp*)>
nint_strmize(ni) =
(
nint_map_lstrm<ni>(ni))
where
{
#impltmp
map$fopr<ni><ni>(i0) = (i0)
}(*where*)//end-[nint_strmize(ni)]
//
#impltmp
<(*tmp*)>
nint_strqize(ni) =
(
 $UN.strm2q_vt(nint_strmize<>(ni)))
//
(* ****** ****** *)
(* ****** ****** *)
(*
HX-2024-08-07:
Wed 07 Aug 2024 08:46:10 AM EDT
*)
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
nint_rstrmize(ni) =
(
nint_rmap_lstrm<ni>(ni))
where
{
#impltmp
rmap$fopr<ni><ni>(i0) = (i0)
}(*where*)//end-[nint_rstrmize(ni)]
//
#impltmp
<(*tmp*)>
nint_rstrqize(ni) =
(
 $UN.strm2q_vt(nint_rstrmize<>(ni)))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-22:
Mon 22 Jul 2024 11:48:37 AM EDT
*)
//
#impltmp
< y0:vt >
nint_map_lstrm
  ( ni ) =
(
  auxmain(0)) where
{
fun
auxmain
(i0: nint):
strm_vt(y0) = $llazy
(
if
(i0 >= ni)
then strmcon_vt_nil() else
let
val y0 =
map$fopr<ni><y0>(i0) in//let
strmcon_vt_cons(y0, auxmain(i0+1))
end(*let*)//else//end-of-[if]
)
}(*where*)//end-[nint_map_lstrm(ni)]
//
#impltmp
< y0:vt >
nint_map$f1un_lstrm
  (ni, fopr) =
(
nint_map_lstrm<y0>(ni))
where
{ #impltmp
  map$fopr<ni><y0>(i0) = fopr( i0 )
}(*where*)//end-[nint_map$f1un_lstrm]
//
(* ****** ****** *)
//
#impltmp
< y0:vt >
nint_rmap_lstrm
  ( ni ) =
(
  auxmain(ni)) where
{
fun
auxmain
(i0: nint):
strm_vt(y0) = $llazy
(
if
(i0 <= 0)
then strmcon_vt_nil() else
let
val y0 =
rmap$fopr<ni><y0>(i0-1) in//let
(
 strmcon_vt_cons(y0, auxmain(i0-1)))
end(*let*)//else//end-of-[if]
)
}(*where*)//end-[nint_rmap_lstrm(ni)]
//
#impltmp
< y0:vt >
nint_rmap$f1un_lstrm
  (ni, fopr) =
(
nint_rmap_lstrm<y0>(ni))
where
{ #impltmp
  rmap$fopr<ni><y0>(i0) = fopr( i0 )
}(*where*)//end-[nint_rmap$f1un_lstrm]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-28:
Sun 28 Jul 2024 02:03:24 PM EDT
*)
//
(* ****** ****** *)
//
#impltmp
< y0:t0 >
nint_map_list
  ( ni ) =
(
list_vt2t(
nint_map_llist<y0>(ni)))
//
#impltmp
< y0:t0 >
nint_map$f1un_list
  (ni, f0) =
(
list_vt2t(
nint_map$f1un_llist<y0>(ni, f0)))
//
(* ****** ****** *)
//
#impltmp
< y0:vt >
nint_map_llist
  ( ni ) =
(
list_vt_reverse0
<y0>(loop(0, r0)))
where
{
//
#vwtpdef
ys = list_vt(y0)
//
val
r0 = list_vt_nil()
//
fun
loop
(i0: ni, r0: ys): ys =
(
if
(i0 >= ni)
then r0 else
let
val y0 = map$fopr<ni><y0>(i0)
in//let
(
loop(i0+1, list_vt_cons(y0, r0)))
end(*let*)//else//end-of-[if(...)]
)
//
}(*where*)//end-[nint_map_llist(ni)]
//
#impltmp
< y0:vt >
nint_map$f1un_llist
  (ni, fopr) =
(
nint_map_llist
<  y0  >(  ni  )) where
{
#impltmp
map$fopr<ni><y0>( i0 ) = fopr( i0 )
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< y0:vt >
nint_rmap_llist
  ( ni ) =
(
list_vt_reverse0
<y0>(loop(ni, r0)))
where
{
//
#vwtpdef
ys = list_vt(y0)
//
val
r0 = list_vt_nil()
//
fun
loop
(i0: ni, r0: ys): ys =
(
if
(i0 <= 0)
then r0 else
let
val y0 = rmap$fopr<ni><y0>(i0-1)
in//let
  loop(i0-1, list_vt_cons(y0,r0))
end(*let*)//else//end-of-[if(...)]
)
//
}(*where*)//end-[nint_map_llist(ni)]
//
#impltmp
< y0:vt >
nint_rmap$f1un_llist
  (ni, fopr) =
(
nint_rmap_llist
<  y0  >(  ni  )) where
{
#impltmp
rmap$fopr<ni><y0>( i0 ) = fopr( i0 )
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
gasq_strmize<nint><ni> = nint_strmize<>
#impltmp
gasq_strqize<nint><ni> = nint_strqize<>
//
#impltmp
gseq_strmize<nint><ni> = gasq_strmize<nint><ni>
#impltmp
gseq_strqize<nint><ni> = gasq_strqize<nint><ni>
//
(* ****** ****** *)
//
#impltmp
gasq_rstrmize<nint><ni> = nint_rstrmize<>
#impltmp
gasq_rstrqize<nint><ni> = nint_rstrqize<>
//
#impltmp
gseq_rstrmize<nint><ni> = gasq_rstrmize<nint><ni>
#impltmp
gseq_rstrqize<nint><ni> = gasq_rstrqize<nint><ni>
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-01-12:
Sun Jan 12 10:08:30 AM EST 2025
*)
//
#impltmp
< r0:vt >
nint_folditm =
gseq_folditm<nint><ni><r0>(*void*)
#impltmp
< r0:vt >
nint_rfolditm =
gseq_rfolditm<nint><ni><r0>(*void*)
//
(* ****** ****** *)
//
#impltmp
< r0:vt >
nint_folditm$f2un =
gseq_folditm$f2un<nint><ni><r0>(*void*)
#impltmp
< r0:vt >
nint_rfolditm$f2un =
gseq_rfolditm$f2un<nint><ni><r0>(*void*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-27:
Sat Dec 27 12:37:56 PM EST 2025
*)
//
#impltmp
<(*tmp*)>
nint_listize(ni) =
(
  auxloop(ni, rs)
) where
{
//
#vwtpdef
rs = list_vt(nint)
//
val
rs: rs = list_vt_nil()
//
fun
auxloop
(ni: ni, rs: rs): rs =
(
if
(ni <= 0)
then ( rs ) else
(
  auxloop(ni, rs)) where
{
val ni = ni-1
val rs = list_vt_cons(ni, rs)}
)
}(*where*)//end-of-[nint_listize(ni)]
//
#impltmp
<(*tmp*)>
nint_rlistize(ni) =
(
  auxloop(i0, rs)
) where
{
//
#vwtpdef
rs = list_vt(nint)
//
val
i0: ni = (   0   )
val
rs: rs = list_vt_nil()
//
fun
auxloop
(i0: ni, rs: rs): rs =
(
if
(i0 >= ni)
then ( rs ) else
(
  auxloop(i0+1, rs)) where
{
val rs = list_vt_cons(i0, rs)}
)
}(*where*)//end-of-[nint_rlistize(ni)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_gint001.dats] *)
(***********************************************************************)
`,
  "DATS/gmap000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sun 08 Sep 2024 12:39:45 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< m0:vt >
< k0:vt >
< x0:vt >
gmap_sep((*void*)) = ","
#impltmp
< m0:vt >
< k0:vt >
< x0:vt >
gmap_end((*void*)) = "}"
#impltmp
< m0:vt >
< k0:vt >
< x0:vt >
gmap_beg((*void*)) = "gmap{"
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
#impltmp
< m0:t0 >
< k0:t0 >
< x0:t0 >
gmap_keyq
(map, k0) =
gseq_exists0
<strm_vt(k0)><x0>
(
gmap_key$strmize
<m0><k0><x0>(map)) where
{
#impltmp
exists$test0
< k0 >( k1 ) = g_equal<k0>(k0, k1)
}(*where*)//end-of-[gmap_keyq(map,k0)]
*)
#impltmp
< m0:t0 >
< k0:t0 >
< x0:t0 >
gmap_keyq
(map, k0) =
gmap_search$tst<m0><k0><x0>(map, k0)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-27:
Sat Dec 27 08:54:59 AM EST 2025
*)
//
#impltmp
< m0:t0 >
< k0:t0 >
< x0:t0 >
gmap_get$at
  (map, k0) =
(
case+ opt of
| ~
optn_vt_cons(itm) => itm)
where
{
val opt =
gmap_get$at$opt<m0><k0><x0>(map, k0)
}(*where*)//end-of-[gmap_get$at(...)]
//
#impltmp
< m0:t0 >
< k0:t0 >
< x0:t0 >
gmap_get$at$opt
  (map, k0) =
(
gmap_search$opt<m0><k0><x0>(map, k0))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
#impltmp
< m0:t0 >
< k0:t0 >
< x0:t0 >
gmap_search$tst
  (map, k0) =
let
//
#typedef
kx = @(k0, x0)
//
in//let
//
gseq_consq0
<strm_vt(kx)><kx>
(
strm_vt_filter0<kx>
(
let
#impltmp
filter$test
< kx >( kx ) =
(
  g_equal<k0>(k0, kx.0))
in//let
  gseq_strmize<m0><(k0,x0)>(map)end))
//
end//let//end-of-[gmap_search$tst(map,k0)]
*)
//
#impltmp
< m0:t0 >
< k0:t0 >
< x0:t0 >
gmap_search$tst
  (map, k0) =
(
case+ opt0 of
| ~
optn_vt_nil() => false
| ~
optn_vt_cons(x0) => true)
where
{
val opt0 =
gmap_search$opt<m0><k0><x0>(map, k0)
}(*where*)//end-of-[gmap_search$tst(map,k0)]
//
(* ****** ****** *)
//
#impltmp
< m0:t0 >
< k0:t0 >
< x0:t0 >
gmap_search$opt
  (map, k0) =
(
case+ opt0 of
| ~
optn_vt_nil
( (*void*) ) => optn_vt_nil()
| ~
optn_vt_cons
(    kx    ) => optn_vt_cons(kx.1)
) where
{
//
#typedef
kx = (k0, x0)
//
val opt0 =
gseq_head$opt0
<strm_vt(kx)><kx>
(
strm_vt_filter0<kx>
(
let
#impltmp
filter$test
< kx >( kx ) =
(
  g_equal<k0>(k0, kx.0))
in//let
  gseq_strmize<m0><(k0,x0)>(map)end))
//
}(*where*)//end-of-[gmap_search$opt(map,k0)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< m0:t0 >
< k0:t0 >
< x0:t0 >
gmap_insert$new
( map, k0, x0 ) =
(
case+ opt of
| ~
optn_vt_nil() => map
) where{
val (map, opt) =
(
gmap_insert$opt<m0><k0><x0>(map, k0, x0))
}(*where*)//end-of-[gmap_insert$new(map,...)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< m0:t0 >
< k0:t0 >
< x0:t0 >
gmap_getout$old
  (map, k0) =
(
case+ opt of
| ~
optn_vt_cons(x0) => (map, x0))
where{
val (map, opt) =
(
  gmap_getout$opt<m0><k0><x0>( map, k0 ))
}(*where*)//end-of-[gmap_getout$old(map,...)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_gmap000.dats] *)
(***********************************************************************)
`,
  "DATS/gmap001.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sun 08 Sep 2024 02:06:44 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<map:t0>
<key:t0>
<itm:t0>
gmap_key$strmize
  ( map ) =
let
//
val kxs =
(
gmap_keyval$strmize
< map >< key >< itm >(map))
//
in//let
(
strm_vt_map0<kx>(kxs)) where
{
#vwtpdef kx = (key,itm)
#impltmp map$fopr0<kx>(kx) = kx.0}
end//let//end(gmap_key$strmize(map))
//
(* ****** ****** *)
//
#impltmp
<map:t0>
<key:t0>
<itm:t0>
gmap_val$strmize
  ( map ) =
let
//
val kxs =
(
gmap_keyval$strmize
< map >< key >< itm >(map))
//
in//let
(
strm_vt_map0<kx>(kxs)) where
{
#vwtpdef kx = (key,itm)
#impltmp map$fopr0<kx>(kx) = kx.1}
end//let//end(gmap_val$strmize(map))
//
(* ****** ****** *)
//
#impltmp
<map:t0>
<key:t0>
<itm:t0>
gmap_keyval$strmize =
gseq_strmize1<map><(key,itm)>(*void*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_gmap001.dats] *)
(***********************************************************************)
`,
  "DATS/gnum000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Fri 12 Jul 2024 07:16:15 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#typedef ni = nint
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:t0 >
g_suc(x0) =
g_add<x0>(x0, g_1<x0>())
#impltmp
< x0:t0 >
g_pre(x0) =
g_sub<x0>(x0, g_1<x0>())
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:t0 >
g_sqr(x0) =
g_mul<x0>(x0, x0)
#impltmp
< x0:t0 >
g_cbe(x0) =
g_mul<x0>(g_sqr<x0>(x0), x0)
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
g_pow(x0, n0) =
(
auxloop
(x0, n0, g_1<x0>())
) where
{
//
#symload
* with g_mul of 1000
//
fun
auxloop
( x0: x0
, n0: ni, rs: x0): x0 =
if
(n0 <= 0)
then rs else
(
auxloop
(x0*x0, n1, rs)
) where
{
val n1 = n0 / 2
val rs =
if n0 % 2 = 0 then rs else x0*rs
}(*where*)//end-of-[auxloop(...)]
//
}(*where*)//end-of-[g_pow(x0, n0)]
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
g_ncpy(x0, n0) =
(
if
(n0 <= 0)
then
(
  g_0<x0>() )
else
(
  loop(n0-1, x0))) where
{
//
fun
loop
(i0: nint, r0: x0): (x0) =
(
if
(i0 <= 0)
then r0 else
(
  loop(i0-1, g_add<x0>(x0, r0))))
//
}(*where*)//end-of-[g_ncpy(x0, n0)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_gnum000.dats] *)
(***********************************************************************)
`,
  "DATS/gord000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sat 10 Aug 2024 03:48:01 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:t0 >
g_lt(x1, x2) =
g_gt<x0>(x2, x1)
#impltmp
< x0:t0 >
g_gt(x1, x2) =
g_lt<x0>(x2, x1)
//
#impltmp
< x0:t0 >
g_lt(x1, x2) =
(
g_cmp<x0>(x1, x2) < 0)
#impltmp
< x0:t0 >
g_gt(x1, x2) =
(
g_cmp<x0>(x1, x2) > 0)
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
g_lte(x1, x2) =
g_gte<x0>(x2, x1)
#impltmp
< x0:t0 >
g_gte(x1, x2) =
g_lte<x0>(x2, x1)
//
#impltmp
< x0:t0 >
g_lte(x1, x2) =
(
g_cmp<x0>(x1, x2) <= 0)
#impltmp
< x0:t0 >
g_gte(x1, x2) =
(
g_cmp<x0>(x1, x2) >= 0)
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
g_eq(x1, x2) =
(
g_cmp<x0>(x1, x2) = 0)
#impltmp
< x0:t0 >
g_neq(x1, x2) =
(
g_cmp<x0>(x1, x2) != 0)
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
g_cmp(x1, x2) =
(
if
g_lt<x0>(x1, x2)
then -1 else
if
g_lt<x0>(x2, x1) then -1 else 0
)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:t0 >
g_ltz(x0) =
g_lt<x0>(x0, g_0<x0>((*void*)))
#impltmp
< x0:t0 >
g_gtz(x0) =
g_gt<x0>(x0, g_0<x0>((*void*)))
#impltmp
< x0:t0 >
g_eqz(x0) =
g_eq<x0>(x0, g_0<x0>((*void*)))
//
#impltmp
< x0:t0 >
g_ltez(x0) =
g_lte<x0>(x0, g_0<x0>((*void*)))
#impltmp
< x0:t0 >
g_gtez(x0) =
g_gte<x0>(x0, g_0<x0>((*void*)))
#impltmp
< x0:t0 >
g_neqz(x0) =
g_neq<x0>(x0, g_0<x0>((*void*)))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:t0 >
g_max(x1, x2) =
(
if // if
g_gte<x0>(x1, x2) then x1 else x2)
//
#impltmp
< x0:t0 >
g_min(x1, x2) =
(
if // if
g_lte<x0>(x1, x2) then x1 else x2)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_gord000.dats] *)
(***********************************************************************)
`,
  "DATS/gseq000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon 08 Jul 2024 12:53:10 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_sep((*void*)) = ","
#impltmp
< xs:vt >
< x0:vt >
gseq_end((*void*)) = ")"
#impltmp
< xs:vt >
< x0:vt >
gseq_beg((*void*)) = "gseq("
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_omit((*void*)) = "..."
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_prlen((*void*)) = (-1)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-03:
Sat 03 Aug 2024 02:54:34 PM EDT
*)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_nilq(xs) =
not(gseq_consq<xs><x0>(xs))
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_consq(xs) =
(
 not(gseq_nilq<xs><x0>(xs)))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_free(xs) =
(
gseq_foritm0<xs><x0>(xs)
) where
{
#impltmp
foritm$work0<x0> = g_free<x0>
}
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_copy(xs) =
(
gseq_map1_self<xs><x0>(xs)
) where
{
#impltmp
map$fopr1<x0><x0> = g_copy<x0>
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_max = gseq_max0<xs><x0>
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_min = gseq_min0<xs><x0>
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_sum = gseq_sum0<xs><x0>
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_prod = gseq_prod0<xs><x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_torep = gseq_torep0<xs><x0>
#impltmp
< xs:t0 >
< x0:t0 >
gseq_tostr = gseq_tostr0<xs><x0>
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_print = gseq_print0<xs><x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_length = gseq_length0<xs><x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-17:
Wed 17 Jul 2024 01:31:56 PM EDT
*)
//
(*
#impltmp
< xs:t0 >
< x0:t0 >
< ys:vt >
gseq_append =
gseq_append00<xs><x0><ys>(*void*)
*)
//
#impltmp
< xs:t0 >
< x0:t0 >
< ys:vt >
gseq_append
  (xs, ys) =
gseq_fmake_fwork<xs><x0>
(
lam(work) =>
(
gseq_foritm$f1un<xs><x0>(xs, work);
gseq_foritm0$f1un<ys><x0>(ys, work)))
//
(* ****** ****** *)
//
(*
HX-2024-07-17:
Wed 17 Jul 2024 01:36:53 PM EDT
*)
//
(*
#impltmp
< xs:t0 >
< x0:t0 >
< ys:vt >
gseq_prepend =
gseq_prepend00<xs><x0><ys>(*void*)
*)
//
#impltmp
< xs:t0 >
< x0:t0 >
< ys:vt >
gseq_prepend
  (xs, ys) =
gseq_fmake_fwork<xs><x0>
(
lam(work) =>
(
gseq_foritm0$f1un<ys><x0>(ys, work)
;gseq_foritm$f1un<xs><x0>(xs, work)))
//
(* ****** ****** *)
//
(*
Wed 17 Jul 2024 04:10:30 PM EDT
*)
//
(*
#impltmp
< xs:t0 >
< x0:t0 >
< ys:vt >
gseq_reverse =
gseq_reverse0<xs><x0>(*void*)
#impltmp
< xs:t0 >
< x0:t0 >
< ys:vt >
gseq_rappend =
gseq_rappend00<xs><x0><ys>(*void*)
*)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_reverse
  ( xs ) =
gseq_fmake_fwork<xs><x0>
(
lam(work) =>
(
gseq_rforitm$f1un<xs><x0>(xs, work)))
//
#impltmp
< xs:t0 >
< x0:t0 >
< ys:vt >
gseq_rappend
  (xs, ys) =
gseq_fmake_fwork<xs><x0>
(
lam(work) =>
(
gseq_rforitm$f1un<xs><x0>(xs, work);
gseq_foritm0$f1un<ys><x0>(ys, work)))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-14:
Sun Dec 14 05:20:43 PM EST 2025
*)
#impltmp
< xz:t0 >
< xs:t0 >
< x0:t0 >
gseq_concat_lstrm
  (   xz   ) =
let
#vwtpdef ys = strm_vt(x0)
in//let
strm_vt_lstrm$concat0<x0>(
gseq_map$f1un_lstrm<xz><xs><ys>(xz, gseq_strmize<xs><x0>))
end(*let*)//end-of-[gseq_concat(xz)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_gseq000.dats] *)
(***********************************************************************)
`,
  "DATS/gseq001.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sat 13 Jul 2024 10:07:23 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_strmize =
gseq_strmize0<xs><x0>(*void*)
#impltmp
< xs:t0 >
< x0:t0 >
gseq_strqize =
gseq_strqize0<xs><x0>(*void*)
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_rstrmize =
gseq_rstrmize0<xs><x0>(*void*)
#impltmp
< xs:t0 >
< x0:t0 >
gseq_rstrqize =
gseq_rstrqize0<xs><x0>(*void*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_listize
  ( xs ) =
(
gseq_rfolditm
<xs><x0><r0>(xs, r0))
where
{
val r0 = list_vt_nil()
#vwtpdef r0 = list_vt(x0)
#impltmp
rfolditm$fopr
<x0><r0>
(x0, r0) = list_vt_cons(x0, r0)
}(*where*)//end(gseq_listize(xs))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_rlistize
  ( xs ) =
(
gseq_folditm
<xs><x0><r0>(xs, r0))
where
{
val r0 = list_vt_nil()
#vwtpdef r0 = list_vt(x0)
#impltmp
folditm$fopr
<x0><r0>
(r0, x0) = list_vt_cons(x0, r0)
}(*where*)//end(gseq_rlistize(xs))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_forall
  ( xs ) =
(
strm_vt_forall0<x0>
(
gseq_strmize<xs><x0>(xs)))
where
{
#impltmp
forall$test0<x0> = forall$test<x0>
}
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_forall$f1un
  (xs, test) =
(
gseq_forall
<xs><x0>(xs)) where {
#impltmp
forall$test<x0>(*x0*) = test(*x0*)
}(*where*)//end-of-[gseq_forall$f1un(xs)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_exists
  ( xs ) =
let
//
#impltmp
forall$test<x0>(x0) =
(
  not(exists$test<x0>(x0)))
//
in//let
  not(gseq_forall<xs><x0>(xs))
end//let//end-of-[gseq_exists(xs)]
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_exists$f1un
  (xs, test) =
(
gseq_exists
<xs><x0>(xs)) where {
#impltmp
exists$test<x0>(*x0*) = test(*x0*)
}(*where*)//end-of-[gseq_exists$f1un(xs)]
//
(* ****** ****** *)
//
(*
(*
HX-2026-01-07:
This should be for
a bi-directional gseq!
Wed Jan  7 02:41:07 PM EST 2026
*)
#impltmp
< xs:t0 >
< x0:t0 >
gseq_rforall
  ( xs ) =
(
strm_vt_forall0<x0>
(gseq_rstrmize<xs><x0>(xs)))
where
{
#impltmp
forall$test0<x0> = rforall$test<x0>
}
*)
//
(*
HX-2025-12-22:
[gseq_rforall] should be
based on [gseq_rlistize]
for uni-directional [gseq]?
HX-2026-01-07: Yes!
Wed Jan  7 02:41:07 PM EST 2026
*)
#impltmp
< xs:t0 >
< x0:t0 >
gseq_rforall
  ( xs ) =
(
list_vt_forall0<x0>
(gseq_rlistize<xs><x0>(xs)))
where
{
#impltmp
forall$test0<x0> = rforall$test<x0>
}
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_rforall$f1un
  (xs, test) =
(
gseq_rforall
<xs><x0>(xs)) where {
#impltmp
rforall$test<x0>(*x0*) = test(*x0*)
}(*where*)//end-of-[gseq_rforall$f1un(xs)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_rexists
  ( xs ) =
let
//
#impltmp
rforall$test<x0>(x0) =
(
  not(rexists$test<x0>(x0)))
//
in//let
  not(gseq_rforall<xs><x0>(xs))
end//let//end-of-[gseq_rexists(xs)]
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_rexists$f1un
  (xs, test) =
(
gseq_rexists
<xs><x0>(xs)) where {
#impltmp
rexists$test<x0>(*x0*) = test(*x0*)
}(*where*)//end-of-[gseq_rexists$f1un(xs)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_iforall
  ( xs ) = b0
where {
//
var i0: ni = (0)
//
val p0 = $addr(i0)
//
val b0 =
(
gseq_forall<xs><x0>(xs)
) where
{
#impltmp
forall$test<x0>(x0) =
(
$UN.p2tr_set<ni>(p0, i0+1); b0)
where
{
val i0 = $UN.p2tr_get<ni>(p0)
val b0 = iforall$test<x0>(i0, x0) }
}
//
}(*where*)//end-of-[gseq_iforall(xs)]
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_iforall$f2un
  (xs, test) =
(
gseq_iforall
<xs><x0>(xs)) where {
#impltmp
iforall$test<x0>(*i0,x0*) = test(*i0,x0*)
}(*where*)//end-of-[gseq_iforall$f2un(xs)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_iexists
  ( xs ) =
let
//
#impltmp
iforall$test<x0>(i0, x0) =
(
not(iexists$test<x0>(i0, x0)))
//
in//let
(
  not(gseq_iforall<xs><x0>(xs)))
end//let//end-of-[gseq_iexists(xs)]
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_iexists$f2un
  (xs, test) =
(
gseq_iexists
<xs><x0>(xs)) where {
#impltmp
iexists$test<x0>(*i0,x0*) = test(*i0,x0*)
}(*where*)//end-of-[gseq_iexists$f2un(xs)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_irforall
  ( xs ) = b0
where {
//
var i0: ni = (0)
//
val p0 = $addr(i0)
//
val b0 =
(
gseq_rforall<xs><x0>(xs)
) where
{
#impltmp
rforall$test<x0>(x0) =
(
$UN.p2tr_set<ni>(p0, i0+1); b0)
where
{
val i0 = $UN.p2tr_get<ni>(p0)
val b0 = irforall$test<x0>(i0, x0) }
}
//
}(*where*)//end-of-[gseq_irforall(xs)]
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_irforall$f2un
  (xs, test) =
(
gseq_irforall
<xs><x0>(xs)) where {
#impltmp
irforall$test<x0>(*i0,x0*) = test(*i0,x0*)
}(*where*)//end-of-[gseq_irforall$f2un(xs)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_irexists
  ( xs ) =
let
//
#impltmp
iforall$test<x0>(i0, x0) =
(
not(irexists$test<x0>(i0, x0)))
//
in//let
(
  not(gseq_iforall<xs><x0>(xs)))
end//let//end-of-[gseq_irexists(xs)]
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_irexists$f2un
  (xs, test) =
(
gseq_irexists
<xs><x0>(xs)) where {
#impltmp
irexists$test<x0>(*i0,x0*) = test(*i0,x0*)
}(*where*)//end-of-[gseq_irexists$f2un(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_foritm
  ( xs ) =
(
let
val _ =
gseq_forall
<xs><x0>(xs) end//let
) where
{
#impltmp
forall$test<x0>(x0) =
let
val () =
foritm$work<x0>(x0) in true end
}(*where*)//end-of-[gseq_foritm(xs)]
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_foritm$f1un
  (xs, work) =
(
gseq_foritm
<xs><x0>(xs)) where {
#impltmp foritm$work<x0>(x0) = work(x0)
}(*where*)//end-of-[gseq_foritm$f1un(xs,work)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_rforitm
  ( xs ) =
(
let
val _ =
gseq_rforall
<xs><x0>(xs) end//let
) where
{
#impltmp
rforall$test<x0>(x0) =
let
val () =
rforitm$work<x0>(x0) in true end
}(*where*)//end-of-[gseq_rforitm(xs)]
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_rforitm$f1un
  (xs, work) =
(
gseq_rforitm
<xs><x0>(xs)) where {
#impltmp rforitm$work<x0>(x0) = work(x0)
}(*where*)//end-of-[gseq_rforitm$f1un(xs,work)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_iforitm
  ( xs ) =
(
let
val _ =
gseq_iforall
<xs><x0>(xs) end//let
) where
{
#impltmp
iforall$test<x0>(i0,x0) =
let
val () =
iforitm$work<x0>(i0,x0) in true end
}(*where*)//end-of-[gseq_iforitm(xs)]
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_iforitm$f2un
  (xs, work) =
(
gseq_iforitm
<xs><x0>(xs)) where {
#impltmp
iforitm$work<x0>(i0, x0) = work(i0, x0)
}(*where*)//end-of-[gseq_iforitm$f2un(xs,work)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_irforitm
  ( xs ) =
(
let
val _ =
gseq_irforall
<xs><x0>(xs) end//let
) where
{
#impltmp
irforall$test<x0>(i0,x0) =
let
val () =
irforitm$work<x0>(i0,x0) in true end
}(*where*)//end-of-[gseq_irforitm(xs)]
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_irforitm$f2un
  (xs, work) =
(
gseq_irforitm
<xs><x0>(xs)) where {
#impltmp
irforitm$work<x0>(i0, x0) = work(i0, x0)
}(*where*)//end-of-[gseq_irforitm$f2un(xs,work)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_folditm
  (xs, r0) = r0
where {
//
var r0: r0 = r0
//
val p0 = $addr(r0)
//
val () =
(
gseq_foritm<xs><x0>(xs)
) where
{
#impltmp
foritm$work<x0>(x0) =
(
  $UN.p2tr_set<r0>(p0, r0))
where
{
val r0 = $UN.p2tr_get<r0>(p0)
val r0 = folditm$fopr<x0><r0>(r0, x0)}}
//
}(*where*)//end-of-[gseq_folditm(xs,r0)]
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_folditm$f2un
  (xs, r0, fopr) =
(
gseq_folditm
<xs><x0><r0>(xs, r0)) where
{
#impltmp
folditm$fopr<x0><r0>(r0, x0) = fopr(r0, x0)
}(*where*)//end-of-[gseq_folditm$f2un(xs,r0,fopr)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_rfolditm
  (xs, r0) = r0
where {
//
var r0: r0 = r0
//
val p0 = $addr(r0)
//
val () =
(
gseq_rforitm<xs><x0>(xs)
) where
{
#impltmp
rforitm$work<x0>(x0) =
(
  $UN.p2tr_set<r0>(p0, r0))
where
{
val r0 = $UN.p2tr_get<r0>(p0)
val r0 = rfolditm$fopr<x0><r0>(x0, r0)}}
//
}(*where*)//end-of-[gseq_rfolditm(xs,r0)]
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_rfolditm$f2un
  (xs, r0, fopr) =
(
gseq_rfolditm
<xs><x0><r0>(xs, r0)) where
{
#impltmp
rfolditm$fopr<x0><r0>(r0, x0) = fopr(r0, x0)
}(*where*)//end-of-[gseq_rfolditm$f2un(xs,r0,fopr)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_ifolditm
  (xs, r0) = r0
where {
//
var i0: ni = 0
var r0: r0 = r0
//
val pi = $addr(i0)
val pr = $addr(r0)
//
val () =
(
gseq_foritm<xs><x0>(xs)
) where
{
#impltmp
foritm$work<x0>(x0) =
(
  $UN.p2tr_set<r0>(pr, r0)
; $UN.p2tr_set<ni>(pi, i0+1))
where
{
val i0 = $UN.p2tr_get<ni>(pi)
val r0 = $UN.p2tr_get<r0>(pr)
val r0 =
(
  ifolditm$fopr<x0><r0>(r0, i0, x0))}}
//
}(*where*)//end-of-[gseq_ifolditm(xs,r0)]
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_ifolditm$f3un
  (xs, r0, fopr) =
(
gseq_ifolditm
<xs><x0><r0>(xs, r0)) where
{
#impltmp
ifolditm$fopr
< x0 >< r0 >(r0, i0, x0) = fopr(r0, i0, x0)
}(*where*)//end-of-[gseq_ifolditm$f3un(xs,r0,fopr)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_irfolditm
  (xs, r0) = r0
where {
//
var i0: ni = 0
var r0: r0 = r0
//
val pi = $addr(i0)
val pr = $addr(r0)
//
val () =
(
gseq_rforitm<xs><x0>(xs)
) where
{
#impltmp
rforitm$work<x0>(x0) =
(
  $UN.p2tr_set<r0>(pr, r0)
; $UN.p2tr_set<ni>(pi, i0+1))
where
{
val i0 = $UN.p2tr_get<ni>(pi)
val r0 = $UN.p2tr_get<r0>(pr)
val r0 =
(
  irfolditm$fopr<x0><r0>(i0, x0, r0))}}
//
}(*where*)//end-of-[gseq_irfolditm(xs,r0)]
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_irfolditm$f3un
  (xs, r0, fopr) =
(
gseq_irfolditm
<xs><x0><r0>(xs, r0)) where
{
#impltmp
irfolditm$fopr
< x0 >< r0 >(i0, x0, r0) = fopr(i0, x0, r0)
}(*where*)//end-of-[gseq_irfolditm$f3un(xs,r0,fopr)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_foldall
  (xs, r0) = r0
where {
//
var r0: r0 = r0
//
val p0 = $addr(r0)
//
val b0 =
(
gseq_forall<xs><x0>(xs)
) where
{
#impltmp
forall$test<x0>(x0) =
(
$UN.p2tr_set<r0>(p0, r0); b0)
where
{
val r0 = $UN.p2tr_get<r0>(p0)
val (b0, r0) =
(
  foldall$fopr<x0><r0>(r0, x0)) } }
//
}(*where*)//end-of-[gseq_foldall(xs, r0)]
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_foldall$f2un
  (xs, r0, fopr) =
(
gseq_foldall
<xs><x0><r0>(xs, r0)) where
{
#impltmp
foldall$fopr<x0><r0>(r0, x0) = fopr(r0, x0)
}(*where*)//end-of-[gseq_foldall$f2un(xs,r0)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_rfoldall
  (xs, r0) = r0
where {
//
var r0: r0 = r0
//
val p0 = $addr(r0)
//
val b0 =
(
gseq_rforall<xs><x0>(xs)
) where
{
#impltmp
rforall$test<x0>(x0) =
(
$UN.p2tr_set<r0>(p0, r0); b0)
where
{
val r0 = $UN.p2tr_get<r0>(p0)
val (b0, r0) =
(
  rfoldall$fopr<x0><r0>(x0, r0)) } }
//
}(*where*)//end-of-[gseq_rfoldall(xs, r0)]
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_rfoldall$f2un
  (xs, r0, fopr) =
(
gseq_rfoldall
<xs><x0><r0>(xs, r0)) where
{
#impltmp
rfoldall$fopr<x0><r0>(x0, r0) = fopr(x0, r0)
}(*where*)//end-of-[gseq_rfoldall$f2un(xs,r0)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_ifoldall
  (xs, r0) = r0
where {
//
var i0: ni = 0
var r0: r0 = r0
//
val pi = $addr(i0)
val pr = $addr(r0)
//
val b0 =
(
gseq_forall<xs><x0>(xs)
) where
{
#impltmp
forall$test
< x0 >( x0 ) = ( b0 )
where
{
val () =
$UN.p2tr_set<r0>(pr, r0)
val () =
$UN.p2tr_set<ni>(pi, i0+1)}
where
{
val i0 = $UN.p2tr_get<ni>(pi)
val r0 = $UN.p2tr_get<r0>(pr)
val (b0, r0) =
(
  ifoldall$fopr<x0><r0>(r0, i0, x0))}}
//
}(*where*)//end-of-[gseq_ifoldall(xs, r0)]
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_ifoldall$f3un
  (xs, r0, fopr) =
(
gseq_ifoldall
<xs><x0><r0>(xs, r0)) where
{
#impltmp
ifoldall$fopr
< x0 >< r0 >(r0, i0, x0) = fopr(r0, i0, x0)
}(*where*)//end-of-[gseq_ifoldall$f3un(xs,r0)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_irfoldall
  (xs, r0) = r0
where {
//
var i0: ni = 0
var r0: r0 = r0
//
val pi = $addr(i0)
val pr = $addr(r0)
//
val b0 =
(
gseq_rforall<xs><x0>(xs)
) where
{
#impltmp
rforall$test
< x0 >( x0 ) = ( b0 )
where
{
val () =
$UN.p2tr_set<r0>(pr, r0)
val () =
$UN.p2tr_set<ni>(pi, i0+1)}
where
{
val i0 = $UN.p2tr_get<ni>(pi)
val r0 = $UN.p2tr_get<r0>(pr)
val (b0, r0) =
(
  irfoldall$fopr<x0><r0>(i0, x0, r0))}}
//
}(*where*)//end-of-[gseq_irfoldall(xs, r0)]
//
#impltmp
< xs:t0 >
< x0:t0 >
< r0:vt >
gseq_irfoldall$f3un
  (xs, r0, fopr) =
(
gseq_irfoldall
<xs><x0><r0>(xs, r0)) where
{
#impltmp
irfoldall$fopr
< x0 >< r0 >(r0, i0, x0) = fopr(r0, i0, x0)
}(*where*)//end-of-[gseq_irfoldall$f3un(xs,r0)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< ys:vt >
< y0:vt >
gseq_map_ares(xs) =
g_make_lstrm<y0><ys>
(
gseq_map_lstrm<xs><x0><y0>(xs))
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_map_self(xs) =
g_make_lstrm<x0><xs>
(
gseq_map_lstrm<xs><x0><x0>(xs))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< ys:vt >
< y0:vt >
gseq_map$f1un_ares
  (xs, fopr) =
(
gseq_map_ares
<xs><x0>
<ys><y0>( xs )) where
{
#impltmp
map$fopr<x0><y0>(x0) = fopr(x0)
}
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_map$f1un_self
  (xs, fopr) =
(
gseq_map_self
<xs><x0>( xs )) where
{
#impltmp
map$fopr<x0><x0>(x0) = fopr(x0)
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:t0 >
gseq_map_list
  ( xs ) =
list_vt2t{y0}
(
gseq_map_llist<xs><x0><y0>(xs))
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:t0 >
gseq_map$f1un_list
  (xs, fopr) =
list_vt2t{y0}
(
gseq_map$f1un_llist<xs><x0><y0>(xs, fopr))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_map_llist
  ( xs ) =
strm_vt_listize0<y0>
(
gseq_map_lstrm<xs><x0><y0>(xs))
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_map$f1un_llist
  (xs, fopr) =
(
gseq_map_llist<xs><x0><y0>(xs))
where
{
#impltmp
map$fopr<x0><y0>( x0 ) = fopr( x0 )
}(*where*)//end-of-[gseq_map$f1un_llist]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_map_lstrm
  ( xs ) =
strm_vt_map0<x0><y0>
(
gseq_strmize<xs><x0>(xs))
where {
#impltmp
map$fopr0<x0><y0> = map$fopr<x0><y0>
}(*where*)
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_map_lstrq
  ( xs ) =
strq_vt_map0<x0><y0>
(
gseq_strqize<xs><x0>(xs))
where {
#impltmp
map$fopr0<x0><y0> = map$fopr<x0><y0>
}(*where*)
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_map$f1un_lstrm
  (xs, fopr) =
(
gseq_map_lstrm<xs><x0><y0>(xs))
where
{
#impltmp
map$fopr<x0><y0>( x0 ) = fopr( x0 )
}(*where*)//end-of-[gseq_map$f1un_lstrm]
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_map$f1un_lstrq
  (xs, fopr) =
(
gseq_map_lstrq<xs><x0><y0>(xs))
where
{
#impltmp
map$fopr<x0><y0>( x0 ) = fopr( x0 )
}(*where*)//end-of-[gseq_map$f1un_lstrq]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:t0 >
gseq_map_rlist
  ( xs ) =
list_vt2t{y0}(
gseq_map_rllist<xs><x0><y0>(xs))
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:t0 >
gseq_map$f1un_rlist
  (xs, fopr) =
list_vt2t{y0}(
gseq_map$f1un_rllist<xs><x0><y0>(xs, fopr))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_map_rllist
  ( xs ) =
strm_vt_rlistize0<y0>
(
gseq_map_lstrm<xs><x0><y0>(xs))
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_map$f1un_rllist
  (xs, fopr) =
(
gseq_map_rllist<xs><x0><y0>(xs))
where
{
#impltmp
map$fopr<x0><y0>( x0 ) = fopr( x0 )
}(*where*)//end-of-[gseq_map$f1un_rllist]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:t0 >
gseq_rmap_list
  ( xs ) =
list_vt2t{y0}(
gseq_rmap_llist<xs><x0><y0>(xs))
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:t0 >
gseq_rmap$f1un_list
  (xs, fopr ) =
list_vt2t{y0}(
gseq_rmap$f1un_llist<xs><x0><y0>(xs, fopr))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_rmap_llist
  ( xs ) =
strm_vt_listize0<y0>
(
gseq_rmap_lstrm<xs><x0><y0>(xs))
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_rmap$f1un_llist
  (xs, fopr) =
(
gseq_rmap_llist<xs><x0><y0>(xs))
where
{
#impltmp
rmap$fopr<x0><y0>( x0 ) = fopr( x0 )
}(*where*)//end-of-[gseq_rmap$f1un_llist]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_rmap_lstrm
  ( xs ) =
strm_vt_map0<x0><y0>
(
gseq_rstrmize<xs><x0>(xs))
where
{
#impltmp
map$fopr0<x0><y0> = rmap$fopr<x0><y0>
}
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_rmap_lstrq
  ( xs ) =
strq_vt_map0<x0><y0>
(
gseq_rstrqize<xs><x0>(xs))
where
{
#impltmp
map$fopr0<x0><y0> = rmap$fopr<x0><y0>
}
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_rmap$f1un_lstrm
  (xs, fopr) =
(
gseq_rmap_lstrm<xs><x0><y0>(xs))
where
{
#impltmp
rmap$fopr<x0><y0>( x0 ) = fopr( x0 )
}(*where*)//end-of-[gseq_rmap$f1un_lstrm]
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_rmap$f1un_lstrq
  (xs, fopr) =
(
gseq_rmap_lstrq<xs><x0><y0>(xs))
where
{
#impltmp
rmap$fopr<x0><y0>( x0 ) = fopr( x0 )
}(*where*)//end-of-[gseq_rmap$f1un_lstrq]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:t0 >
gseq_rmap_rlist
  ( xs ) =
list_vt2t{y0}
(
gseq_rmap_rllist<xs><x0><y0>(xs))
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:t0 >
gseq_rmap$f1un_rlist
  (xs, fopr ) =
list_vt2t{y0}
(
gseq_rmap$f1un_rllist<xs><x0><y0>(xs, fopr))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_rmap_rllist
  ( xs ) =
strm_vt_rlistize0<y0>
(
gseq_rmap_lstrm<xs><x0><y0>(xs))
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_rmap$f1un_rllist
  (xs, fopr) =
(
gseq_rmap_rllist<xs><x0><y0>(xs))
where
{
#impltmp
rmap$fopr<x0><y0>( x0 ) = fopr( x0 )
}(*where*)//end-of-[gseq_rmap$f1un_rllist]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:t0 >
gseq_imap_list
  ( xs ) =
list_vt2t{y0}
(
gseq_imap_llist<xs><x0><y0>(xs))
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:t0 >
gseq_imap$f2un_list
  (xs, fopr) =
list_vt2t{y0}
(
gseq_imap$f2un_llist<xs><x0><y0>(xs, fopr))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_imap_llist
  ( xs ) =
strm_vt_listize0<y0>
(
gseq_imap_lstrm<xs><x0><y0>(xs))
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_imap$f2un_llist
  (xs, fopr) =
(
gseq_imap_llist<xs><x0><y0>(xs)
) where
{
#impltmp
imap$fopr<x0><y0>(i0, x0) = fopr(i0, x0)
}
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_imap_lstrm
  ( xs ) =
strm_vt_imap0<x0><y0>
(
gseq_strmize<xs><x0>(xs))
where {
#impltmp
imap$fopr0<x0><y0> = imap$fopr<x0><y0>
}(*where*)
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_imap_lstrq
  ( xs ) =
strq_vt_imap0<x0><y0>
(
gseq_strqize0<xs><x0>(xs))
where {
#impltmp
imap$fopr0<x0><y0> = imap$fopr<x0><y0>
}(*where*)
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_imap$f2un_lstrm
  (xs, fopr) =
(
gseq_imap_lstrm<xs><x0><y0>(xs)
) where
{
#impltmp
imap$fopr<x0><y0>(i0, x0) = fopr(i0, x0)
}
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_imap$f2un_lstrq
  (xs, fopr) =
(
gseq_imap_lstrq<xs><x0><y0>(xs)
) where
{
#impltmp
imap$fopr<x0><y0>(i0, x0) = fopr(i0, x0)
}
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:t0 >
gseq_imap_rlist
  ( xs ) =
list_vt2t{y0}
(
gseq_imap_rllist<xs><x0><y0>(xs))
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:t0 >
gseq_imap$f2un_rlist
  (xs, fopr) =
list_vt2t{y0}
(
gseq_imap$f2un_rllist<xs><x0><y0>(xs, fopr))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_imap_rllist
  ( xs ) =
strm_vt_rlistize0<y0>
(
gseq_imap_lstrm<xs><x0><y0>(xs))
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_imap$f2un_rllist
  (xs, fopr) =
(
gseq_imap_rllist<xs><x0><y0>(xs)
) where
{
#impltmp
imap$fopr<x0><y0>(i0, x0) = fopr(i0, x0)
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-28:
Sun 28 Jul 2024 05:43:53 PM EDT
*)
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:t0 >
gseq_irmap_list
  ( xs ) =
list_vt2t{y0}
(
gseq_irmap_llist<xs><x0><y0>(xs))
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_irmap_llist
  ( xs ) =
strm_vt_listize0<y0>
(
gseq_irmap_lstrm<xs><x0><y0>(xs))
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_irmap$f2un_llist
  (xs, fopr) =
(
gseq_irmap_llist<xs><x0><y0>(xs)
) where
{
#impltmp
irmap$fopr<x0><y0>(i0, x0) = fopr(i0, x0)
}
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_irmap_lstrm
  ( xs ) =
strm_vt_imap0<x0><y0>
(gseq_rstrmize<xs><x0>(xs))
where
{
#impltmp
imap$fopr0<x0><y0> = irmap$fopr<x0><y0>
}
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_irmap_lstrq
  ( xs ) =
strq_vt_imap0<x0><y0>
(gseq_rstrqize<xs><x0>(xs))
where
{
#impltmp
imap$fopr0<x0><y0> = irmap$fopr<x0><y0>
}
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_irmap$f2un_lstrm
  (xs, fopr) =
(
gseq_irmap_lstrm<xs><x0><y0>(xs)
) where
{
#impltmp
irmap$fopr<x0><y0>(i0, x0) = fopr(i0, x0)
}
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_irmap$f2un_lstrq
  (xs, fopr) =
(
gseq_irmap_lstrq<xs><x0><y0>(xs)
) where
{
#impltmp
irmap$fopr<x0><y0>(i0, x0) = fopr(i0, x0)
}
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:t0 >
gseq_irmap_rlist
  ( xs ) =
list_vt2t{y0}
(
gseq_irmap_rllist<xs><x0><y0>(xs))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_irmap_rllist
  ( xs ) =
strm_vt_rlistize0<y0>
(
gseq_irmap_lstrm<xs><x0><y0>(xs))
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_irmap$f2un_rllist
  (xs, fopr) =
(
gseq_irmap_rllist<xs><x0><y0>(xs)
) where
{
#impltmp
irmap$fopr<x0><y0>(i0, x0) = fopr(i0, x0)
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< ys:vt >
gseq_filter_ares
  ( xs ) =
g_make_lstrm<x0><ys>
(
gseq_filter_lstrm<xs><x0>(xs))
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_filter_self
  ( xs ) =
g_make_lstrm<x0><xs>
(
gseq_filter_lstrm<xs><x0>(xs))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_filter_list
  ( xs ) =
list_vt2t{x0}
(
gseq_filter_llist<xs><x0>(xs))
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_filter$f1un_list
  (xs, test) =
list_vt2t{x0}
(
gseq_filter$f1un_llist<xs><x0>(xs, test))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_filter_llist
  ( xs ) =
strm_vt_listize0<x0>
(
gseq_filter_lstrm<xs><x0>(xs))
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_filter$f1un_llist
  (xs, test) =
(
gseq_filter_llist<xs><x0>(xs)
) where
{
#impltmp
filter$test<x0>(*x0*) = test(*x0*)
}(*where*)//end(gseq_filter$f1un_llist)
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_filter_lstrm
  ( xs ) =
strm_vt_filter0<x0>
(
  gseq_strmize<xs><x0>(xs))
where
{
#impltmp
filter$test1<x0> = filter$test<x0>
}
#impltmp
< xs:t0 >
< x0:t0 >
gseq_filter_lstrq
  ( xs ) =
strq_vt_filter0<x0>
(
  gseq_strqize<xs><x0>(xs))
where
{
#impltmp
filter$test1<x0> = filter$test<x0>
}
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_filter$f1un_lstrm
  (xs, test) =
(
gseq_filter_lstrm<xs><x0>(xs)
) where
{
#impltmp
filter$test<x0>(*x0*) = test(*x0*)
}(*where*)//end(gseq_filter$f1un_lstrm)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_filter$f1un_lstrq
  (xs, test) =
(
gseq_filter_lstrq<xs><x0>(xs)
) where
{
#impltmp
filter$test<x0>(*x0*) = test(*x0*)
}(*where*)//end(gseq_filter$f1un_lstrq)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_rfilter_lstrm
  ( xs ) =
strm_vt_filter0<x0>
(
  gseq_rstrmize<xs><x0>(xs))
where
{
#impltmp
filter$test1<x0> = rfilter$test<x0>
}
#impltmp
< xs:t0 >
< x0:t0 >
gseq_rfilter_lstrq
  ( xs ) =
strq_vt_filter0<x0>
(
  gseq_rstrqize<xs><x0>(xs))
where
{
#impltmp
filter$test1<x0> = rfilter$test<x0>
}
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_rfilter$f1un_lstrm
  (xs, test) =
(
gseq_rfilter_lstrm<xs><x0>(xs)
) where
{
#impltmp
rfilter$test<x0>(*x0*) = test(*x0*)
}(*where*)//end(gseq_rfilter$f1un_lstrm)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_rfilter$f1un_lstrq
  (xs, test) =
(
gseq_rfilter_lstrq<xs><x0>(xs)
) where
{
#impltmp
rfilter$test<x0>(*x0*) = test(*x0*)
}(*where*)//end(gseq_rfilter$f1un_lstrq)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-16:
Fri 16 Aug 2024 08:45:52 AM EDT
This is some kind of "fusion" aiming at
saving the intermediate structure that is
otherwise needed in the standard explicit
composition (as reference implementation)!
*)
//
(*
HX-2024-08-17:
Sat 17 Aug 2024 11:47:00 AM EDT
*)
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_map$listize =
gseq_map_llist<xs><x0><y0>(*alias*)
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_map$strmize =
gseq_map_lstrm<xs><x0><y0>(*alias*)
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_map$strqize =
gseq_map_lstrq<xs><x0><y0>(*alias*)
//
(* ****** ****** *)
(* ****** ****** *)
(*
//
HX:
This is the standard
reference implementation:
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_map$forall
  ( xs ) =
(
strm_vt_forall0<y0>
(gseq_map<xs><x0><y0>(xs)))
//
*)
//
(*
HX-2024-08-17:
We need to think about generating
the following style of "fused" code
in some automated manner!!!
*)
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_map$forall
  ( xs ) =
(
gseq_forall
<xs><x0>(xs)) where
{
#impltmp
forall$test<x0>(x0) =
forall$test0<y0>(map$fopr<x0><y0>(x0))
}
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_map$forall$f1un
  (xs, fopr) =
(
gseq_map$forall
<xs><x0><y0>(xs)) where
{
#impltmp
map$fopr<x0><y0>(x0) = fopr(    x0    )
}(*where*)//end(gseq_map$forall$f1un(...))
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_imap$iforall
  ( xs ) =
(
gseq_iforall
<xs><x0>(xs)) where
{
#impltmp
iforall$test<x0>(i0, x0) =
iforall$test0<y0>
(i0, imap$fopr<x0><y0>(i0, x0))
}
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
gseq_imap$iforall$f2un
  (xs, fopr) =
(
gseq_imap$iforall
<xs><x0><y0>( xs ))
where {
#impltmp
imap$fopr<x0><y0>(i0, x0) = fopr(i0, x0)
}(*where*)//end(gseq_imap$iforall$f2un(...))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_uncons$forall
  ( xs ) =
(
  auxmain(xs)) where
{
//
fun
auxmain
( xs
: xs ): bool =
(
if
gseq_nilq
<xs><x0>(xs)
then (true) else
let
//
val x0 =
$UN.gseq_head$raw<xs><x0>(xs)
//
in//let
//
if not(
forall$test<x0>(x0))
then false else
auxmain($UN.gseq_tail$raw<xs><x0>(xs))
end//let//else//end-of-[if]
//
)(*llazy*)//end-of-[auxmain(xs)]
//
}(*where*)//end-of-(gseq_uncons$forall(xs))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_uncons$strmize
  ( xs ) =
(
  auxmain(xs)) where
{
//
fun
auxmain
( xs: xs )
: strm_vt(x0) = $llazy
(
if
gseq_nilq
<xs><x0>(xs)
then
(
  strmcon_vt_nil()) else
let
//
val x0 =
$UN.gseq_head$raw<xs><x0>(xs)
val xs =
$UN.gseq_tail$raw<xs><x0>(xs)
//
in//let
(
  strmcon_vt_cons(x0, auxmain(xs)))
end//let//else//end-of-[if]
)(*llazy*)//end-of-[auxmain(xs)]
//
}(*where*)//end-of-(gseq_uncons$strmize(xs))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-21:
Wed 21 Aug 2024 08:16:22 AM EDT
*)
//
#impltmp
gseq_fmake_fwork
<strn><cgtz>(f0) = strn_fmake_fwork<>(f0)
//
#impltmp
{ x0:t0 }
gseq_fmake_fwork
<a1sz(x0)><x0>(f0) = a1sz_fmake_fwork<x0>(f0)
//
#impltmp
{ x0:t0 }
gseq_fmake_fwork
<list(x0)><x0>(f0) = list_fmake_fwork<x0>(f0)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-06-01:
This resembles
"traverse" in "Traversable"!
Sun Jun  1 11:10:21 AM EDT 2025
*)
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:t0 >
< e1:vt >
gseq_map$e1nv_list
  ( xs, e1 ) =
(
gseq_map_list<xs><x0><y0>(xs)
) where
{
#impltmp
map$fopr<x0><y0>(x0) =
(
  map$e1nv$fopr<x0><y0><e1>(x0, e1))
}(*where*)//end-of-[gseq_map$e1nv_list(xs,e1)]
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
< e1:vt >
gseq_map$e1nv_llist
  ( xs, e1 ) =
(
gseq_map_llist<xs><x0><y0>(xs)
) where
{
#impltmp
map$fopr<x0><y0>(x0) =
(
  map$e1nv$fopr<x0><y0><e1>(x0, e1))
}(*where*)//end-of-[gseq_map$e1nv_llist(xs,e1)]
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
< e1:vt >
gseq_map$e1nv_lstrm
  ( xs, e1 ) =
(
gseq_map_lstrm<xs><x0><y0>(xs)
) where
{
#impltmp
map$fopr<x0><y0>(x0) =
(
  map$e1nv$fopr<x0><y0><e1>(x0, e1))
}(*where*)//end-of-[gseq_map$e1nv_lstrm(xs,e1)]
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
< e1:vt >
gseq_map$e1nv_lstrq
  ( xs, e1 ) =
(
gseq_map_lstrq<xs><x0><y0>(xs)
) where
{
#impltmp
map$fopr<x0><y0>(x0) =
(
  map$e1nv$fopr<x0><y0><e1>(x0, e1))
}(*where*)//end-of-[gseq_map$e1nv_lstrq(xs,e1)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:t0 >
< e1:vt >
gseq_map$e1nv_rlist
  ( xs, e1 ) =
(
gseq_map_rlist<xs><x0><y0>(xs)
) where
{
#impltmp
map$fopr<x0><y0>(x0) =
(
  map$e1nv$fopr<x0><y0><e1>(x0, e1))
}(*where*)//end-of-[gseq_map$e1nv_rlist(xs,e1)]
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:vt >
< e1:vt >
gseq_map$e1nv_rllist
  ( xs, e1 ) =
(
gseq_map_rllist<xs><x0><y0>(xs)
) where
{
#impltmp
map$fopr<x0><y0>(x0) =
(
  map$e1nv$fopr<x0><y0><e1>(x0, e1))
}(*where*)//end-of-[gseq_map$e1nv_rllist(xs,e1)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-25:
Thu Dec 25 04:43:22 PM EST 2025
*)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_search
  ( xs ) =
(
strm_vt_head$opt0<x0>(rs)
) where
{
//
val rs =
(
gseq_filter_lstrm<xs><x0>(xs))
where
{
#impltmp
filter$test<x0> = search$test<x0>
}
//
}(*where*)//end-of-[gseq_search<xs><x0>(xs)]
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_search$f1un
  (xs, test) =
(
gseq_search<xs><x0>(xs)) where
{
#impltmp
search$test<x0>(*x0*) = test(*x0*)
}(*where*)//endof[gseq_search$f1un<xs><x0>(...)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_rsearch
  ( xs ) =
(
strm_vt_head$opt0<x0>(rs)
) where
{
//
val rs =
(
gseq_rfilter_lstrm<xs><x0>(xs))
where
{
#impltmp
rfilter$test<x0> = rsearch$test<x0>
}
//
}(*where*)//end-of-[gseq_rsearch<xs><x0>(xs)]
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_rsearch$f1un
  (xs, test) =
(
gseq_rsearch<xs><x0>(xs)) where
{
#impltmp
rsearch$test<x0>(*x0*) = test(*x0*)
}(*where*)//endof[gseq_rsearch$f1un<xs><x0>(...)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-05:
Mon Jan  5 12:17:18 PM EST 2026
*)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_sortedq
  ( xs ) =
let
//
fun
nilq
(xs: xs): bool =
gseq_nilq<xs><x0>(xs)
//
in//let0
if // if
(nilq(xs))
then true else
let
//
val x0 =
$UN.gseq_head$raw<xs><x0>(xs)
val xs =
$UN.gseq_tail$raw<xs><x0>(xs)
//
in//let1
(
  auxloop(xs, x0))
where
{
//
fun
auxloop
(xs: xs, x0: x0): bool =
(
if
nilq(xs)
then true else
let
val x1 =
$UN.gseq_head$raw<xs><x0>(xs)
val xs =
$UN.gseq_tail$raw<xs><x0>(xs)
in//let
if // if
sortedq$lteq<x0>(x0, x1)
then auxloop(xs, x1) else false end)
//
}(*where*)
//
end(*let1*)//end(else)//endof(if(nilq(xs)))
//
end(*let0*)//end-of-[gseq_sortedq<xs><x0>(xs)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_sortedq
  ( xs ) =
let
//
fun
nilq
(xs: xs): bool =
gseq_nilq<xs><x0>(xs)
//
in//let0
//
if // if
(nilq(xs))
then true else
let
//
val xs =
(
gseq_strmize<xs><x0>(xs))
val ~
strmcon_vt_cons
(   x0 , xs   ) = (  !xs  )
//
in//let1
(
  auxloop(xs, x0)
) where
{
//
#vwtpdef
xs = strm_vt( x0 )
//
fun
auxloop
(xs: xs, x0: x0): bool =
(
case+ !xs of
| ~
strmcon_vt_nil
(  (*void*)  ) => true
| ~
strmcon_vt_cons
(   x1, xs   ) =>
(
if // if
sortedq$lteq<x0>(x0, x1)
then auxloop(xs, x1) else false))
//
}
end(*let1*)//end(else)//endof(if(nilq(xs)))
//
end(*let0*)//end-of-[gseq_sortedq<xs><x0>(xs)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_sortedq$f2un
  (xs, lteq) =
(
gseq_sortedq<xs><x0>(xs))
where
{
#impltmp
sortedq$lteq<x0>(*x1,x2*) = lteq
}(*where*)//end-of-[gseq_sortedq$f2un(xs,lteq)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-04:
Sun Jan  4 11:11:49 PM EST 2026
*)
#impltmp
< xs:t0 >
< x0:t0 >
gseq_memberq(xs, x0) =
(
gseq_exists<xs><x0>(xs)) where
{
#impltmp
exists$test<x0>(x1) = g_equal<x0>(x0, x1)
}(*where*)//end-of-[gseq_memberq<xs><x0>(xs,x0)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_gseq001.dats] *)
(***********************************************************************)
`,
  "DATS/gseq002.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sat 13 Jul 2024 10:17:23 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-04:
Sun 04 Aug 2024 10:21:55 AM EDT
//
These defines show the need for
[symload] that can not be easily
substituted with templates.
//
Note that [GSEQ] is meant to
be resolved during type-checking;
if [GSEQ_make] is used instead,
some types cannot be obtained until
the phase of template resolution.
//
*)
//
#define
GZ2SEQ(xs, ys) =
GSEQ_z2make(GSEQ(xs), GSEQ(ys))
//
(*
#typedef
gz2seq
( xs: t0, x0: t0
, ys: t0, y0: t0) =
(
z2tup(GSEQ(xs, x0), GSEQ(ys, y0)))
*)
//
#impltmp
< xs:t0 >
< x0:t0 >
< ys:t0 >
< y0:t0 >
GSEQ_z2make
(xgsq, ygsq) =
$UN.castxy//GSEQ_make
(z2tup_make(xgsq, ygsq))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ xs:t0
, x0:t0
, ys:t0
, y0:t0 }
gseq_forall
<
gz2seq
(xs,x0
,ys,y0)><(x0,y0)>
  (xsys) =
(
gseq_z2forall
<xs><x0><ys><y0>(xs, ys))
where
{
val
@(xs, ys) =
z2tup_unmk(xsys)
val xs =
GSEQ_unmk<xs><x0>(xs)
and ys =
GSEQ_unmk<ys><y0>(ys)
#impltmp
z2forall$test<x0><y0>(x0, y0) = forall$test@(x0, y0)
}
//
#impltmp
{ xs:t0
, x0:t0
, ys:t0
, y0:t0 }
gseq_rforall
<
gz2seq
(xs,x0,ys,y0)><(x0,y0)>
  (xsys) =
(
gseq_z2rforall
<xs><x0><ys><y0>(xs, ys))
where
{
//
val
@(xs, ys) =
z2tup_unmk(xsys)
val xs =
GSEQ_unmk<xs><x0>(xs)
and ys =
GSEQ_unmk<ys><y0>(ys)
//
#impltmp
z2rforall$test<x0><y0>(x0, y0) = rforall$test@(x0, y0)
//
}
//
(* ****** ****** *)
//
#impltmp
{ xs:t0
, x0:t0
, ys:t0
, y0:t0 }
gseq_strmize
<
gz2seq
(xs,x0
,ys,y0)><(x0,y0)>
  (xsys) =
let
//
val
@(xs, ys) =
z2tup_unmk(xsys)
val xs =
GSEQ_unmk<xs><x0>(xs)
and ys =
GSEQ_unmk<ys><y0>(ys)
//
val xs = gseq_strmize<xs><x0>(xs)
val ys = gseq_strmize<ys><y0>(ys)
//
in//let
//
(
strm_vt_z2map0
<x0><y0><(x0,y0)>(xs, ys))
where
{
#impltmp
z2map$fopr0<x0><y0><(x0,y0)>(x0, y0) = (x0, y0)
}
//
end//let
//
(* ****** ****** *)
(* ****** ****** *)
//
#define
GX2SEQ(xs, ys) =
GSEQ_x2make(GSEQ(xs), GSEQ(ys))
//
(*
#typedef
gx2seq
( xs: t0, x0: t0
, ys: t0, y0: t0) =
(
x2tup(GSEQ(xs, x0), GSEQ(ys, y0)))
*)
//
#impltmp
< xs:t0 >
< x0:t0 >
< ys:t0 >
< y0:t0 >
GSEQ_x2make
(xgsq, ygsq) = 
$UN.castxy//GSEQ_make
(x2tup_make(xgsq, ygsq))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ xs:t0
, x0:t0
, ys:t0
, y0:t0 }
gseq_forall
<
gx2seq
(xs,x0
,ys,y0)><(x0,y0)>
  (xsys) =
(
gseq_x2forall
<xs><x0><ys><y0>(xs, ys))
where
{
//
val
@(xs, ys) =
x2tup_unmk(xsys)
val xs =
GSEQ_unmk<xs><x0>(xs)
and ys =
GSEQ_unmk<ys><y0>(ys)
//
#impltmp
x2forall$test<x0><y0>(x0, y0) = forall$test@(x0, y0)
}
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-05:
Thu 05 Sep 2024 08:13:20 PM EDT
*)
#impltmp
{ xs:t0
, x0:t0
, ys:t0
, y0:t0 }
gseq_strmize
<
gx2seq
(xs,x0,ys,y0)><(x0,y0)>
  (xsys) =
let
//
#typedef
xy = @(x0, y0)
//
val
@(xs, ys) =
x2tup_unmk(xsys)
val xs =
GSEQ_unmk<xs><x0>(xs)
and ys =
GSEQ_unmk<ys><y0>(ys)
//
in//let
//
strm_vt_lstrm$concat0<xy>
(
gseq_map$f1un_lstrm<xs><x0><strm_vt(xy)>
(
xs,
lam(x0) =>
gseq_map$f1un_lstrm<ys><y0><xy>(ys,lam(y0)=>(x0,y0))))
//
end//let//end-of-[gseq_strmize<gx2seq(...)><...>(xsys)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-05:
Mon 05 Aug 2024 06:21:53 PM EDT
*)
//
#impltmp
< xs:t0 >
< x0:t0 >
< ys:t0 >
< y0:t0 >
gseq_z2forall
  (xs, ys) =
let
val xs =
gseq_strmize<xs><x0>(xs)
val ys =
gseq_strmize<ys><y0>(ys)
in//let
(
strm_vt_z2forall0<x0><y0>(xs, ys))
where
{
#impltmp
z2forall$test0<x0><y0> = z2forall$test<x0><y0>
}
end where
{
(*
val () =
(
  prints("gseq_z2forall: xs = ", xs, "\\n"))
val () =
(
  prints("gseq_z2forall: ys = ", ys, "\\n"))
*)
}(*where*)//let//end-of-[gseq_z2forall(xs, ys)]
//
(* ****** ****** *)
//
(*
//
HX-2024-08-05:
This is so interestingly buggy
(when |xs| does not equal |ys|).
Please do not delete the code as
it serves as a really good example!
//
#impltmp
< xs:t0 >
< x0:t0 >
< ys:t0 >
< y0:t0 >
gseq_z2rforall
  (xs, ys) =
let
val xs =
gseq_rstrmize<xs><x0>(xs)
val ys =
gseq_rstrmize<ys><y0>(ys)
in//let
(
strm_vt_z2forall0<x0><y0>(xs, ys))
where
{
#impltmp
z2forall$test0<x0><y0> = z2rforall$test<x0><y0>
}
end where
{
(*
val () =
(
  prints("gseq_z2rforall: xs = ", xs, "\\n"))
val () =
(
  prints("gseq_z2rforall: ys = ", ys, "\\n"))
*)
}(*where*)//let//end-of-[gseq_z2rforall(xs, ys)]
*)
//
#impltmp
< xs:t0 >
< x0:t0 >
< ys:t0 >
< y0:t0 >
gseq_z2rforall
  (xs, ys) =
let
val xs =
gseq_strmize<xs><x0>(xs)
val ys =
gseq_strmize<ys><y0>(ys)
//
in//let
list_vt_forall0<(x0,y0)>
(
strm_vt_z2rlistize0<x0><y0>(xs, ys)
) where
{
#impltmp
forall$test<(x0,y0)>(xy) =
(
  z2rforall$test<x0><y0>(xy.0, xy.1))
}
end//let//end-of-[gseq_z2rforall(xs,ys)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< ys:t0 >
< y0:t0 >
gseq_z2iforall
  (xs, ys) = b0
where {
//
var i0: ni = (0)
//
val p0 = $addr(i0)
//
val b0 =
(
gseq_z2forall
<xs><x0><ys><y0>(xs, ys))
where
{
#impltmp
z2forall$test
<x0><y0>(x0, y0) =
(
$UN.p2tr_set<ni>(p0, i0+1); b0)
where
{
val i0 = $UN.p2tr_get<ni>(p0)
val b0 = z2iforall$test<x0>(i0, x0, y0)
}(*where*)
}(*where*)
//
}(*where*)//end-of-[gseq_z2iforall(xs,ys)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< ys:t0 >
< y0:t0 >
gseq_z2irforall
  (xs, ys) = b0
where {
//
var i0: ni = (0)
//
val p0 = $addr(i0)
//
val b0 =
(
gseq_z2rforall
<xs><x0><ys><y0>(xs, ys))
where
{
#impltmp
z2rforall$test
<x0><y0>(x0, y0) =
(
$UN.p2tr_set<ni>(p0, i0+1); b0)
where
{
val i0 = $UN.p2tr_get<ni>(p0)
val b0 = z2irforall$test<x0>(i0, x0, y0)
}(*where*)
}(*where*)
//
}(*where*)//end-of-[gseq_z2irforall(xs, ys)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-10:
Sat 10 Aug 2024 07:14:36 PM EDT
*)
//
#impltmp
< xs:t0 >
< x0:t0 >
gseq_cmp
  (xs, ys) =
(
gseq_z2forcmp
<xs><x0><xs><x0>(xs, ys))
where
{
#impltmp
z2forcmp$test<x0> = g_cmp<x0>
}(*where*)//end-of-[gseq_cmp(xs,ys)]
//
#impltmp
< xs:t0 >
< x0:t0 >
< ys:t0 >
< y0:t0 >
gseq_z2forcmp
  (xs, ys) =
let
val xs =
gseq_strmize<xs><x0>(xs)
val ys =
gseq_strmize<ys><y0>(ys)
in//let
(
strm_vt_z2forcmp0<x0><y0>(xs, ys))
where
{
#impltmp
z2forcmp$test0<x0><y0> = z2forcmp$test<x0><y0>
}
end where
{
(*
val () =
(
  prints("gseq_z2forcmp: xs = ", xs, "\\n"))
val () =
(
  prints("gseq_z2forcmp: ys = ", ys, "\\n"))
*)
}(*where*)//let//end-of-[gseq_z2forcmp(xs, ys)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< ys:t0 >
< y0:t0 >
gseq_z2foritm
  (xs, ys) =
(
let
val _ =
gseq_z2forall
<xs><x0><ys><y0>(xs, ys)
end
) where
{
#impltmp
z2forall$test
<x0><y0>(x0, y0) = true
where
{ val () =
  z2foritm$work<x0><y0>(x0, y0) }
}(*where*)//end-of-[gseq_z2foritm(xs,ys)]
//
#impltmp
< xs:t0 >
< x0:t0 >
< ys:t0 >
< y0:t0 >
gseq_z2rforitm
  (xs, ys) =
(
let
val _ =
gseq_z2rforall
<xs><x0><ys><y0>(xs, ys)
end
) where
{
#impltmp
z2rforall$test
<x0><y0>(x0, y0) = true
where
{ val () =
  z2rforitm$work<x0><y0>(x0, y0) }
}(*where*)//end-of-[gseq_z2rforitm(xs,ys)]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< ys:t0 >
< y0:t0 >
gseq_z2iforitm
  (xs, ys) =
(
let
val _ =
gseq_z2iforall
<xs><x0><ys><y0>(xs, ys)
end
) where
{
#impltmp
z2iforall$test
<x0><y0>(i0, x0, y0) = true
where
{
val () =
z2iforitm$work<x0><y0>(i0, x0, y0) }
}(*where*)//end-of-[gseq_z2iforitm(xs,ys)]
//
#impltmp
< xs:t0 >
< x0:t0 >
< ys:t0 >
< y0:t0 >
gseq_z2irforitm
  (xs, ys) =
(
let
val _ =
gseq_z2irforall
<xs><x0><ys><y0>(xs, ys)
end
) where
{
#impltmp
z2irforall$test
<x0><y0>(i0, x0, y0) = true
where
{
val () =
z2irforitm$work<x0><y0>(i0, x0, y0) }
}(*where*)//end-of-[gseq_z2iforitm(xs,ys)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-04:
Sun 04 Aug 2024 07:26:14 AM EDT
*)
//
(*
HX-2024-08-04:
This one is BUGGY!!!
Can you spot the SUBTLE cause :)
#impltmp
< xs:t0 >
< x0:t0 >
< ys:t0 >
< y0:t0 >
gseq_x2forall
  (xs, ys) =
(
gseq_forall<xs><x0>(xs)) where
{
#impltmp
forall$test<x0>(x0) =
(
//
(*
HX:
this one is treated
as a recursive call!!!
*)
//
gseq_forall<ys><y0>(ys)) where
{
#impltmp
forall$test<y0>(y0) =
(
  x2forall$test<x0><y0>(x0, y0))
}(*where*)
}(*where*)//end-of-[gseq_x2forall(xs, ys)]
*)
//
#impltmp
< xs:t0 >
< x0:t0 >
< ys:t0 >
< y0:t0 >
gseq_x2forall
  (xs, ys) =
let
//
fun
forall$test_x0(x0) =
(
  gseq_forall<ys><y0>(ys)
) where
{
#impltmp
forall$test<y0>(y0) =
x2forall$test<x0><y0>(x0, y0) }
//
in//let
(
  gseq_forall<xs><x0>(xs)) where
{
#impltmp
forall$test<x0> = forall$test_x0(*x0*)
}
end//(*let*)//end-of-[gseq_x2forall(xs, ys)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
< ys:t0 >
< y0:t0 >
gseq_ix2forall
  (xs, ys) =
let
//
fun
iforall$test_x0(i0, x0) =
(
  gseq_iforall<ys><y0>(ys)
) where
{
#impltmp
iforall$test<y0>(j0, y0) =
ix2forall$test<x0><y0>(i0, x0, j0, y0)
}
//
in//let
(
  gseq_iforall<xs><x0>(xs)) where
{
#impltmp
iforall$test<x0> = iforall$test_x0(*i0,x0*)
}
end//(*let*)//end-of-[gseq_ix2forall(xs, ys)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_gseq002.dats] *)
(***********************************************************************)
`,
  "DATS/gsyn000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sat 27 Jul 2024 01:32:19 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-29:
Mon 29 Jul 2024 03:17:20 PM EDT
*)
//
#impltmp
< x0:t0 >
gs_add_a0() =
g_0<x0>((*void*))
//
#impltmp
< x0:t0 >
gs_add_a1(x1) = x1
//
#impltmp
< x0:t0 >
gs_add_a2
(x1, x2) =
(
g_add<x0>(x1, x2)
) (* end of [gs_add_a2] *)
#impltmp
< x0:t0 >
gs_add_a3
(x1, x2, x3) =
let
fun
f0(x, y) =
g_add<x0>(x, y)
in//let
  f0(f0(x1, x2), x3)
end (*let*) // end of [gs_add_a3]
#impltmp
< x0:t0 >
gs_add_a4
(x1, x2, x3, x4) =
let
fun
f0(x, y) =
g_add<x0>(x, y)
in//let
  f0(f0(f0(x1,x2),x3),x4)
end (*let*) // end of [gs_add_a4]
#impltmp
< x0:t0 >
gs_add_a5
(x1, x2, x3, x4, x5) =
let
fun
f0(x, y) =
g_add<x0>(x, y)
in//let
f0(f0(f0(f0(x1,x2),x3),x4),x5)
end (*let*) // end of [gs_add_a5]
#impltmp
< x0:t0 >
gs_add_a6
(x1, x2, x3, x4, x5, x6) =
let
fun
f0(x, y) =
g_add<x0>(x, y)
in//let
f0(f0(f0(f0(f0(x1,x2),x3),x4),x5),x6)
end (*let*) // end of [gs_add_a6]
#impltmp
< x0:t0 >
gs_add_a7
(x1, x2, x3, x4, x5, x6, x7) =
let
fun
f0(x, y) =
g_add<x0>(x, y)
in//let
f0(f0(f0(f0(f0(f0(x1,x2),x3),x4),x5),x6),x7)
end (*let*) // end of [gs_add_a7]
#impltmp
< x0:t0 >
gs_add_a8
(x1, x2, x3, x4, x5, x6, x7, x8) =
let
fun
f0(x, y) =
g_add<x0>(x, y)
in//let
f0(f0(f0(f0(f0(f0(f0(x1,x2),x3),x4),x5),x6),x7),x8)
end (*let*) // end of [gs_add_a8]
#impltmp
< x0:t0 >
gs_add_a9
(x1, x2, x3, x4, x5, x6, x7, x8, x9) =
let
fun
f0(x, y) =
g_add<x0>(x, y)
in//let
f0(f0(f0(f0(f0(f0(f0(f0(x1,x2),x3),x4),x5),x6),x7),x8),x9)
end (*let*) // end of [gs_add_a9]
//
#impltmp
< x0:t0 >
gs_add_a10
(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10) =
let
fun
f0(x, y) =
g_add<x0>(x, y)
in//let
f0(f0(f0(f0(f0(f0(f0(f0(f0(x1,x2),x3),x4),x5),x6),x7),x8),x9),x10)
end (*let*) // end of [gs_add_a10]
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
gs_add_a11
(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11) =
let
fun
f0(x, y) =
g_add<x0>(x, y)
in//let
f0(f0(f0(f0(f0(f0(f0(f0(f0(f0(x1,x2),x3),x4),x5),x6),x7),x8),x9),x10),x11)
end (*let*) // end of [gs_add_a11]
//
#impltmp
< x0:t0 >
gs_add_a12
(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12) =
let
fun
f0(x, y) =
g_add<x0>(x, y)
in//let
f0(f0(f0(f0(f0(f0(f0(f0(f0(f0(f0(x1,x2),x3),x4),x5),x6),x7),x8),x9),x10),x11),x12)
end (*let*) // end of [gs_add_a12]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-29:
Mon 29 Jul 2024 03:17:20 PM EDT
*)
//
#impltmp
< x0:t0 >
gs_mul_a0() =
g_1<x0>((*void*))
//
#impltmp
< x0:t0 >
gs_mul_a1(x1) = x1
//
#impltmp
< x0:t0 >
gs_mul_a2
(x1, x2) =
(
g_mul<x0>(x1, x2)
) (* end of [gs_mul_a2] *)
#impltmp
< x0:t0 >
gs_mul_a3
(x1, x2, x3) =
let
fun
f0(x, y) =
g_mul<x0>(x, y)
in//let
  f0(f0(x1, x2), x3)
end (*let*) // end of [gs_mul_a3]
#impltmp
< x0:t0 >
gs_mul_a4
(x1, x2, x3, x4) =
let
fun
f0(x, y) =
g_mul<x0>(x, y)
in//let
  f0(f0(f0(x1,x2),x3),x4)
end (*let*) // end of [gs_mul_a4]
#impltmp
< x0:t0 >
gs_mul_a5
(x1, x2, x3, x4, x5) =
let
fun
f0(x, y) =
g_mul<x0>(x, y)
in//let
f0(f0(f0(f0(x1,x2),x3),x4),x5)
end (*let*) // end of [gs_mul_a5]
#impltmp
< x0:t0 >
gs_mul_a6
(x1, x2, x3, x4, x5, x6) =
let
fun
f0(x, y) =
g_mul<x0>(x, y)
in//let
f0(f0(f0(f0(f0(x1,x2),x3),x4),x5),x6)
end (*let*) // end of [gs_mul_a6]
#impltmp
< x0:t0 >
gs_mul_a7
(x1, x2, x3, x4, x5, x6, x7) =
let
fun
f0(x, y) =
g_mul<x0>(x, y)
in//let
f0(f0(f0(f0(f0(f0(x1,x2),x3),x4),x5),x6),x7)
end (*let*) // end of [gs_mul_a7]
#impltmp
< x0:t0 >
gs_mul_a8
(x1, x2, x3, x4, x5, x6, x7, x8) =
let
fun
f0(x, y) =
g_mul<x0>(x, y)
in//let
f0(f0(f0(f0(f0(f0(f0(x1,x2),x3),x4),x5),x6),x7),x8)
end (*let*) // end of [gs_mul_a8]
#impltmp
< x0:t0 >
gs_mul_a9
(x1, x2, x3, x4, x5, x6, x7, x8, x9) =
let
fun
f0(x, y) =
g_mul<x0>(x, y)
in//let
f0(f0(f0(f0(f0(f0(f0(f0(x1,x2),x3),x4),x5),x6),x7),x8),x9)
end (*let*) // end of [gs_mul_a9]
//
#impltmp
< x0:t0 >
gs_mul_a10
(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10) =
let
fun
f0(x, y) =
g_mul<x0>(x, y)
in//let
f0(f0(f0(f0(f0(f0(f0(f0(f0(x1,x2),x3),x4),x5),x6),x7),x8),x9),x10)
end (*let*) // end of [gs_mul_a10]
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
gs_mul_a11
(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11) =
let
fun
f0(x, y) =
g_mul<x0>(x, y)
in//let
f0(f0(f0(f0(f0(f0(f0(f0(f0(f0(x1,x2),x3),x4),x5),x6),x7),x8),x9),x10),x11)
end (*let*) // end of [gs_mul_a11]
//
#impltmp
< x0:t0 >
gs_mul_a12
(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12) =
let
fun
f0(x, y) =
g_mul<x0>(x, y)
in//let
f0(f0(f0(f0(f0(f0(f0(f0(f0(f0(f0(x1,x2),x3),x4),x5),x6),x7),x8),x9),x10),x11),x12)
end (*let*) // end of [gs_mul_a12]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-29:
Mon 29 Jul 2024 03:17:20 PM EDT
*)
//
(*
#impltmp
< x0:t0 >
gs_max_a0() =
( -infinity )
#impltmp
< x0:t0 >
gs_max_a1(x1) = x1
*)
//
#impltmp
< x0:t0 >
gs_max_a2
(x1, x2) =
(
g_max<x0>(x1, x2)
) (* end of [gs_max_a2] *)
#impltmp
< x0:t0 >
gs_max_a3
(x1, x2, x3) =
let
fun
f0(x, y) =
g_max<x0>(x, y)
in//let
  f0(f0(x1, x2), x3)
end (*let*) // end of [gs_max_a3]
#impltmp
< x0:t0 >
gs_max_a4
(x1, x2, x3, x4) =
let
fun
f0(x, y) =
g_max<x0>(x, y)
in//let
  f0(f0(f0(x1,x2),x3),x4)
end (*let*) // end of [gs_max_a4]
#impltmp
< x0:t0 >
gs_max_a5
(x1, x2, x3, x4, x5) =
let
fun
f0(x, y) =
g_max<x0>(x, y)
in//let
f0(f0(f0(f0(x1,x2),x3),x4),x5)
end (*let*) // end of [gs_max_a5]
#impltmp
< x0:t0 >
gs_max_a6
(x1, x2, x3, x4, x5, x6) =
let
fun
f0(x, y) =
g_max<x0>(x, y)
in//let
f0(f0(f0(f0(f0(x1,x2),x3),x4),x5),x6)
end (*let*) // end of [gs_max_a6]
#impltmp
< x0:t0 >
gs_max_a7
(x1, x2, x3, x4, x5, x6, x7) =
let
fun
f0(x, y) =
g_max<x0>(x, y)
in//let
f0(f0(f0(f0(f0(f0(x1,x2),x3),x4),x5),x6),x7)
end (*let*) // end of [gs_max_a7]
#impltmp
< x0:t0 >
gs_max_a8
(x1, x2, x3, x4, x5, x6, x7, x8) =
let
fun
f0(x, y) =
g_max<x0>(x, y)
in//let
f0(f0(f0(f0(f0(f0(f0(x1,x2),x3),x4),x5),x6),x7),x8)
end (*let*) // end of [gs_max_a8]
#impltmp
< x0:t0 >
gs_max_a9
(x1, x2, x3, x4, x5, x6, x7, x8, x9) =
let
fun
f0(x, y) =
g_max<x0>(x, y)
in//let
f0(f0(f0(f0(f0(f0(f0(f0(x1,x2),x3),x4),x5),x6),x7),x8),x9)
end (*let*) // end of [gs_max_a9]
//
#impltmp
< x0:t0 >
gs_max_a10
(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10) =
let
fun
f0(x, y) =
g_max<x0>(x, y)
in//let
f0(f0(f0(f0(f0(f0(f0(f0(f0(x1,x2),x3),x4),x5),x6),x7),x8),x9),x10)
end (*let*) // end of [gs_max_a10]
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
gs_max_a11
(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11) =
let
fun
f0(x, y) =
g_max<x0>(x, y)
in//let
f0(f0(f0(f0(f0(f0(f0(f0(f0(f0(x1,x2),x3),x4),x5),x6),x7),x8),x9),x10),x11)
end (*let*) // end of [gs_max_a11]
//
#impltmp
< x0:t0 >
gs_max_a12
(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12) =
let
fun
f0(x, y) =
g_max<x0>(x, y)
in//let
f0(f0(f0(f0(f0(f0(f0(f0(f0(f0(f0(x1,x2),x3),x4),x5),x6),x7),x8),x9),x10),x11),x12)
end (*let*) // end of [gs_max_a12]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-29:
Mon 29 Jul 2024 03:17:20 PM EDT
*)
//
(*
#impltmp
< x0:t0 >
gs_min_a0() =
( +infinity )
#impltmp
< x0:t0 >
gs_min_a1(x1) = x1
*)
//
#impltmp
< x0:t0 >
gs_min_a2
(x1, x2) =
(
g_min<x0>(x1, x2)
) (* end of [gs_min_a2] *)
#impltmp
< x0:t0 >
gs_min_a3
(x1, x2, x3) =
let
fun
f0(x, y) =
g_min<x0>(x, y)
in//let
  f0(f0(x1, x2), x3)
end (*let*) // end of [gs_min_a3]
#impltmp
< x0:t0 >
gs_min_a4
(x1, x2, x3, x4) =
let
fun
f0(x, y) =
g_min<x0>(x, y)
in//let
  f0(f0(f0(x1,x2),x3),x4)
end (*let*) // end of [gs_min_a4]
#impltmp
< x0:t0 >
gs_min_a5
(x1, x2, x3, x4, x5) =
let
fun
f0(x, y) =
g_min<x0>(x, y)
in//let
f0(f0(f0(f0(x1,x2),x3),x4),x5)
end (*let*) // end of [gs_min_a5]
#impltmp
< x0:t0 >
gs_min_a6
(x1, x2, x3, x4, x5, x6) =
let
fun
f0(x, y) =
g_min<x0>(x, y)
in//let
f0(f0(f0(f0(f0(x1,x2),x3),x4),x5),x6)
end (*let*) // end of [gs_min_a6]
#impltmp
< x0:t0 >
gs_min_a7
(x1, x2, x3, x4, x5, x6, x7) =
let
fun
f0(x, y) =
g_min<x0>(x, y)
in//let
f0(f0(f0(f0(f0(f0(x1,x2),x3),x4),x5),x6),x7)
end (*let*) // end of [gs_min_a7]
#impltmp
< x0:t0 >
gs_min_a8
(x1, x2, x3, x4, x5, x6, x7, x8) =
let
fun
f0(x, y) =
g_min<x0>(x, y)
in//let
f0(f0(f0(f0(f0(f0(f0(x1,x2),x3),x4),x5),x6),x7),x8)
end (*let*) // end of [gs_min_a8]
#impltmp
< x0:t0 >
gs_min_a9
(x1, x2, x3, x4, x5, x6, x7, x8, x9) =
let
fun
f0(x, y) =
g_min<x0>(x, y)
in//let
f0(f0(f0(f0(f0(f0(f0(f0(x1,x2),x3),x4),x5),x6),x7),x8),x9)
end (*let*) // end of [gs_min_a9]
//
#impltmp
< x0:t0 >
gs_min_a10
(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10) =
let
fun
f0(x, y) =
g_min<x0>(x, y)
in//let
f0(f0(f0(f0(f0(f0(f0(f0(f0(x1,x2),x3),x4),x5),x6),x7),x8),x9),x10)
end (*let*) // end of [gs_min_a10]
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
gs_min_a11
(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11) =
let
fun
f0(x, y) =
g_min<x0>(x, y)
in//let
f0(f0(f0(f0(f0(f0(f0(f0(f0(f0(x1,x2),x3),x4),x5),x6),x7),x8),x9),x10),x11)
end (*let*) // end of [gs_min_a11]
//
#impltmp
< x0:t0 >
gs_min_a12
(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12) =
let
fun
f0(x, y) =
g_min<x0>(x, y)
in//let
f0(f0(f0(f0(f0(f0(f0(f0(f0(f0(f0(x1,x2),x3),x4),x5),x6),x7),x8),x9),x10),x11),x12)
end (*let*) // end of [gs_min_a12]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:vt >
gs_free_a1
 (  x0  ) =
(
  g_free<x0>(x0))
//
#impltmp
< x0:vt >
< x1:vt >
gs_free_a2
 (x0, x1) =
(
  g_free<x0>(x0); g_free<x1>(x1))
//
#impltmp
< x0:vt >
< x1:vt >
< x2:vt >
gs_free_a3
( x0
, x1, x2) =
( g_free<x0>(x0)
; g_free<x1>(x1); g_free<x2>(x2))
//
#impltmp
< x0:vt >
< x1:vt >
< x2:vt >
< x3:vt >
gs_free_a4
( x0, x1
, x2, x3) =
( g_free<x0>(x0); g_free<x1>(x1)
; g_free<x2>(x2); g_free<x3>(x3))
//
#impltmp
< x0:vt >
< x1:vt >
< x2:vt >
< x3:vt >
< x4:vt >
gs_free_a5
( x0, x1
, x2, x3, x4) =
( g_free<x0>(x0)
; g_free<x1>(x1); g_free<x2>(x2)
; g_free<x3>(x3); g_free<x4>(x4))
//
#impltmp
< x0:vt >
< x1:vt >
< x2:vt >
< x3:vt >
< x4:vt >
< x5:vt >
gs_free_a6
( x0, x1, x2
, x3, x4, x5) =
( g_free<x0>(x0); g_free<x1>(x1)
; g_free<x2>(x2); g_free<x3>(x3)
; g_free<x4>(x4); g_free<x5>(x5))
//
#impltmp
< x0:vt >
< x1:vt >
< x2:vt >
< x3:vt >
< x4:vt >
< x5:vt >
< x6:vt >
gs_free_a7
( x0, x1, x2
, x3, x4, x5, x6) =
( g_free<x0>(x0)
; g_free<x1>(x1); g_free<x2>(x2)
; g_free<x3>(x3); g_free<x4>(x4)
; g_free<x5>(x5); g_free<x6>(x6))
//
#impltmp
< x0:vt >
< x1:vt >
< x2:vt >
< x3:vt >
< x4:vt >
< x5:vt >
< x6:vt >
< x7:vt >
gs_free_a8
( x0, x1, x2, x3
, x4, x5, x6, x7) =
( g_free<x0>(x0); g_free<x1>(x1)
; g_free<x2>(x2); g_free<x3>(x3)
; g_free<x4>(x4); g_free<x5>(x5)
; g_free<x6>(x6); g_free<x7>(x7))
//
#impltmp
< x0:vt >
< x1:vt >
< x2:vt >
< x3:vt >
< x4:vt >
< x5:vt >
< x6:vt >
< x7:vt >
< x8:vt >
gs_free_a9
( x0, x1, x2, x3
, x4, x5, x6, x7, x8) =
( g_free<x0>(x0)
; g_free<x1>(x1); g_free<x2>(x2)
; g_free<x3>(x3); g_free<x4>(x4)
; g_free<x5>(x5); g_free<x6>(x6)
; g_free<x7>(x7); g_free<x8>(x8))
//
#impltmp
< x0:vt >
< x1:vt >
< x2:vt >
< x3:vt >
< x4:vt >
< x5:vt >
< x6:vt >
< x7:vt >
< x8:vt >
< x9:vt >
gs_free_a10
( x0, x1, x2, x3, x4
, x5, x6, x7, x8, x9) =
( g_free<x0>(x0); g_free<x1>(x1)
; g_free<x2>(x2); g_free<x3>(x3)
; g_free<x4>(x4); g_free<x5>(x5)
; g_free<x6>(x6); g_free<x7>(x7)
; g_free<x8>(x8); g_free<x9>(x9))
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
< x1:vt >
< x2:vt >
< x3:vt >
< x4:vt >
< x5:vt >
< x6:vt >
< x7:vt >
< x8:vt >
< x9:vt >
< x10:vt >
gs_free_a11
( x0, x1, x2, x3, x4
, x5, x6, x7, x8, x9, x10) =
( g_free<x0>(x0)
; g_free<x1>(x1); g_free<x2>(x2)
; g_free<x3>(x3); g_free<x4>(x4)
; g_free<x5>(x5); g_free<x6>(x6)
; g_free<x7>(x7); g_free<x8>(x8)
; g_free<x9>(x9); g_free<x10>(x10))
//
#impltmp
< x0:vt >
< x1:vt >
< x2:vt >
< x3:vt >
< x4:vt >
< x5:vt >
< x6:vt >
< x7:vt >
< x8:vt >
< x9:vt >
< x10:vt >
< x11:vt >
gs_free_a12
( x0, x1, x2, x3, x4, x5
, x6, x7, x8, x9, x10, x11) =
( g_free<x0>(x0); g_free<x1>(x1)
; g_free<x2>(x2); g_free<x3>(x3)
; g_free<x4>(x4); g_free<x5>(x5)
; g_free<x6>(x6); g_free<x7>(x7)
; g_free<x8>(x8); g_free<x9>(x9)
; g_free<x10>(x10); g_free<x11>(x11))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
gs_work$beg() = ()
#impltmp
<(*tmp*)>
gs_work$sep() = ()
#impltmp
<(*tmp*)>
gs_work$end() = ()
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
gs_work_a0
 ((*0*) ) =
(
gs_work$beg(); gs_work$end())
//
#impltmp
< x0:t0 >
gs_work_a1
 (  x0  ) =
let
val () =
gs_work$beg() in//let
(
g_work<x0>(x0); gs_work$end())
end//let//end-of-[gs_work_a1(...)]
//
#impltmp
< x0:t0 >
< x1:t0 >
gs_work_a2
 (x0, x1) =
let
val () =
gs_work$beg() in//let
(
  g_work<x0>(x0); gs_work$sep()
; g_work<x1>(x1); gs_work$end())
end//let//end-of-[gs_work_a2(...)]
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
gs_work_a3
( x0
, x1, x2) =
let
val () =
gs_work$beg() in//let
(
  g_work<x0>(x0); gs_work$sep()
; g_work<x1>(x1); gs_work$sep()
; g_work<x2>(x2); gs_work$end())
end//let//end-of-[gs_work_a3(...)]
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
< x3:t0 >
gs_work_a4
( x0, x1
, x2, x3) =
let
val () =
gs_work$beg() in//let
(
  g_work<x0>(x0); gs_work$sep()
; g_work<x1>(x1); gs_work$sep()
; g_work<x2>(x2); gs_work$sep()
; g_work<x3>(x3); gs_work$end())
end//let//end-of-[gs_work_a4(...)]
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
< x3:t0 >
< x4:t0 >
gs_work_a5
( x0, x1
, x2, x3, x4) =
let
val () =
gs_work$beg() in//let
(
  g_work<x0>(x0); gs_work$sep()
; g_work<x1>(x1); gs_work$sep()
; g_work<x2>(x2); gs_work$sep()
; g_work<x3>(x3); gs_work$sep()
; g_work<x4>(x4); gs_work$end())
end//let//end-of-[gs_work_a5(...)]
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
< x3:t0 >
< x4:t0 >
< x5:t0 >
gs_work_a6
( x0, x1, x2
, x3, x4, x5) =
let
val () =
gs_work$beg() in//let
(
  g_work<x0>(x0); gs_work$sep()
; g_work<x1>(x1); gs_work$sep()
; g_work<x2>(x2); gs_work$sep()
; g_work<x3>(x3); gs_work$sep()
; g_work<x4>(x4); gs_work$sep()
; g_work<x5>(x5); gs_work$end())
end//let//end-of-[gs_work_a6(...)]
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
< x3:t0 >
< x4:t0 >
< x5:t0 >
< x6:t0 >
gs_work_a7
( x0, x1, x2
, x3, x4, x5, x6) =
let
val () =
gs_work$beg() in//let
(
  g_work<x0>(x0); gs_work$sep()
; g_work<x1>(x1); gs_work$sep()
; g_work<x2>(x2); gs_work$sep()
; g_work<x3>(x3); gs_work$sep()
; g_work<x4>(x4); gs_work$sep()
; g_work<x5>(x5); gs_work$sep()
; g_work<x6>(x6); gs_work$end())
end//let//end-of-[gs_work_a7(...)]
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
< x3:t0 >
< x4:t0 >
< x5:t0 >
< x6:t0 >
< x7:t0 >
gs_work_a8
( x0, x1, x2, x3
, x4, x5, x6, x7) =
let
val () =
gs_work$beg() in//let
(
  g_work<x0>(x0); gs_work$sep()
; g_work<x1>(x1); gs_work$sep()
; g_work<x2>(x2); gs_work$sep()
; g_work<x3>(x3); gs_work$sep()
; g_work<x4>(x4); gs_work$sep()
; g_work<x5>(x5); gs_work$sep()
; g_work<x6>(x6); gs_work$sep()
; g_work<x7>(x7); gs_work$end())
end//let//end-of-[gs_work_a8(...)]
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
< x3:t0 >
< x4:t0 >
< x5:t0 >
< x6:t0 >
< x7:t0 >
< x8:t0 >
gs_work_a9
( x0, x1, x2, x3
, x4, x5, x6, x7, x8) =
let
val () =
gs_work$beg() in//let
(
  g_work<x0>(x0); gs_work$sep()
; g_work<x1>(x1); gs_work$sep()
; g_work<x2>(x2); gs_work$sep()
; g_work<x3>(x3); gs_work$sep()
; g_work<x4>(x4); gs_work$sep()
; g_work<x5>(x5); gs_work$sep()
; g_work<x6>(x6); gs_work$sep()
; g_work<x7>(x7); gs_work$sep()
; g_work<x8>(x8); gs_work$end())
end//let//end-of-[gs_work_a9(...)]
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
< x3:t0 >
< x4:t0 >
< x5:t0 >
< x6:t0 >
< x7:t0 >
< x8:t0 >
< x9:t0 >
gs_work_a10
( x0, x1, x2, x3, x4
, x5, x6, x7, x8, x9) =
let
val () =
gs_work$beg() in//let
(
  g_work<x0>(x0); gs_work$sep()
; g_work<x1>(x1); gs_work$sep()
; g_work<x2>(x2); gs_work$sep()
; g_work<x3>(x3); gs_work$sep()
; g_work<x4>(x4); gs_work$sep()
; g_work<x5>(x5); gs_work$sep()
; g_work<x6>(x6); gs_work$sep()
; g_work<x7>(x7); gs_work$sep()
; g_work<x8>(x8); gs_work$sep()
; g_work<x9>(x9); gs_work$end())
end//let//end-of-[gs_work_a10(...)]
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
< x3:t0 >
< x4:t0 >
< x5:t0 >
< x6:t0 >
< x7:t0 >
< x8:t0 >
< x9:t0 >
< x10:t0 >
gs_work_a11
( x0, x1, x2, x3, x4
, x5, x6, x7, x8, x9, x10) =
let
val () =
gs_work$beg() in//let
(
  g_work<x0>(x0); gs_work$sep()
; g_work<x1>(x1); gs_work$sep()
; g_work<x2>(x2); gs_work$sep()
; g_work<x3>(x3); gs_work$sep()
; g_work<x4>(x4); gs_work$sep()
; g_work<x5>(x5); gs_work$sep()
; g_work<x6>(x6); gs_work$sep()
; g_work<x7>(x7); gs_work$sep()
; g_work<x8>(x8); gs_work$sep()
; g_work<x9>(x9); gs_work$sep()
; g_work<x10>(x10); gs_work$end())
end//let//end-of-[gs_work_a11(...)]
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
< x3:t0 >
< x4:t0 >
< x5:t0 >
< x6:t0 >
< x7:t0 >
< x8:t0 >
< x9:t0 >
< x10:t0 >
< x11:t0 >
gs_work_a12
( x0, x1, x2, x3, x4, x5
, x6, x7, x8, x9, x10, x11) =
let
val () =
gs_work$beg() in//let
(
  g_work<x0>(x0); gs_work$sep()
; g_work<x1>(x1); gs_work$sep()
; g_work<x2>(x2); gs_work$sep()
; g_work<x3>(x3); gs_work$sep()
; g_work<x4>(x4); gs_work$sep()
; g_work<x5>(x5); gs_work$sep()
; g_work<x6>(x6); gs_work$sep()
; g_work<x7>(x7); gs_work$sep()
; g_work<x8>(x8); gs_work$sep()
; g_work<x9>(x9); gs_work$sep()
; g_work<x10>(x10); gs_work$sep()
; g_work<x11>(x11); gs_work$end())
end//let//end-of-[gs_work_a12(...)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
gs_tostr_a0
 ((*00*)) = ""
#impltmp
< x0:t0 >
gs_tostr_a1
 (  x0  ) = tostr<x0>(x0)
//
#impltmp
< x0:t0 >
< x1:t0 >
gs_tostr_a2
 (x0, x1) =
strn_fmake_fwork<>
(
lam(work) =>
(
strn_foritm(tostr<x0>(x0));
strn_foritm(tostr<x1>(x1)))
where
{
#typedef c1 = cgtz
#impltmp foritm$work<c1> = work}
)
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
gs_tostr_a3
( x0
, x1, x2) =
strn_fmake_fwork<>
(
lam(work) =>
(
strn_foritm(tostr<x0>(x0));
strn_foritm(tostr<x1>(x1));
strn_foritm(tostr<x2>(x2)))
where
{
#typedef c1 = cgtz
#impltmp foritm$work<c1> = work}
)
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
< x3:t0 >
gs_tostr_a4
( x0, x1
, x2, x3) =
strn_fmake_fwork<>
(
lam(work) =>
(
strn_foritm(tostr<x0>(x0));
strn_foritm(tostr<x1>(x1));
strn_foritm(tostr<x2>(x2));
strn_foritm(tostr<x3>(x3)))
where
{
#typedef c1 = cgtz
#impltmp foritm$work<c1> = work}
)
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
< x3:t0 >
< x4:t0 >
gs_tostr_a5
( x0, x1
, x2, x3, x4) =
strn_fmake_fwork<>
(
lam(work) =>
(
strn_foritm(tostr<x0>(x0));
strn_foritm(tostr<x1>(x1));
strn_foritm(tostr<x2>(x2));
strn_foritm(tostr<x3>(x3));
strn_foritm(tostr<x4>(x4)))
where
{
#typedef c1 = cgtz
#impltmp foritm$work<c1> = work}
)
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
< x3:t0 >
< x4:t0 >
< x5:t0 >
gs_tostr_a6
( x0, x1, x2
, x3, x4, x5) =
strn_fmake_fwork<>
(
lam(work) =>
(
strn_foritm(tostr<x0>(x0));
strn_foritm(tostr<x1>(x1));
strn_foritm(tostr<x2>(x2));
strn_foritm(tostr<x3>(x3));
strn_foritm(tostr<x4>(x4));
strn_foritm(tostr<x5>(x5)))
where
{
#typedef c1 = cgtz
#impltmp foritm$work<c1> = work}
)
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
< x3:t0 >
< x4:t0 >
< x5:t0 >
< x6:t0 >
gs_tostr_a7
( x0
, x1, x2, x3
, x4, x5, x6) =
strn_fmake_fwork<>
(
lam(work) =>
(
strn_foritm(tostr<x0>(x0));
strn_foritm(tostr<x1>(x1));
strn_foritm(tostr<x2>(x2));
strn_foritm(tostr<x3>(x3));
strn_foritm(tostr<x4>(x4));
strn_foritm(tostr<x5>(x5));
strn_foritm(tostr<x6>(x6)))
where
{
#typedef c1 = cgtz
#impltmp foritm$work<c1> = work}
)
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
< x3:t0 >
< x4:t0 >
< x5:t0 >
< x6:t0 >
< x7:t0 >
gs_tostr_a8
( x0, x1
, x2, x3, x4
, x5, x6, x7) =
strn_fmake_fwork<>
(
lam(work) =>
(
strn_foritm(tostr<x0>(x0));
strn_foritm(tostr<x1>(x1));
strn_foritm(tostr<x2>(x2));
strn_foritm(tostr<x3>(x3));
strn_foritm(tostr<x4>(x4));
strn_foritm(tostr<x5>(x5));
strn_foritm(tostr<x6>(x6));
strn_foritm(tostr<x7>(x7)))
where
{
#typedef c1 = cgtz
#impltmp foritm$work<c1> = work}
)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
gs_print$beg() = ()
#impltmp
<(*tmp*)>
gs_print$sep() = ()
#impltmp
<(*tmp*)>
gs_print$end() = ()
(*
#impltmp
<(*tmp*)>
g_print$end() = strn_print("\\n")
*)
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
gs_print_a0
 ((*00*)) =
(
gs_print$beg(); gs_print$end())
//
#impltmp
< x0:t0 >
gs_print_a1
 (  x0  ) =
let
val () =
gs_print$beg() in//let
(
g_print<x0>(x0); gs_print$end())
end//let//end-of-[gs_print_a1(...)]
//
#impltmp
< x0:t0 >
< x1:t0 >
gs_print_a2
 (x0, x1) =
let
val () =
gs_print$beg() in//let
(
  g_print<x0>(x0); gs_print$sep()
; g_print<x1>(x1); gs_print$end())
end//let//end-of-[gs_print_a2(...)]
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
gs_print_a3
( x0
, x1, x2) =
let
val () =
gs_print$beg() in//let
(
  g_print<x0>(x0); gs_print$sep()
; g_print<x1>(x1); gs_print$sep()
; g_print<x2>(x2); gs_print$end())
end//let//end-of-[gs_print_a3(...)]
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
< x3:t0 >
gs_print_a4
( x0, x1
, x2, x3) =
let
val () =
gs_print$beg() in//let
(
  g_print<x0>(x0); gs_print$sep()
; g_print<x1>(x1); gs_print$sep()
; g_print<x2>(x2); gs_print$sep()
; g_print<x3>(x3); gs_print$end())
end//let//end-of-[gs_print_a4(...)]
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
< x3:t0 >
< x4:t0 >
gs_print_a5
( x0, x1
, x2, x3, x4) =
let
val () =
gs_print$beg() in//let
(
  g_print<x0>(x0); gs_print$sep()
; g_print<x1>(x1); gs_print$sep()
; g_print<x2>(x2); gs_print$sep()
; g_print<x3>(x3); gs_print$sep()
; g_print<x4>(x4); gs_print$end())
end//let//end-of-[gs_print_a5(...)]
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
< x3:t0 >
< x4:t0 >
< x5:t0 >
gs_print_a6
( x0, x1, x2
, x3, x4, x5) =
let
val () =
gs_print$beg() in//let
(
  g_print<x0>(x0); gs_print$sep()
; g_print<x1>(x1); gs_print$sep()
; g_print<x2>(x2); gs_print$sep()
; g_print<x3>(x3); gs_print$sep()
; g_print<x4>(x4); gs_print$sep()
; g_print<x5>(x5); gs_print$end())
end//let//end-of-[gs_print_a6(...)]
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
< x3:t0 >
< x4:t0 >
< x5:t0 >
< x6:t0 >
gs_print_a7
( x0, x1, x2
, x3, x4, x5, x6) =
let
val () =
gs_print$beg() in//let
(
  g_print<x0>(x0); gs_print$sep()
; g_print<x1>(x1); gs_print$sep()
; g_print<x2>(x2); gs_print$sep()
; g_print<x3>(x3); gs_print$sep()
; g_print<x4>(x4); gs_print$sep()
; g_print<x5>(x5); gs_print$sep()
; g_print<x6>(x6); gs_print$end())
end//let//end-of-[gs_print_a7(...)]
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
< x3:t0 >
< x4:t0 >
< x5:t0 >
< x6:t0 >
< x7:t0 >
gs_print_a8
( x0, x1, x2, x3
, x4, x5, x6, x7) =
let
val () =
gs_print$beg() in//let
(
  g_print<x0>(x0); gs_print$sep()
; g_print<x1>(x1); gs_print$sep()
; g_print<x2>(x2); gs_print$sep()
; g_print<x3>(x3); gs_print$sep()
; g_print<x4>(x4); gs_print$sep()
; g_print<x5>(x5); gs_print$sep()
; g_print<x6>(x6); gs_print$sep()
; g_print<x7>(x7); gs_print$end())
end//let//end-of-[gs_print_a8(...)]
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
< x3:t0 >
< x4:t0 >
< x5:t0 >
< x6:t0 >
< x7:t0 >
< x8:t0 >
gs_print_a9
( x0, x1, x2, x3
, x4, x5, x6, x7, x8) =
let
val () =
gs_print$beg() in//let
(
  g_print<x0>(x0); gs_print$sep()
; g_print<x1>(x1); gs_print$sep()
; g_print<x2>(x2); gs_print$sep()
; g_print<x3>(x3); gs_print$sep()
; g_print<x4>(x4); gs_print$sep()
; g_print<x5>(x5); gs_print$sep()
; g_print<x6>(x6); gs_print$sep()
; g_print<x7>(x7); gs_print$sep()
; g_print<x8>(x8); gs_print$end())
end//let//end-of-[gs_print_a9(...)]
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
< x3:t0 >
< x4:t0 >
< x5:t0 >
< x6:t0 >
< x7:t0 >
< x8:t0 >
< x9:t0 >
gs_print_a10
( x0, x1, x2, x3, x4
, x5, x6, x7, x8, x9) =
let
val () =
gs_print$beg() in//let
(
  g_print<x0>(x0); gs_print$sep()
; g_print<x1>(x1); gs_print$sep()
; g_print<x2>(x2); gs_print$sep()
; g_print<x3>(x3); gs_print$sep()
; g_print<x4>(x4); gs_print$sep()
; g_print<x5>(x5); gs_print$sep()
; g_print<x6>(x6); gs_print$sep()
; g_print<x7>(x7); gs_print$sep()
; g_print<x8>(x8); gs_print$sep()
; g_print<x9>(x9); gs_print$end())
end//let//end-of-[gs_print_a10(...)]
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
< x3:t0 >
< x4:t0 >
< x5:t0 >
< x6:t0 >
< x7:t0 >
< x8:t0 >
< x9:t0 >
< x10:t0 >
gs_print_a11
( x0, x1, x2, x3, x4
, x5, x6, x7, x8, x9, x10) =
let
val () =
gs_print$beg() in//let
(
  g_print<x0>(x0); gs_print$sep()
; g_print<x1>(x1); gs_print$sep()
; g_print<x2>(x2); gs_print$sep()
; g_print<x3>(x3); gs_print$sep()
; g_print<x4>(x4); gs_print$sep()
; g_print<x5>(x5); gs_print$sep()
; g_print<x6>(x6); gs_print$sep()
; g_print<x7>(x7); gs_print$sep()
; g_print<x8>(x8); gs_print$sep()
; g_print<x9>(x9); gs_print$sep()
; g_print<x10>(x10); gs_print$end()
)
end//let//end-of-[gs_print_a11(...)]
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
< x3:t0 >
< x4:t0 >
< x5:t0 >
< x6:t0 >
< x7:t0 >
< x8:t0 >
< x9:t0 >
< x10:t0 >
< x11:t0 >
gs_print_a12
( x0, x1, x2, x3, x4, x5
, x6, x7, x8, x9, x10, x11) =
let
val () =
gs_print$beg() in//let
(
  g_print<x0>(x0); gs_print$sep()
; g_print<x1>(x1); gs_print$sep()
; g_print<x2>(x2); gs_print$sep()
; g_print<x3>(x3); gs_print$sep()
; g_print<x4>(x4); gs_print$sep()
; g_print<x5>(x5); gs_print$sep()
; g_print<x6>(x6); gs_print$sep()
; g_print<x7>(x7); gs_print$sep()
; g_print<x8>(x8); gs_print$sep()
; g_print<x9>(x9); gs_print$sep()
; g_print<x10>(x10); gs_print$sep()
; g_print<x11>(x11); gs_print$end()
)
end//let//end-of-[gs_print_a12(...)]
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
gs_println_a0
 ((*0*)) =
(
  gs_print_a0<>((*0*)); g_print("\\n"))
//
#impltmp
< x0:t0 >
gs_println_a1
 (  x0  ) =
(
  gs_print_a1<x0>( x0 ); g_print("\\n"))
//
#impltmp
< x0:t0 >
< x1:t0 >
gs_println_a2
 (x0, x1) =
(
  gs_print_a2<x0><x1>(x0,x1); g_print("\\n"))
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
gs_println_a3
( x0
, x1, x2) =
(
  gs_print_a3<x0><x1><x2>(x0,x1,x2); g_print("\\n"))
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
< x3:t0 >
gs_println_a4
( x0, x1
, x2, x3) =
(
  gs_print_a4<x0><x1><x2><x3>(x0,x1,x2,x3); g_print("\\n"))
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
< x3:t0 >
< x4:t0 >
gs_println_a5
( x0, x1
, x2, x3, x4) =
(
  gs_print_a5<x0><x1><x2><x3><x4>(x0,x1,x2,x3,x4); g_print("\\n"))
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
< x3:t0 >
< x4:t0 >
< x5:t0 >
gs_println_a6
( x0, x1, x2
, x3, x4, x5) =
(
  gs_print_a6<x0><x1><x2><x3><x4><x5>(x0,x1,x2,x3,x4,x5); g_print("\\n"))
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
< x3:t0 >
< x4:t0 >
< x5:t0 >
< x6:t0 >
gs_println_a7
( x0, x1, x2
, x3, x4, x5, x6) =
(
  gs_print_a7<x0><x1><x2><x3><x4><x5><x6>(x0,x1,x2,x3,x4,x5,x6); g_print("\\n"))
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
< x3:t0 >
< x4:t0 >
< x5:t0 >
< x6:t0 >
< x7:t0 >
gs_println_a8
( x0, x1, x2, x3
, x4, x5, x6, x7) =
(
  gs_print_a8<x0><x1><x2><x3><x4><x5><x6><x7>(x0,x1,x2,x3,x4,x5,x6,x7); g_print("\\n"))
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
< x3:t0 >
< x4:t0 >
< x5:t0 >
< x6:t0 >
< x7:t0 >
< x8:t0 >
gs_println_a9
( x0
, x1, x2, x3, x4
, x5, x6, x7, x8) =
(
  gs_print_a9<x0><x1><x2><x3><x4><x5><x6><x7><x8>(x0,x1,x2,x3,x4,x5,x6,x7,x8); g_print("\\n"))
//
#impltmp
< x0:t0 >
< x1:t0 >
< x2:t0 >
< x3:t0 >
< x4:t0 >
< x5:t0 >
< x6:t0 >
< x7:t0 >
< x8:t0 >
< x9:t0 >
gs_println_a10
( x0, x1
, x2, x3, x4, x5
, x6, x7, x8, x9) =
(
  gs_print_a10<x0><x1><x2><x3><x4><x5><x6><x7><x8><x9>(x0,x1,x2,x3,x4,x5,x6,x7,x8,x9); g_print("\\n"))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-24:
Wed 31 Jul 2024 08:01:45 PM EDT
*)
//
(*
#impltmp
< xs:t0 >
gs_append_a0
  ((*0*)) =
g_0<xs>((*void*))
*)
//
(*
#impltmp
< xs:t0 >
gs_append_a1
  ( y1 ) = (y1)
*)
//
#impltmp
< xs:t0 >
gs_append_a2
  (y1, y2) =
(
g_append<xs>(y1, y2)
) (* end of [gs_append_a2] *)
#impltmp
< xs:t0 >
gs_append_a3
(y1, y2, y3) =
let
fun
f0(u, v) =
g_append<xs>(u, v)
in//let
  f0(f0(y1, y2), y3)
end (*let*) // end of [gs_append_a3]
#impltmp
< xs:t0 >
gs_append_a4
(y1, y2, y3, y4) =
let
fun
f0(u, v) =
g_append<xs>(u, v)
in//let
  f0(f0(f0(y1,y2),y3),y4)
end (*let*) // end of [gs_append_a4]
#impltmp
< xs:t0 >
gs_append_a5
(y1, y2, y3, y4, y5) =
let
fun
f0(u, v) =
g_append<xs>(u, v)
in//let
f0(f0(f0(f0(y1,y2),y3),y4),y5)
end (*let*) // end of [gs_append_a5]
#impltmp
< xs:t0 >
gs_append_a6
(y1, y2, y3, y4, y5, y6) =
let
fun
f0(u, v) =
g_append<xs>(u, v)
in//let
f0(f0(f0(f0(f0(y1,y2),y3),y4),y5),y6)
end (*let*) // end of [gs_append_a6]
#impltmp
< xs:t0 >
gs_append_a7
(y1, y2, y3, y4, y5, y6, y7) =
let
fun
f0(u, v) =
g_append<xs>(u, v)
in//let
f0(f0(f0(f0(f0(f0(y1,y2),y3),y4),y5),y6),y7)
end (*let*) // end of [gs_append_a7]
#impltmp
< xs:t0 >
gs_append_a8
(y1, y2, y3, y4, y5, y6, y7, y8) =
let
fun
f0(u, v) =
g_append<xs>(u, v)
in//let
f0(f0(f0(f0(f0(f0(f0(y1,y2),y3),y4),y5),y6),y7),y8)
end (*let*) // end of [gs_append_a8]
#impltmp
< xs:t0 >
gs_append_a9
(y1, y2, y3, y4, y5, y6, y7, y8, y9) =
let
fun
f0(u, v) =
g_append<xs>(u, v)
in//let
f0(f0(f0(f0(f0(f0(f0(f0(y1,y2),y3),y4),y5),y6),y7),y8),y9)
end (*let*) // end of [gs_append_a9]
//
#impltmp
< xs:t0 >
gs_append_a10
(y1, y2, y3, y4, y5, y6, y7, y8, y9, y10) =
let
fun
f0(u, v) =
g_append<xs>(u, v)
in//let
f0(f0(f0(f0(f0(f0(f0(f0(f0(y1,y2),y3),y4),y5),y6),y7),y8),y9),y10)
end (*let*) // end of [gs_append_a10]
//
(* ****** ****** *)
//
#impltmp
< xs:t0 >
gs_append_a11
(y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11) =
let
fun
f0(u, v) =
g_append<xs>(u, v)
in//let
f0(f0(f0(f0(f0(f0(f0(f0(f0(f0(y1,y2),y3),y4),y5),y6),y7),y8),y9),y10),y11)
end (*let*) // end of [gs_append_a11]
//
#impltmp
< xs:t0 >
gs_append_a12
(y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11, y12) =
let
fun
f0(u, v) =
g_append<xs>(u, v)
in//let
f0(f0(f0(f0(f0(f0(f0(f0(f0(f0(f0(y1,y2),y3),y4),y5),y6),y7),y8),y9),y10),y11),y12)
end (*let*) // end of [gs_append_a12]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_gsyn000.dats] *)
(***********************************************************************)
`,
  "DATS/gsyn001.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Wed 31 Jul 2024 04:11:39 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< y0:t0 >
gs_foritm_a1
  ( y0 ) =
(
  g_foritm<y0>(y0))
//
#impltmp
< y0:t0 >
< y1:t0 >
gs_foritm_a2
  (y0, y1) =
(
  g_foritm<y0>(y0); g_foritm<y1>(y1))
//
#impltmp
< y0:t0 >
< y1:t0 >
< y2:t0 >
gs_foritm_a3
  (y0, y1, y2) =
(
  g_foritm<y0>(y0)
; g_foritm<y1>(y1); g_foritm<y2>(y2))
//
#impltmp
< y0:t0 >
< y1:t0 >
< y2:t0 >
< y3:t0 >
gs_foritm_a4
  (y0, y1, y2, y3) =
(
  g_foritm<y0>(y0); g_foritm<y1>(y1)
; g_foritm<y2>(y2); g_foritm<y3>(y3))
//
#impltmp
< y0:t0 >
< y1:t0 >
< y2:t0 >
< y3:t0 >
< y4:t0 >
gs_foritm_a5
  (y0, y1, y2, y3, y4) =
(
  g_foritm<y0>(y0); g_foritm<y1>(y1)
; g_foritm<y2>(y2); g_foritm<y3>(y3); g_foritm<y4>(y4))
//
#impltmp
< y0:t0 >
< y1:t0 >
< y2:t0 >
< y3:t0 >
< y4:t0 >
< y5:t0 >
gs_foritm_a6
  (y0, y1, y2, y3, y4, y5) =
(
  g_foritm<y0>(y0); g_foritm<y1>(y1); g_foritm<y2>(y2)
; g_foritm<y3>(y3); g_foritm<y4>(y4); g_foritm<y5>(y5))
//
#impltmp
< y0:t0 >
< y1:t0 >
< y2:t0 >
< y3:t0 >
< y4:t0 >
< y5:t0 >
< y6:t0 >
gs_foritm_a7
  (y0, y1, y2, y3, y4, y5, y6) =
(
  g_foritm<y0>(y0)
; g_foritm<y1>(y1); g_foritm<y2>(y2); g_foritm<y3>(y3)
; g_foritm<y4>(y4); g_foritm<y5>(y5); g_foritm<y6>(y6))
//
#impltmp
< y0:t0 >
< y1:t0 >
< y2:t0 >
< y3:t0 >
< y4:t0 >
< y5:t0 >
< y6:t0 >
< y7:t0 >
gs_foritm_a8
  (y0, y1, y2, y3, y4, y5, y6, y7) =
(
  g_foritm<y0>(y0); g_foritm<y1>(y1)
; g_foritm<y2>(y2); g_foritm<y3>(y3); g_foritm<y4>(y4)
; g_foritm<y5>(y5); g_foritm<y6>(y6); g_foritm<y7>(y7))
//
#impltmp
< y0:t0 >
< y1:t0 >
< y2:t0 >
< y3:t0 >
< y4:t0 >
< y5:t0 >
< y6:t0 >
< y7:t0 >
< y8:t0 >
gs_foritm_a9
  (y0, y1, y2, y3, y4, y5, y6, y7, y8) =
(
  g_foritm<y0>(y0); g_foritm<y1>(y1); g_foritm<y2>(y2)
; g_foritm<y3>(y3); g_foritm<y4>(y4); g_foritm<y5>(y5)
; g_foritm<y6>(y6); g_foritm<y7>(y7); g_foritm<y8>(y8))
//
#impltmp
< y0:t0 >
< y1:t0 >
< y2:t0 >
< y3:t0 >
< y4:t0 >
< y5:t0 >
< y6:t0 >
< y7:t0 >
< y8:t0 >
< y9:t0 >
gs_foritm_a10
  (y0, y1, y2, y3, y4, y5, y6, y7, y8, y9) =
(
  g_foritm<y0>(y0)
; g_foritm<y1>(y1); g_foritm<y2>(y2); g_foritm<y3>(y3)
; g_foritm<y4>(y4); g_foritm<y5>(y5); g_foritm<y6>(y6)
; g_foritm<y7>(y7); g_foritm<y8>(y8); g_foritm<y9>(y9))
//
#impltmp
< y0:t0 >
< y1:t0 >
< y2:t0 >
< y3:t0 >
< y4:t0 >
< y5:t0 >
< y6:t0 >
< y7:t0 >
< y8:t0 >
< y9:t0 >
< y10:t0 >
gs_foritm_a11
  (y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10) =
(
  g_foritm<y0>(y0); g_foritm<y1>(y1)
; g_foritm<y2>(y2); g_foritm<y3>(y3); g_foritm<y4>(y4)
; g_foritm<y5>(y5); g_foritm<y6>(y6); g_foritm<y7>(y7)
; g_foritm<y8>(y8); g_foritm<y9>(y9); g_foritm<y10>(y10))
//
#impltmp
< y0:t0 >
< y1:t0 >
< y2:t0 >
< y3:t0 >
< y4:t0 >
< y5:t0 >
< y6:t0 >
< y7:t0 >
< y8:t0 >
< y9:t0 >
< y10:t0 >
< y11:t0 >
gs_foritm_a12
  (y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11) =
(
  g_foritm<y0>(y0); g_foritm<y1>(y1); g_foritm<y2>(y2)
; g_foritm<y3>(y3); g_foritm<y4>(y4); g_foritm<y5>(y5)
; g_foritm<y6>(y6); g_foritm<y7>(y7); g_foritm<y8>(y8)
; g_foritm<y9>(y9); g_foritm<y10>(y10); g_foritm<y11>(y11))
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_gsyn001.dats] *)
(***********************************************************************)
`,
  "DATS/gxyz000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sat 27 Jul 2024 01:32:19 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-29:
Sat 03 Aug 2024 05:17:21 PM EDT
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_gxyz000.dats] *)
(***********************************************************************)
`,
  "DATS/list000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon 08 Jul 2024 11:37:45 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX:
This one is also
implemented in [gdbg000.dats]:
*)
#impltmp
{ t0:t0 }
g_ptcon
<list(t0)>
( (*void*) ) =
(
pstrn("list"))
#impltmp
{ t0:t0 }
g_ptype
<list(t0)>
( (*void*) ) =
(
pstrn("list(");
g_ptype<t0>((*0*)); pstrn(")"))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< (*0*) >
list_nil_
((*void*)) = list_nil()
#impltmp
< x0:t0 >
list_cons_
( x1, xs ) = list_cons(x1, xs)
//
(* ****** ****** *)
//
#impltmp
< (*0*) >
list_nilq
{a:t0}(xs) =
(
case+ xs of
| list_nil() => true
| list_cons(_, _) => false)
//
#impltmp
< (*0*) >
list_consq
{a:t0}(xs) =
(
case+ xs of
| list_nil() => false
| list_cons(_, _) => (true))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:t0 >
list_head(xs) =
(case+ xs of
|list_cons(x0, xs) => x0)
#impltmp
< x0:t0 >
list_tail(xs) =
(case+ xs of
|list_cons(x0, xs) => xs)
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
list_head$opt(xs) =
(
case+ xs of
|list_nil
((*nil*)) => optn_vt_nil()
|list_cons
( x0,xs ) => optn_vt_cons(x0))
#impltmp
< x0:t0 >
list_tail$opt(xs) =
(
case+ xs of
|list_nil
((*nil*)) => optn_vt_nil()
|list_cons
( x0,xs ) => optn_vt_cons(xs))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
gseq_nil
<list(x0)><x0>
((*void*)) =
(
  list_nil(*void*))
#impltmp
{ x0:t0 }
gseq_cons
<list(x0)><x0>
( x0, xs ) =
(
  list_cons(x0, xs))
//
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
gseq_nilq
<list(x0)><x0>
 (  xs  ) = list_nilq{x0}(xs)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
$UN.gseq_head$raw
<list(x0)><x0>(xs) =
(case- xs of
|list_cons(x0, xs) => x0)
#impltmp
{ x0:t0 }
$UN.gseq_tail$raw
<list(x0)><x0>(xs) =
(case- xs of
|list_cons(x0, xs) => xs)
//
#impltmp
{ x0:t0 }
$UN.gseq_uncons$raw
<list(x0)><x0>( xs ) =
(case- xs of
|list_cons(x0, xs) => (x0, xs))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-17:
Wed 17 Jul 2024 09:49:09 PM EDT
*)
//
#impltmp
{ x0:t0 }
gseq_sep
<list(x0)><x0>() = ","
#impltmp
{ x0:t0 }
gseq_end
<list(x0)><x0>() = ")"
#impltmp
{ x0:t0 }
gseq_beg
<list(x0)><x0>() = "list("
//
#impltmp
{ x0:t0 }
g_print
<list(x0)>(xs) =
(
gseq_print<list(x0)><x0>(xs))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:t0 >
list_strqize
  (xs) =
(
  auxmain(xs)) where
{
fun auxmain(xs) = $llazy
(
case+ xs of
|
list_nil() =>
strqcon_vt_nil()
|
list_cons(x1, xs) =>
strqcon_vt_cons(x1, auxmain(xs))
)
}(*where*)//end-of-[list_strqize(xs)]
//
#impltmp
{x0:t0}
gseq_strqize
<list(x0)><x0> = list_strqize<x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
#impltmp
< x0:t0 >
list_length =
gseq_length<list(x0)><x0>
*)
//
#impltmp
< x0:t0 >
list_length
  (xs) =
(
loop(xs, 0(*j0*))) where
{
fun
loop{i,j:i0}
(xs:
 list(x0)
,j0: sint(j)): sint(i+j) =
(
case+ xs of
|
list_nil
((*void*)) => ( j0 )
|
list_cons
( x1, xs ) => loop(xs, j0+1)
)
}
//
#impltmp
{ x0:t0 }
gseq_length
<list(x0)><x0> = list_length<x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<a>(*tmp*)
list_copy_vt = list_listize<a>
#impltmp
<a>(*tmp*)
list_rcopy_vt = list_rlistize<a>
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-24:
there is a trec-implementation
for [list_append]!
Wed 31 Jul 2024 08:13:30 PM EDT
*)
#impltmp
{ x0:t0 }
g_add
<list(x0)> =
g_append<list(x0)>(*void*)
#impltmp
{ x0:t0 }
g_append
<list(x0)>(*x0*) =
gseq_append<list(x0)><x0>(*void*)
//
#impltmp
{ x0:t0 }
gseq_append
<list(x0)><x0> = list_append<x0>
//
(* ****** ****** *)
//
#impltmp
<a>(*tmp*)
list_extend
(xs, y0) =
(
list_append<a>(xs, ys)
) where
{
  val ys = list_sing<a>(y0)
}(*where*)//end-of-[list_extend]
//
#impltmp
<a>(*tmp*)
list_append
{m,n}
(xs, ys) = let
fnx
loop
{m:nat} .<m>.
( xs
: list(a, m)
, r0:
& (?list(a)>>list(a,m+n))
) : void =
(
case+ xs of
| list_nil() =>
  (r0 := ys)
| list_cons(x0, xs) =>
  let
    val () =
    r0 := list_cons(x0, _)
  in
    loop(xs, r0.1); $fold(r0)
  end
endcas // end of [ case+(xs) ]
)
in
let
var r0: list(a) in loop(xs, r0); r0
end(*let*)
end(*let*)//end-of(list_append(xs,ys))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-17:
Wed 17 Jul 2024 06:14:38 PM EDT
*)
//
#impltmp
< x0:t0 >
list_reverse
  ( xs ) =
(
list_vt2t(list_reverse_vt<x0>(xs)))
//
#impltmp
{ x0:t0 }
gseq_reverse
<list(x0)><x0> = list_reverse<x0>(*void*)
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
list_reverse_vt
  (xs) =
(
list_rappendx0_vt<x0>(xs, list_vt_nil()))
//
(* ****** ****** *)
//
(*
HX-2024-07-17:
Wed 17 Jul 2024 06:32:33 PM EDT
*)
//
#impltmp
< x0:t0 >
list_rappend_vt
  (xs, ys) =
let
  val ys =
  list_copy_vt<x0>(ys)
in
  list_rappendx0_vt<x0>(xs, ys)
end(*let*)//endof(list_rappend_vt(xs,ys))
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
list_rappendx0_vt
  (xs, ys) =
(
  loop(xs, ys)) where
{
//
fnx
loop
{m,n:nat}.<m>.
( xs
: list(x0, m)
, ys
: list_vt(x0, n)
) : list_vt(x0,m+n) =
(
case+ xs of
| list_nil() => ys
| list_cons(x0, xs) =>
  loop(xs, list_vt_cons(x0, ys)))//fnx
//
}(*where*)//end(list_rappendx0_vt(xs,ys))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:t0 >
list_make_1val
(x1) =
list_cons(x1, list_nil(*0*))
#impltmp
< x0:t0 >
list_make_2val
(x1, x2) =
list_cons(x1,
list_cons(x2, list_nil(*0*)))
#impltmp
< x0:t0 >
list_make_3val
(x1, x2, x3) =
list_cons(x1,
list_cons(x2,
list_cons(x3, list_nil(*0*))))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-01:
Mon 02 Sep 2024 06:16:45 PM EDT
*)
//
#impltmp
< x0:t0 >
list_make_ncpy
  (n0, x0) =
list_fmake_fwork<>
(
lam(work) =>
foritm(n0, //HX:it may not be
  lam(i0) => work(x0)))//efficient!
//
#impltmp
< x0:t0 >
list_make_nfun
  (n0, f0) =
list_fmake_fwork<>
(
lam(work) =>
foritm(n0, //HX:it may not be
  lam(i0) => work(f0(i0))))//efficient!
//
(* ****** ****** *)
(* ****** ****** *)
(*
HX-2024-08-16:
Note that
[list_fmake] and list_fmake_fwork]
are both implemented in [list001.dats]
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
//
HX-2024-08-04:
This is not needed for now as
[GSEQ_make_list] is defined as a [fcast]
Sun 04 Aug 2024 10:05:15 AM EDT
//
#impltmp
{ a: t0 }
GSEQ_make<list(a)><a> = GSEQ_make_list<>{a}
//
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
< x0:t0 >
list_make_gseq
  ( xs ) =
list_vt2t{x0}
(
gseq_listize<xs><x0>(xs))
//
#impltmp
< xs:t0 >
< x0:t0 >
< y0:t0 >
list_map$make_gseq
  ( xs ) =
(
gseq_map_list<xs><x0><y0>(xs))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-05:
Thu 05 Sep 2024 05:21:51 PM EDT
*)
//
#impltmp
< x0:t0 >
list_make_t0up1(xs) =
(
  list_make_1val<x0>(xs.0))
//
#impltmp
< x0:t0 >
list_make_t0up2(xs) =
(
  list_make_2val<x0>(x0, x1))
where
{
  val x0 = xs.0 and x1 = xs.1 }
//
#impltmp
< x0:t0 >
list_make_t0up3(xs) =
let
val @(x0, x1, x2) = xs in
(
  list_make_3val<x0>(x0, x1, x2))
end//let//end-of-[list_make_t0up3]
//
(* ****** ****** *)
//
(*
#impltmp
< x0:t0 >
list_make_t0up4 =
list_make_gseq<t0up(x0,x0,x0,x0)><x0>
*)
#impltmp
< x0:t0 >
list_make_t0up4(xs) =
let
val
@(x0, x1, x2, x3) = xs in
(
list_cons(x0,
  list_make_3val<x0>(x1, x2, x3)))
end//let//end-of-[list_make_t0up4(xs)]
//
(*
#impltmp
< x0:t0 >
list_make_t0up5 =
list_make_gseq<t0up(x0,x0,x0,x0,x0)><x0>
*)
#impltmp
< x0:t0 >
list_make_t0up5(xs) =
let
//
val
@(x0, x1, x2, x3, x4) = xs in
(
list_cons(x0,
list_cons(x1,
  list_make_3val<x0>(x2, x3, x4))))
end//let//end-of-[list_make_t0up5(xs)]
//
(*
#impltmp
< x0:t0 >
list_make_t0up6 =
list_make_gseq<t0up(x0,x0,x0,x0,x0,x0)><x0>
*)
#impltmp
< x0:t0 >
list_make_t0up6(xs) =
let
//
val
@(x0, x1, x2, x3, x4, x5) = xs
//
in//let
(
list_cons(x0,
list_cons(x1,
list_cons(x2,
  list_make_3val<x0>(x3, x4, x5)))))
end//let//end-of-[list_make_t0up6(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-13:
Sat Dec 13 10:31:30 PM EST 2025
*)
#impltmp
< a:t0 >
list_list$concat
  (   xss   ) =
list_vt2t(
list_list$concat_vt<a>(xss))
//
#impltmp
< a:t0 >
list_list$concat_vt
  (   xss   ) =
(
  loop(xss, res)) where
{
//
val res = list_vt_nil(*0*)
//
fun
loop
( xss
: list(list(a))
, res: list_vt(a)): list_vt(a) =
(
case+ xss of
|
list_nil() =>
list_vt_reverse0(res)
|
list_cons(xs1, xss) =>
loop(xss, list_rappendx0_vt(xs1, res)))
//
}(*where*)//end-of-[list_list$concat_vt(xss)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-15:
Mon Dec 15 04:37:34 PM EST 2025
*)
//
#impltmp
< a:t0 >
list_make_lstrm(xs) =
(
list_vt2t(list_vt_make_lstrm<a>(xs)))
//end-of-[impltmp<a:t0>(list_make_lstrm(xs))]
//
#impltmp
< a:t0 >
list_make_lstrq(xs) =
(
list_vt2t(list_vt_make_lstrq<a>(xs)))
//end-of-[impltmp<a:t0>(list_make_lstrq(xs))]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-08:
Thu Jan  8 10:54:42 AM EST 2026
*)
//
#impltmp
list_make'len<>() = 10
//
#impltmp
< a:t0 >
list_make() =
(
nint_map_list<a>(ln)
) where
{
//
val ln = list_make'len<>()
//
#impltmp map$fopr<a>(_) = g_make<a>()
//
}(*where*)//end-of-[g_make<list(a)>()]
//
#impltmp
{ a:t0 }
g_make<list(a)>(*0*) = list_make<a>(*0*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_list000.dats] *)
(***********************************************************************)
`,
  "DATS/list001.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sun 14 Jul 2024 09:17:49 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
g_forall
<list(x0)> =
gseq_forall<list(x0)><x0>
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
list_forall
  ( xs ) = 
(
  loop(xs) ) where
{
fun
loop
(xs: list(x0)): bool =
(
case+ xs of
| ~
list_nil() =>
  ( true )
| ~
list_cons(x1, xs) =>
let
val test =
forall$test<x0>(x1) in
(
if test
then loop(xs) else false) end)
}
//
#impltmp
{ x0:t0 }
gseq_forall
<list(x0)><x0> = list_forall<x0>
#impltmp
{ x0:t0 }
gseq_forall0
<list(x0)><x0>(xs) =
list_forall<x0>(xs) where
{
#impltmp
forall$test<x0> = forall$test0<x0>
}
#impltmp
{ x0:t0 }
gseq_forall1
<list(x0)><x0>(xs) =
list_forall<x0>(xs) where
{
#impltmp
forall$test<x0> = forall$test1<x0>
}
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
list_rforall
  ( xs ) =
(
list_vt_forall0<x0>
(list_reverse_vt<x0>(xs))) where
{
#impltmp
forall$test0<x0> = rforall$test<x0>
}
//
#impltmp
{ x0:t0 }
gseq_rforall
<list(x0)><x0> = list_rforall<x0>
#impltmp
{ x0:t0 }
gseq_rforall0
<list(x0)><x0>(xs) =
list_rforall<x0>(xs) where
{
#impltmp
rforall$test<x0> = rforall$test0<x0>
}
#impltmp
{ x0:t0 }
gseq_rforall1
<list(x0)><x0>(xs) =
list_rforall<x0>(xs) where
{
#impltmp
rforall$test<x0> = rforall$test1<x0>
}
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
list_iforall =
gseq_iforall<list(x0)><x0>(*void*)
//
#impltmp
< x0:t0 >
list_irforall =
gseq_irforall<list(x0)><x0>(*void*)
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
list_forall$f1un =
gseq_forall$f1un<list(x0)><x0>(*void*)
#impltmp
< x0:t0 >
list_iforall$f2un =
gseq_iforall$f2un<list(x0)><x0>(*void*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-10-15:
Wed Oct 15 02:26:54 AM EDT 2025
*)
//
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
g_exists
<list(x0)> =
gseq_exists<list(x0)><x0>
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
list_exists
  ( xs ) = 
(
  loop(xs) ) where
{
fun
loop
(xs: list(x0)): bool =
(
case+ xs of
| ~
list_nil() =>
  (false)
| ~
list_cons(x1, xs) =>
let
val test =
exists$test<x0>(x1) in//let
(if test
 then true else loop(xs)) end)
}
//
#impltmp
{ x0:t0 }
gseq_exists
<list(x0)><x0> = list_exists<x0>
#impltmp
{ x0:t0 }
gseq_exists0
<list(x0)><x0>(xs) =
list_exists<x0>(xs) where
{
#impltmp
exists$test<x0> = exists$test0<x0>
}
#impltmp
{ x0:t0 }
gseq_exists1
<list(x0)><x0>(xs) =
list_exists<x0>(xs) where
{
#impltmp
exists$test<x0> = exists$test1<x0>
}
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
list_rexists
  ( xs ) =
(
list_vt_exists0<x0>
(list_reverse_vt<x0>(xs))) where
{
#impltmp
exists$test0<x0> = rexists$test<x0>
}
//
#impltmp
{ x0:t0 }
gseq_rexists
<list(x0)><x0> = list_rexists<x0>
#impltmp
{ x0:t0 }
gseq_rexists0
<list(x0)><x0>(xs) =
list_rexists<x0>(xs) where
{
#impltmp
rexists$test<x0> = rexists$test0<x0>
}
#impltmp
{ x0:t0 }
gseq_rexists1
<list(x0)><x0>(xs) =
list_rexists<x0>(xs) where
{
#impltmp
rexists$test<x0> = rexists$test1<x0>
}
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
list_iexists =
gseq_iexists<list(x0)><x0>(*void*)
//
#impltmp
< x0:t0 >
list_irexists =
gseq_irexists<list(x0)><x0>(*void*)
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
list_exists$f1un =
gseq_exists$f1un<list(x0)><x0>(*void*)
#impltmp
< x0:t0 >
list_iexists$f2un =
gseq_iexists$f2un<list(x0)><x0>(*void*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
g_foritm
<list(x0)> =
gseq_foritm<list(x0)><x0>
//
#impltmp
< x0:t0 >
list_foritm
  ( xs ) = 
(
  loop(xs) ) where
{
fun
loop
(xs: list(x0)): void =
(
case+ xs of
| ~
list_nil() => ( (*void*) )
| ~
list_cons(x1, xs) =>
let
val () =
foritm$work<x0>(x1) in loop(xs) end)
}
//
#impltmp
{ x0:t0 }
gseq_foritm
<list(x0)><x0> = list_foritm<x0>
#impltmp
{ x0:t0 }
gseq_foritm0
<list(x0)><x0>(xs) =
(
list_foritm<x0>(xs)) where
{
#impltmp
foritm$work<x0> = foritm$work0<x0>
}
#impltmp
{ x0:t0 }
gseq_foritm1
<list(x0)><x0>(xs) =
(
list_foritm<x0>(xs)) where
{
#impltmp
foritm$work<x0> = foritm$work1<x0>
}
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
list_rforitm(xs) =
(
list_vt_foritm0<x0>
(list_reverse_vt<x0>(xs))) where
{
#impltmp
foritm$work0<x0> = rforitm$work<x0>
}
//
#impltmp
{ x0:t0 }
gseq_rforitm
<list(x0)><x0> = list_rforitm<x0>
#impltmp
{ x0:t0 }
gseq_rforitm0
<list(x0)><x0>(xs) =
(
list_rforitm<x0>(xs)) where
{
#impltmp
rforitm$work<x0> = rforitm$work0<x0>
}
#impltmp
{ x0:t0 }
gseq_rforitm1
<list(x0)><x0>(xs) =
(
list_rforitm<x0>(xs)) where
{
#impltmp
rforitm$work<x0> = rforitm$work1<x0>
}
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
list_iforitm =
gseq_iforitm<list(x0)><x0>(* void *)
#impltmp
< x0:t0 >
list_irforitm =
gseq_irforitm<list(x0)><x0>(* void *)
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
list_foritm$f1un =
gseq_foritm$f1un<list(x0)><x0>(* void *)
#impltmp
< x0:t0 >
list_rforitm$f1un =
gseq_rforitm$f1un<list(x0)><x0>(* void *)
//
#impltmp
< x0:t0 >
list_iforitm$f2un =
gseq_iforitm$f2un<list(x0)><x0>(* void *)
#impltmp
< x0:t0 >
list_irforitm$f2un =
gseq_irforitm$f2un<list(x0)><x0>(* void *)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX: 2024-07-28:
Sun 28 Jul 2024 02:37:26 PM EDT
*)
//
#impltmp
<x0>(*tmp*)
list_strmize
  ( xs ) =
(
  auxmain(xs)
) where
{
//
fun
auxmain
(xs: list(x0)) =
$llazy
(
case+ xs of
|
list_nil() =>
strmcon_vt_nil()
|
list_cons(x0, xs) =>
strmcon_vt_cons(x0, auxmain(xs))
)
//
}(*where*)//end-of-[list_strmize(xs)]
//
#impltmp
{ x0:t0 }
gseq_strmize<list(x0)><x0> = list_strmize<x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<x0>(*tmp*)
list_rlistize = list_reverse_vt<x0>
#impltmp
{ x0:t0 }
gseq_rlistize<list(x0)><x0> = list_rlistize<x0>
//
(* ****** ****** *)
//
#impltmp
<x0>(*tmp*)
list_rstrmize
  ( xs ) =
(
list_vt_strmize0<x0>(list_reverse_vt<x0>(xs)))
//
#impltmp
{ x0:t0 }
gseq_rstrmize<list(x0)><x0> = list_rstrmize<x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-31:
Wed 31 Jul 2024 10:34:56 AM EDT
*)
//
#impltmp
< x0:t0 >
list_2choose_lstrm
  ( xs ) =
(
  auxmain(xs)) where
{
fun auxmain(xs) = $llazy
(
//
case+ xs of
|
list_nil() =>
strmcon_vt_nil(*void*)
|
list_cons(x1, xs) => !
(
strm_vt_append00
<y0>(r1, auxmain(xs))
) where
{
//
#typedef xs = list(x0)
#typedef y0 = @(x0, x0)
//
val r1 =
(
gseq_map_lstrm<xs><x0><y0>(xs)
) where
{
#impltmp
map$fopr<x0><y0>(x2) = @(x1, x2) } }//whr
)(*case+*)
}(*where*)//end-of-[list_2choose_lstrm(xs)]
//
#impltmp
< x0:t0 >
list_2choose$forall
  ( xs ) =
(
strm_vt_forall0<x2>
(list_2choose_lstrm<x0>(xs))
) where
{
#typedef x2 = @(x0, x0)
#impltmp
forall$test0<x2>(x2) =
c2hoose$forall$test<x0>(x2.0, x2.1)
}(*where*)//end-of-[list_2choose$forall(xs)]
//
#impltmp
< x0:t0 >
list_2choose$forall$f2un
  (xs, test) =
(
list_2choose$forall<x0>(xs)
) where
{
#impltmp
c2hoose$forall$test<x0>(x1, x2) = test(x1, x2)
}(*where*)//end-of-[list_2choose$forall$f2un(...)]
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
list_3choose_lstrm
  ( xs ) =
(
  auxmain(xs)) where
{
fun auxmain(xs) = $llazy
(
//
case+ xs of
|
list_nil() =>
strmcon_vt_nil(*void*)
//
|
list_cons(x1, xs) => !
(
strm_vt_append00
<y0>(r1, auxmain(xs))
) where
{
//
#typedef xx = @(x0, x0)
#typedef y0 = @(x0, x0, x0)
//
val r1 =
(
strm_vt_map0<xx><y0>
(list_2choose_lstrm<x0>(xs))
) where
{
#impltmp
map$fopr
<xx><y0>(xx) = @(x1, xx.0, xx.1) } }//whr
//
)(*case+*)
}(*where*)//end-of-[list_3choose_lstrm(xs)]
//
#impltmp
< x0:t0 >
list_3choose$forall
  ( xs ) =
(
strm_vt_forall0<x3>
(list_3choose_lstrm<x0>(xs))
) where
{
#typedef x3 = @(x0, x0, x0)
#impltmp
forall$test0<x3>(x3) =
c3hoose$forall$test<x0>(x3.0, x3.1, x3.2)
}(*where*)//end-of-[list_3choose$forall(xs)]
//
#impltmp
< x0:t0 >
list_3choose$forall$f3un
  (xs, test) =
(
list_3choose$forall<x0>(xs)
) where
{
#impltmp
c3hoose$forall$test<x0>(x1, x2, x3) = test(x1, x2, x3)
}(*where*)//end-of-[list_3choose$forall$f3un(...)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:t0 >
list_fmake() =
(
let
val () =
fmake$fwork<x0>((*0*))
in//let
list_vt2t{x0}
(list_vt_reverse0<x0>(r0))
end
) where // end-of-[list_fmake()]
{
//
var r0:
list_vt(x0) =
list_vt_nil()
val p0 = $addr(r0)
//
#impltmp
fmake$fwork$work<x0>(x0) =
$UN.p2tr_set
(p0,list_vt_cons(x0, $UN.p2tr_get(p0)))
//
}(*where*)//end-of-[list_fmake((*0*))]
//
#impltmp
< x0:t0 >
list_fmake_fwork
  (fwork) =
(
  list_fmake<x0>()) where
{
#impltmp
fmake$fwork<x0>
  ((*void*)) =
(
fwork(lam(x0) => fmake$fwork$work<x0>(x0)))
}(*where*)//end-of-[list_fmake_fwork(fwork)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-03:
Tue 03 Sep 2024 01:16:12 PM EDT
*)
//
#impltmp
< x0:t0 >
< y0:t0 >
list_map =
gseq_map_list<list(x0)><x0><y0>(*void*)
#impltmp
< x0:t0 >
< y0:t0 >
list_map$f1un =
gseq_map$f1un_list<list(x0)><x0><y0>(*void*)
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
< y0:vt >
list_map_vt =
gseq_map_llist<list(x0)><x0><y0>(*void*)
#impltmp
< x0:t0 >
< y0:vt >
list_map$f1un_vt =
gseq_map$f1un_llist<list(x0)><x0><y0>(*void*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:t0 >
< y0:t0 >
list_maprev =
gseq_map_rlist<list(x0)><x0><y0>(*void*)
#impltmp
< x0:t0 >
< y0:t0 >
list_maprev$f1un =
gseq_map$f1un_rlist<list(x0)><x0><y0>(*void*)
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
< y0:vt >
list_maprev_vt =
gseq_map_rllist<list(x0)><x0><y0>(*void*)
#impltmp
< x0:t0 >
< y0:vt >
list_maprev$f1un_vt =
gseq_map$f1un_rllist<list(x0)><x0><y0>(*void*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-05-31:
Sat May 31 09:19:05 PM EDT 2025
*)
//
#impltmp
< x0:t0 >
< y0:t0 >
< e1:vt >
list_map$e1nv =
gseq_map$e1nv_list<list(x0)><x0><y0><e1>(*void*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-11-03:
Mon Nov  3 04:07:29 PM EST 2025
*)
//
#impltmp
< x0:t0 >
< r0:vt >
list_folditm
  (xs, r0) = 
(
  loop(xs, r0)) where
{
//
fun
loop
( xs
: list(x0), r0: r0): (r0) =
(
case+ xs of
| ~
list_nil() => ( r0 )
| ~
list_cons(x1, xs) =>
let
val r0 =
folditm$fopr
<x0><r0>(r0, x1) in loop(xs, r0) end)
//
}(*where*)//end-of-[list_folditm<x0><r0>(xs,r0)]
//
#impltmp
{ x0:t0 }
{ r0:vt }
gseq_folditm
<list(x0)><x0><r0> = list_folditm<x0><r0>
#impltmp
{ x0:t0 }
{ r0:vt }
gseq_folditm0
<list(x0)><x0><r0>(xs, r0) =
(
list_folditm<x0><r0>(xs, r0)) where
{
#impltmp
folditm$fopr<x0><r0> = folditm$fopr0<x0><r0>
}(*where*)//end(gseq_folditm0<list(x0)><x0><r0>)
#impltmp
{ x0:t0 }
{ r0:vt }
gseq_folditm1
<list(x0)><x0><r0>(xs, r0) =
(
list_folditm<x0><r0>(xs, r0)) where
{
#impltmp
folditm$fopr<x0><r0> = folditm$fopr1<x0><r0>
}(*where*)//end(gseq_folditm1<list(x0)><x0><r0>)
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
< r0:vt >
list_folditm$f2un =
gseq_folditm$f2un<list(x0)><x0><r0>(*void*)
#impltmp
< x0:t0 >
< r0:vt >
list_ifolditm$f3un =
gseq_ifolditm$f3un<list(x0)><x0><r0>(*void*)
//
#impltmp
< x0:t0 >
< r0:vt >
list_rfolditm$f2un =
gseq_rfolditm$f2un<list(x0)><x0><r0>(*void*)
#impltmp
< x0:t0 >
< r0:vt >
list_irfolditm$f3un =
gseq_irfolditm$f3un<list(x0)><x0><r0>(*void*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-14:
Sun Dec 14 10:39:18 AM EST 2025
*)
//
#impltmp
< x0:t0 >
list_filter
  (  xs  ) =
list_vt2t(list_filter_vt<x0>(xs))
#impltmp
< x0:t0 >
list_filter$f1un
  (xs, test) =
list_vt2t(list_filter$f1un_vt<x0>(xs, test))
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
list_filter_vt
  (  xs  ) =
(
  loop(xs, rs)) where
{
//
val rs = list_vt_nil(*0*)
//
fun
loop
( xs: list(x0)
, rs: list_vt(x0)): list_vt(x0) =
(
case+ xs of
//
|list_nil
( (*00*) ) =>
list_vt_reverse0<x0>(rs)
//
|list_cons
( x1, xs ) =>
if
filter$test<x0>(x1)
then loop(xs, list_vt_cons(x1, rs))
else loop(xs, rs))//end(else)//end(if)
//
}(*where*)//end-of-[list_filter_vt(xs)]
//
#impltmp
< x0:t0 >
list_filter$f1un_vt
  (xs, test) =
(
  list_filter_vt<x0>(xs))
where
{
#impltmp filter$test<x0> = test(*void*)
}(*where*)//end-of-[list_filter$f1un_vt(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-14:
This code is VERY inefficient!
Sun Dec 14 05:49:39 PM EST 2025
*)
#impltmp
< x0:t0 >
list_1choose$split_lstrm
  (  xs  ) =
$llazy(
//
case+ xs of
|
list_nil
((*void*)) =>
(
strmcon_vt_nil(*void*))
|
list_cons
( x1, xs ) =>
let
//
#vwtpdef
xxs = (x0, list_vt(x0))
//
in//let
//
strmcon_vt_cons
(
(x1, list_copy_vt(xs)),
strm_vt_map0$f1un<xxs><xxs>
(
list_1choose$split_lstrm(xs),
lam(xxs) => (xxs.0, list_vt_cons(x1, xxs.1))))
//
end(*let*)//end-of-[list_cons(x1,xs)]
//
)(*case+*)//end-of-[list_1choose$split_lstrm<x0>]
//
(* ****** ****** *)
//
(*
HX-2025-12-14:
Compared to the above one,
this one is more efficient!
Sun Dec 14 08:17:41 PM EST 2025
*)
#impltmp
< x0:t0 >
list_1choose$split_lstrm
  (  xs  ) =
(
case+ xs of
|list_nil() =>
(
  strm_vt_nil())
|list_cons(x1, xs) =>
(
  auxmain(x1, xs, ys))
) where
{
//
val ys = list_vt_nil(*void*)
//
fun
auxmain
(x1: x0
,xs: list(x0)
,ys: list_vt(x0))
: strm_vt@(x0, list_vt(x0)) =
$llazy(
//
case+ xs of
|
list_nil() =>
strmcon_vt_cons
((x1, rs), strm_vt_nil())
where{
  val rs = list_vt_reverse0(ys) }
|
list_cons _ =>
strmcon_vt_cons((x1, rs),
  auxmain(xs.0, xs.1, list_vt_cons(x1, ys)))
where{
  val rs = 
  list_vt_rappend10(ys, list_reverse_vt(xs)) }
)(*case+*)//end-of-[auxmain(x1, xs, ys)]
//
}(*where*)//end-of-[list_1choose$split_lstrm<x0>]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-04:
Sun Jan  4 11:24:40 PM EST 2026
*)
#impltmp
< x0:t0 >
list_memberq = gseq_memberq<list(x0)><x0>(*xs,x0*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_list001.dats] *)
(***********************************************************************)
`,
  "DATS/list002.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sat 10 Aug 2024 07:33:24 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#typedef ni = nint
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-10:
This should probably be
replace later with a more
efficient version
Sat 10 Aug 2024 07:34:46 PM EDT
*)
#impltmp
{ x0:t0 }
g_cmp<list(x0)> =
gseq_cmp<list(x0)><x0>(*void*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:t0 >
< y0:t0 >
list_z2forall
  ( xs, ys ) =
(
  auxloop(xs, ys)) where
{
fun
auxloop
( xs
: list(x0)
, ys
: list(y0)): bool =
(
case+ xs of
|list_nil() =>
(   true   )
|list_cons(x1, xs) =>
(
case+ ys of
|list_nil() =>
(   true   )
|list_cons(y1, ys) =>
(
if
z2forall$test
<x0><y0>(x1, y1)
then auxloop(xs, ys) else false)))
}(*where*)//end-of-[list_z2forall(xs,ys)]
//
#impltmp
{ x0:t0
, y0:t0 }
gseq_z2forall
<list(x0)><x0>
<list(y0)><y0> = list_z2forall<x0><y0>
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:t0 >
< y0:t0 >
list_z2iforall
  ( xs, ys ) =
(
auxloop
(0(*i0*), xs, ys)) where
{
fun
auxloop
( i0: ni
, xs
: list(x0)
, ys
: list(y0)): bool =
(
case+ xs of
|list_nil() =>
(   true   )
|list_cons(x1, xs) =>
(
case+ ys of
|list_nil() =>
(   true   )
|list_cons(y1, ys) =>
(
if
z2iforall$test
<x0><y0>(i0, x1, y1)
then auxloop(i0+1,xs,ys) else false)))
}(*where*)//end-of-[list_z2iforall(xs,ys)]
//
#impltmp
{ x0:t0
, y0:t0 }
gseq_z2iforall
<list(x0)><x0>
<list(y0)><y0> = list_z2iforall<x0><y0>
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_list002.dats] *)
(***********************************************************************)
`,
  "DATS/lsrt000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Thu Dec 25 10:43:54 AM EST 2025
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ t0:t0 }
g_ptcon
<lsrt(t0)>
( (*void*) ) =
(
pstrn("lsrt"))
#impltmp
{ t0:t0 }
g_ptype
<lsrt(t0)>
( (*void*) ) =
(
pstrn("lsrt(");
g_ptype<t0>((*0*)); pstrn(")"))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
lsrt_nil
{a:t0}((*0*)) =
(
UN_lsrt_encd
(list_nil<a>(*0*)))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
lsrt_nilq
  (  xs  ) =
(
  list_nilq(lsrt_decd(xs)))
#impltmp
<(*tmp*)>
lsrt_consq
  (  xs  ) =
(
  list_consq(lsrt_decd(xs)))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: t0 >
lsrt_make_1val
  (  x0  ) =
(
UN_lsrt_encd(
list_make_1val<a>(x0)))
//
#impltmp
< a: t0 >
lsrt_make_2val
  ( x1, x2 ) =
(
if
g_lte<a>(x1, x2)
then
UN_lsrt_encd(
list_make_2val<a>(x1, x2))
else
UN_lsrt_encd(
list_make_2val<a>(x2, x1)))
//
#impltmp
< a: t0 >
lsrt_make_3val
( x1, x2, x3 ) =
(
if // if1
g_lte<a>(x1, x2)
then // 1
(
if // if2
g_lte<a>(x2, x3)
then // 2
UN_lsrt_encd(
list_make_3val<a>(x1, x2, x3))
else // 2
(
if // if3
g_lte<a>(x1, x3)
then // 3
UN_lsrt_encd(
list_make_3val<a>(x1, x3, x2))
else // 3
UN_lsrt_encd(
list_make_3val<a>(x3, x1, x2))))
else // 1
(
if // if2
g_lte<a>(x1, x3)
then // 2
UN_lsrt_encd(
list_make_3val<a>(x2, x1, x3))
else // 2
(
if // if3
g_lte<a>(x2, x3)
then // 3
UN_lsrt_encd(
list_make_3val<a>(x2, x3, x1))
else // 3
UN_lsrt_encd(
list_make_3val<a>(x3, x2, x1)))))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: t0 >
lsrt_head
  (  xs  ) =
(
  list_head<a>(lsrt_decd(xs)))
#impltmp
< a: t0 >
lsrt_tail
  (  xs  ) =
(
UN_lsrt_encd(
  list_tail<a>(lsrt_decd(xs))))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: t0 >
lsrt_length
  (  xs  ) =
(
  list_length<a>(lsrt_decd(xs)))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
gseq_forall
<lsrt(x0)><x0>
  (  xs  ) =
(
  list_forall<x0>(lsrt_decd(xs)))
#impltmp
{ x0:t0 }
gseq_iforall
<lsrt(x0)><x0>
  (  xs  ) =
(
  list_iforall<x0>(lsrt_decd(xs)))
//
#impltmp
{ x0:t0 }
gseq_strmize
<lsrt(x0)><x0>
  (  xs  ) =
(
  list_strmize<x0>(lsrt_decd(xs)))
#impltmp
{ x0:t0 }
gseq_listize
<lsrt(x0)><x0>
  (  xs  ) =
(
  list_listize<x0>(lsrt_decd(xs)))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
gseq_sep
<lsrt(x0)><x0>() = ","
#impltmp
{ x0:t0 }
gseq_end
<lsrt(x0)><x0>() = ")"
#impltmp
{ x0:t0 }
gseq_beg
<lsrt(x0)><x0>() = "lsrt("
//
#impltmp
{ x0:t0 }
g_print
<lsrt(x0)>(xs) =
(
gseq_print<lsrt(x0)><x0>(xs))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:t0 >
lsrt_exists
  ( xs ) =
(
loop(lsrt_decd(xs))
) where
{
//
fun
loop
( xs
: list(x0)): bool =
(
case+ xs of
|
list_nil
( (*0*) ) => false
|
list_cons
( x1, xs ) =>
let
val sgn =
(
  exists$tcmp<x0>(x1))
in//let
//
if (sgn = 0)
then true else
(
if (sgn < 0)
  then false else loop(xs))//if
//
end//let//end-of-[list_cons(x1,xs)]
)(*case+*)//end-of-[loop(xs:list(x0))]
//
}(*where*)//end-of-[lsrt_exists<x0>(xs)]
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
lsrt_search
  ( xs ) =
(
loop(lsrt_decd(xs))
) where
{
//
fun
loop
( xs
: list(x0)): optn_vt(x0) =
(
case+ xs of
|
list_nil() =>
(
  optn_vt_nil())
|
list_cons(x1, xs) =>
let
//
val sgn =
(
  search$tcmp<x0>(x1))
//
in//let
//
if (sgn = 0)
then
optn_vt_cons(x1) else
(
if (sgn < 0)
then optn_vt_nil() else loop(xs))
//
end//let//end-of-[list_cons(x1,xs)]
)(*case+*)//end-of-[loop(xs:list(x0))]
//
}(*where*)//end-of-[lsrt_search<x0>(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-15:
Thu Dec 25 01:32:21 PM EST 2025
*)
//
#impltmp
< x0:t0 >
lsrt_insert
( xs , x0 ) =
let
//
val xs =
(
  lsrt_decd(xs))
//
in//let
//
UN_lsrt_encd
(
loop
(xs, list_vt_nil(*0*)))
//
end where // end-of-(let)
{
//
#typedef xs = list(x0)
#vwtpdef rs = list_vt(x0)
//
fun
rappend0x
( rs: rs
, xs: xs): list(x0) =
(
list_vt_folditm0
<x0><xs>(rs, xs)) where
{
//
#impltmp
folditm$fopr0
<x0><xs>(xs, x0) =
(
  list_cons<x0>(x0, xs)) }
//
fnx
loop
( xs: xs
, rs: rs): list(x0) =
(
case+ xs of
|
list_nil
( (*0*) ) =>
(
rappend0x(rs, list_sing(x0)))
|
list_cons
( x1, ys ) =>
if
(
g_lte<x0>(x0, x1))
then
(
rappend0x
(rs, list_cons(x0, xs)))
else
(
loop(ys, list_vt_cons(x1, rs))))//if
//
}(*where*)//end-of-[lsrt_insert(xs,x0))]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-26:
Fri Dec 26 10:53:19 PM EST 2025
*)
//
#impltmp
< x0:t0 >
lsrt_msetize
  (  xs  ) =
(
list_vt2t(
  lsrt_msetize_vt<x0>(xs)))
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
lsrt_msetize_vt
  (   xs   ) =
(
case+ xs of
|
list_nil() =>
(
  list_vt_nil())
|
list_cons(x0, xs) =>
let
val n0 = 1
val rs =
list_vt_nil(*0*)
in//let
(
list_vt_reverse0
(
  loop(xs, x0, n0, rs))) end
) where
{
//
val xs =
lsrt_decd(xs)//val(xs)
//
fun
loop
( xs
: list(x0)
, x0, n0, rs)
: list_vt@(x0, igtz) =
(
case+ xs of
|
list_nil
( (*0*) ) =>
(
list_vt_cons((x0, n0), rs))
|
list_cons
( x1, xs ) =>
(
if
g_eq<x0>(x0, x1)
then
let
val n0 = n0+1
in
  loop(xs, x0, n0, rs) end//then
else
let
val n1 = 1
val rs =
list_vt_cons
((x0, n0), rs)
in
  loop(xs, x1, n1, rs) end//else
)
//
)(*case+*)//end-of-[loop(xs,x0,n0,rs)]
//
}(*where*)//end-of-[lsrt_msetize_vt<x0>(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-25:
The keys in a lsrt-map
are assumed to be distinct!!!
Thu Dec 25 06:35:24 PM EST 2025
*)
//
#impltmp
< k0:t0 >
< x0:t0 >
lsrt$map_search$tst
  (  kxs, key  ) =
(
lsrt_exists<kx0>(kxs))
where
{
//
#typedef kx0 = @(k0, x0)
//
#impltmp
exists$tcmp<kx0>(kx0) = g_cmp<k0>(key, kx0.0)
//
}(*where*)//end-of-[lsrt$map_search$tst<k0><x0>()]
//
#impltmp
< k0:t0 >
< x0:t0 >
lsrt$map_search$opt
  (  kxs, key  ) =
let
//
val opt = lsrt_search(kxs)
//
in//let
//
case+ opt of
| ~
optn_vt_nil
(  (*0*)  ) => optn_vt_nil()
| ~
optn_vt_cons
(   kx1   ) => optn_vt_cons(kx1.1)
//
end where
{
//
#impltmp
search$tcmp
< (k0,x0) >(kx0) = g_cmp<k0>(key, kx0.0)
//
}(*where*)//end-of-[lsrt$map_search$opt<k0><x0>()]
//
#impltmp
{ k0:t0
, x0:t0 }
gmap_search$opt
< lsrt@(k0,x0) ><k0><x0> = lsrt$map_search$opt<k0><x0>
//
(* ****** ****** *)
//
(*
HX-2025-12-25:
This gives another
implementation via [gseq_filter_lstrm]
*)
(*
#impltmp
< k0:t0 >
< x0:t0 >
lsrt$map_search$opt
  (  kxs, key  ) =
let
//
val kxs =
(
gseq_filter_lstrm
< kxs >< kx0 >( kxs ))
where{
//
#typedef kx0 = (k0, x0)
#typedef kxs = lsrt(kx0)
//
#impltmp
filter$test
< kx0 >( kx0 ) =
(
  g_lte<k0>( key, kx0.0 )) }
//
in//let
//
case+ !kxs of
| ~
strmcon_vt_nil
(  (*void*)  ) => optn_vt_nil(*0*)
| ~
strmcon_vt_cons
(   kx1, kxs   ) =>
let
val () = g_free(kxs)
in//let
(
if // if
(
g_eq<k0>
(key, kx1.0))
then
optn_vt_cons(kx1.1) else optn_vt_nil(*0*))
end//let//end-of-[strmcon_vt_cons(kx1,kxs)]
//
end(*let*)//end-of-[lsrt$map_search$opt<k0><x0>()]
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-26:
Fri Dec 26 12:00:19 AM EST 2025
*)
//
#impltmp
< k0:t0 >
< x0:t0 >
lsrt$map_getout$opt
  (  kxs, key  ) =
let
val
(map, opt) =
(
loop(kxs, krs))
in//let
(
  map, opt) where
{
val map =
(
  UN_lsrt_encd(map)) }
end where//end-of(let)
{
//
#typedef kx0 = (k0, x0)
#typedef kxs = list(kx0)
#typedef map = list(kx0)
#vwtpdef opt = optn_vt(x0)
#vwtpdef krs = list_vt(kx0)
//
fun
rappend0x
( krs: krs
, kxs: kxs): map =
(
list_vt_folditm0
<kx0><map>(krs, kxs)
) where{
//
#impltmp
folditm$fopr0
<kx0><map>(kxs, kx0) =
(
  list_cons<kx0>(kx0, kxs))}
//
val kxs: kxs = lsrt_decd(kxs)
val krs: krs = list_vt_nil(*0*)
//
fun
loop
( kxs: kxs
, krs: krs)
: (map, opt) =
(
case+ kxs of
//
|list_nil
( (*void*) ) =>
//
let
val map =
rappend0x(krs, kxs)
in//let
(map, optn_vt_nil())
end//let
//
|list_cons
( kx1, kys ) =>
let
//
val sgn =
g_cmp<k0>(key, kx1.0)
//
in//let
//
if // if
(sgn < 0)
then
(
let
//
val map =
(
  rappend0x(krs, kxs))
//
in//let
  (map, optn_vt_nil()) end)
else
(
if
(sgn > 0)
then
loop
(kys, list_vt_cons(kx1, krs))
else
(
let
//
val map =
(
  rappend0x(krs, kys))
//
in//let
(
  map, optn_vt_cons(kx1.1)) end))
//
end//let
//
)(*case+*)//end-of-[loop(kxs,krs)]
//
}(*where*)//end-of-[lsrt$map_getout$opt<k0><x0>()]
//
#impltmp
{ k0:t0
, x0:t0 }
gmap_getout$opt
< lsrt@(k0,x0) ><k0><x0> = lsrt$map_getout$opt<k0><x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-26:
Fri Dec 26 12:00:19 AM EST 2025
*)
//
#impltmp
< k0:t0 >
< x0:t0 >
lsrt$map_insert$opt
  (kxs, key, itm) =
let
val
(map, opt) =
(
loop(kxs, krs))
in//let
(
  map, opt) where
{
val map =
(
  UN_lsrt_encd(map)) }
end where//end-of(let)
{
//
#typedef kx0 = (k0, x0)
#typedef kxs = list(kx0)
#typedef map = list(kx0)
#vwtpdef opt = optn_vt(x0)
#vwtpdef krs = list_vt(kx0)
//
fun
rappend0x
( krs: krs
, kxs: kxs): map =
(
list_vt_folditm0
<kx0><map>(krs, kxs)
) where{
//
#impltmp
folditm$fopr0
<kx0><map>(kxs, kx0) =
(
  list_cons<kx0>(kx0, kxs))}
//
val kxs: kxs = lsrt_decd(kxs)
val krs: krs = list_vt_nil(*0*)
//
fun
loop
( kxs: kxs
, krs: krs)
: (map, opt) =
(
case+ kxs of
//
|list_nil
( (*void*) ) =>
//
let
//
val kx0 =
(key, itm)
val kxs =
list_sing(kx0)
val map =
rappend0x(krs, kxs)
//
in//let
(map, optn_vt_nil())
end//let
//
|list_cons
( kx1, kys ) =>
let
//
val sgn =
g_cmp<k0>(key, kx1.0)
//
in//let
//
if // if
(sgn < 0)
then
(
let
//
val kx0 =
(key, itm)
val kxs =
list_cons(kx0, kxs)
//
val map =
(
  rappend0x(krs, kxs))
in//let
  (map, optn_vt_nil()) end)
else
(
if
(sgn > 0)
then
loop
(kys, list_vt_cons(kx1, krs))
else
(
let
//
val kx0 =
(key, itm)
val kxs =
list_cons(kx0, kys)
//
val map =
(
  rappend0x(krs, kxs))
//
in//let
(
  map, optn_vt_cons(kx1.1)) end))
//
end//let
//
)(*case+*)//end-of-[loop(kxs,krs)]
//
}(*where*)//end-of-[lsrt$map_insert$opt<k0><x0>()]
//
#impltmp
{ k0:t0
, x0:t0 }
gmap_insert$opt
< lsrt@(k0,x0) ><k0><x0> = lsrt$map_insert$opt<k0><x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_lsrt000.dats] *)
(***********************************************************************)
`,
  "DATS/optn000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sat 07 Sep 2024 12:09:18 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX:
This one is also
implemented in [gdbg000.dats]:
*)
#impltmp
{ t0:t0 }
g_ptcon
<optn(t0)>
( (*void*) ) =
(
pstrn("optn"))
#impltmp
{ t0:t0 }
g_ptype
<optn(t0)>
( (*void*) ) =
(
pstrn("optn(");
g_ptype<t0>((*0*)); pstrn(")"))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
gseq_nil
<optn(x0)><x0>
  ((*void*)) =
(
  optn_nil((*0*)))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
optn_nil_
 ((*0*)) = optn_nil()
#impltmp
< a: t0 >
optn_cons_
 (  x0  ) = optn_cons(x0)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< (*0*) >
optn_nilq
{a:t0}(xs) =
(
case+ xs of
|
optn_nil() => true
|
optn_cons(_) => false)
#impltmp
{ x0:t0 }
gseq_nilq
<optn(x0)><x0> =
optn_nilq<>{x0}(* void *)
//
(* ****** ****** *)
//
#impltmp
< (*0*) >
optn_consq
{a:t0}(xs) =
(
case+ xs of
|
optn_nil() => false
|
optn_cons(_) => (true))
#impltmp
{ x0:t0 }
gseq_consq
<optn(x0)><x0> =
optn_consq<>{x0}(* void *)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: t0 >
optn_head
  ( xs ) =
(
case+ xs of
| optn_cons(x0) => (x0))
//
#impltmp
{ x0:t0 }
gseq_head
<optn(x0)><x0> = optn_head<x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
$UN.gseq_head$raw
<optn(x0)><x0>(xs) =
(
case- xs of
| optn_cons(x0) => x0)
//
#impltmp
{ x0:t0 }
$UN.gseq_tail$raw
<optn(x0)><x0>(xs) =
(
case- xs of
|
optn_cons(x0) => optn_nil(*0*))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
gseq_sep
<optn(x0)><x0>() = ","
#impltmp
{ x0:t0 }
gseq_end
<optn(x0)><x0>() = ")"
#impltmp
{ x0:t0 }
gseq_beg
<optn(x0)><x0>() = "optn("
//
#impltmp
{ x0:t0 }
g_print
<optn(x0)>(xs) =
(
gseq_print<optn(x0)><x0>(xs))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: t0 >
optn_make_1val = optn_cons_<a>
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:t0 >
optn_length
  (xs) =
(
case+ xs of
| optn_nil( ) => 0
| optn_cons(_) => 1)//impltmp
//
#impltmp
{ x0:t0 }
gseq_length
<optn(x0)><x0> = optn_length<x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_optn000.dats] *)
(***********************************************************************)
`,
  "DATS/optn001.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sat 07 Sep 2024 08:21:15 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:t0 >
optn_forall
  ( xs ) = 
(
case+ xs of
|optn_nil() => true
|optn_cons(x0) => forall$test<x0>(x0)
)
//
#impltmp
{ x0:t0 }
gseq_forall
<optn(x0)><x0> = optn_forall<x0>(*void*)
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
optn_rforall
  ( xs ) = 
(
case+ xs of
|optn_nil() => true
|optn_cons(x0) => rforall$test<x0>(x0)
)
//
#impltmp
{ x0:t0 }
gseq_rforall
<optn(x0)><x0> = optn_rforall<x0>(*void*)
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
optn_iforall
  ( xs ) = 
(
case+ xs of
|
optn_nil() => true
|
optn_cons(x0) => iforall$test<x0>(0, x0)
)
//
#impltmp
{ x0:t0 }
gseq_iforall
<optn(x0)><x0> = optn_iforall<x0>(*void*)
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
optn_irforall
  ( xs ) = 
(
case+ xs of
|
optn_nil() => true
|
optn_cons(x0) => irforall$test<x0>(0, x0)
)
//
#impltmp
{ x0:t0 }
gseq_irforall
<optn(x0)><x0> = optn_irforall<x0>(*void*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:t0 >
optn_foritm
  ( xs ) = 
(
case+ xs of
|optn_nil() => ((*void*))
|optn_cons(x0) => foritm$work<x0>(x0)
)
//
#impltmp
{ x0:t0 }
gseq_foritm
<optn(x0)><x0> = optn_foritm<x0>(*void*)
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
optn_rforitm
  ( xs ) = 
(
case+ xs of
|optn_nil() => ((*void*))
|optn_cons(x0) => rforitm$work<x0>(x0)
)
//
#impltmp
{ x0:t0 }
gseq_rforitm
<optn(x0)><x0> = optn_rforitm<x0>(*void*)
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
optn_iforitm
  ( xs ) = 
(
case+ xs of
|
optn_nil() => ((*void*))
|
optn_cons(x0) => iforitm$work<x0>(0, x0)
)
//
#impltmp
{ x0:t0 }
gseq_iforitm
<optn(x0)><x0> = optn_iforitm<x0>(*void*)
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
optn_irforitm
  ( xs ) = 
(
case+ xs of
|
optn_nil() => ((*void*))
|
optn_cons(x0) => irforitm$work<x0>(0, x0)
)
//
#impltmp
{ x0:t0 }
gseq_irforitm
<optn(x0)><x0> = optn_irforitm<x0>(*void*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-05-29:
Thu May 29 08:48:06 AM EDT 2025
*)
//
#impltmp
< x0:t0 >
< y0:t0 >
optn_map
(  xs  ) =
(
case+ xs of
| optn_nil() => optn_nil()
| optn_cons(x0) =>
  optn_cons(map$fopr<x0><y0>(x0)))
//
#impltmp
< x0:t0 >
< y0:t0 >
optn_map$f1un
( xs, fopr ) =
(
case+ xs of
| optn_nil() => optn_nil()
| optn_cons(x0) => optn_cons(fopr(x0)))
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_optn001.dats] *)
(***********************************************************************)
`,
  "DATS/strm000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sat 07 Sep 2024 07:22:52 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX:
This one is also
implemented in [gdbg000.dats]:
*)
//
#impltmp
{ t0:t0 }
g_ptcon
<strm(t0)>
( (*void*) ) =
(
pstrn("strm"))
#impltmp
{ t0:t0 }
g_ptype
<strm(t0)>
( (*void*) ) =
(
pstrn("strm(");
g_ptype<t0>((*0*)); pstrn(")"))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-20:
Sat Dec 20 11:36:58 AM EST 2025
*)
#impltmp
<(*tmp*)>
strm_nil((*0*)) =
$lazy(strmcon_nil(*void*))
//
#impltmp
< a: t0 >
strm_sing(x0) =
(
strm_cons(x0, strm_nil()))
//
#impltmp
< a: t0 >
strm_cons(x0, xs) =
$lazy(strmcon_cons(x0, xs))
//
(* ****** ****** *)
//
#impltmp
< a: t0 >
strm_eval(xs) = $eval( xs )
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-20:
Sat Dec 20 11:43:16 AM EST 2025
*)
//
#impltmp
{ x0:t0 }
gseq_sep
<strm(x0)><x0>() = ","
#impltmp
{ x0:t0 }
gseq_end
<strm(x0)><x0>() = ")"
#impltmp
{ x0:t0 }
gseq_beg
<strm(x0)><x0>() = "strm("
//
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
g_print<strm(x0)> =
gseq_print<strm(x0)><x0>(*xs*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-20:
Sat Dec 20 12:27:24 PM EST 2025
*)
//
#impltmp
< x0:t0 >
strm_head
  ( xs ) =
( case- !xs of
| strmcon_cons(x1, xs) => (x1))
//
#impltmp
< x0:t0 >
strm_tail
  ( xs ) =
( case- !xs of
| strmcon_cons(x1, xs) => (xs))
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
strm_head$opt
  ( xs ) =
(
case+ !xs of
|strmcon_nil
( (*void*) ) =>
(
  optn_vt_nil(*0*))
|strmcon_cons
(  x1, xs  ) => optn_vt_cons(x1))
//
#impltmp
< x0:t0 >
strm_tail$opt
  ( xs ) =
(
case+ !xs of
|strmcon_nil
( (*void*) ) =>
(
  optn_vt_nil(*0*))
|strmcon_cons
(  x1, xs  ) => optn_vt_cons(xs))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-20:
Sat Dec 20 01:16:29 PM EST 2025
*)
//
#impltmp
< x0:t0 >
strm_length
  (  xs  ) =
(
  loop(xs, 0)) where
{
//
fun
loop
( xs
: strm(x0), ln: nint): nint =
(
case+ !xs of
|strmcon_nil
(  (*void*)  ) => ( ln )
|strmcon_cons
(   x1 , xs   ) => loop(xs, ln+1))
//
}(*where*)//end-of-[strm_length( xs )]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:t0 >
strm_append
  (xs, ys) =
(
  auxmain(xs, ys)) where
{
fun
auxmain
( xs: strm(x0)
, ys: strm(x0)): strm(x0) = $lazy
(
case+ !xs of
|
strmcon_nil() => 
(
  strm_eval<x0>(xs))
|
strmcon_cons(x1, xs) =>
(
  strmcon_cons(x1, auxmain(xs, ys))))
}(*where*)//end-of-[strm_append(xs,ys)]
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
strm_append_vt
  (xs, ys) =
(
  auxmain(xs, ys)) where
{
fun
auxmain
( xs: strm(x0)
, ys: strm(x0)): strm_vt(x0) = $llazy
(
case+ !xs of
|
strmcon_nil() =>
(
! strm_strmize(ys))
|
strmcon_cons(x1, xs) =>
(
  strmcon_vt_cons(x1, auxmain(xs, ys))))
}(*where*)//end-of-[strm_append_vt(xs,ys)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-21:
Sun Dec 21 07:20:03 PM EST 2025
*)
//
(* ****** ****** *)
//
#impltmp
<>(*tmp*)
strm_end() = ")"
#impltmp
<>(*tmp*)
strm_sep() = ","
#impltmp
<>(*tmp*)
strm_rst() = "..."
//
#impltmp
<>(*tmp*)
strm_beg() = "$strm("
//
(* ****** ****** *)
//
#impltmp
<>(*tmp*)
strm_print$len() = (10)
#impltmp
<>(*tmp*)
strm_print'len() = (10)
//
(* ****** ****** *)
//
#impltmp
<x0>(*tmp*)
strm_print(xs) =
let
val len = 
strm_print$len<>()
in//let
if
(len < 0)
then strm_all$print<x0>(xs)
else strm_len$print<x0>(xs, len)
end(*let*)//end-of-[strm_print(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<x0>(*tmp*)
strm_all$print
  (xs) =
(
loop
(xs, 0(*i0*)) where
{
val () =
pstrn(strm_beg<>())
}
) where
{
#typedef
xs = strm(x0)
fnx
loop
( xs: xs
, i0: nint): void =
(
case+ !xs of
|
strmcon_nil() =>
(
pstrn(strm_end<>()))
|
strmcon_cons(x0, xs) =>
let
//
val () =
if
(i0 > 0)
then
pstrn(strm_sep<>())
//
in
(
  loop(xs, i0+1)) where
{
  val () = g_print<x0>(x0)
}
end // end of [strmcon_cons]
)
}(*where*)//end-of-(strm_all$print(xs))
//
(* ****** ****** *)
//
#impltmp
<x0>(*tmp*)
strm_len$print
  (xs, n0) =
(
loop
(xs, 0(*i0*)) where
{
val () =
pstrn(strm_beg<>())
}
) where
{
//
#typedef
xs = strm(x0)
//
fnx
loop
( xs: xs
, i0: nint): void =
(
case+ !xs of
|
strmcon_nil() =>
(
pstrn(strm_vt_end<>()))
|
strmcon_cons(x0, xs) =>
if
(i0 >= n0)
then
let
//
val () =
if
(i0 > 0)
then
(
  pstrn(strm_sep<>()))
//
val () =
(
  pstrn(strm_rst<>()))
//
in
(
  pstrn(strm_end<>()))
end // end of [if-then]
else
let
//
val () =
if
(i0 > 0)
then
(
  pstrn(strm_sep<>()))
//
in//let
(
  loop(xs, i0+1)) where
{
  val () = g_print<x0>(x0)
}
end // end of [if-else]
)(*case+*)//end-of-(loop(xs,i0))
}(*where*)//end-of-(strm_len$print(xs,ln))
//
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
g_print<strm(x0)> = strm_print<x0>(*xs*)
#impltmp
{ x0:t0 }
gseq_print<strm(x0)><x0> = strm_print<x0>(*xs*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_strm000.dats] *)
(***********************************************************************)
`,
  "DATS/strm001.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sun Dec 21 01:27:59 AM EST 2025
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:t0 >
strm_foritm =
gseq_foritm<strm(x0)><x0>
#impltmp
< x0:t0 >
strm_foritm$f1un =
gseq_foritm$f1un<strm(x0)><x0>
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:t0 >
strm_forall
  ( xs ) =
(
  auxmain(xs)) where
{
fun
auxmain
(xs: strm(x0)): bool =
(
case+ !xs of
|strmcon_nil
( (*void*) ) => (true)
|strmcon_cons
(  x1, xs  ) =>
(
if
forall$test
< x0 >( x1 )
then auxmain(xs) else false)
)(*case+*)//end-of-[auxmain(xs)]
}(*where*)//end-of-[strm_forall(xs)]
//
#impltmp
{ x0:t0 }
gseq_forall
<strm(x0)><x0> = strm_forall<x0>(*0*)
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
strm_forall$f1un
  (xs, test) =
(
strm_forall
<  x0  >(  xs  )) where
{
#impltmp
forall$test<x0> = test(*x0*)
}(*where*)//end-of-[strm_forall$f1un]
//
#impltmp
{ x0:t0 }
gseq_forall$f1un
<strm(x0)><x0> = strm_forall$f1un<x0>(*0*)
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
strm_iforall
  ( xs ) =
(
auxmain(0, xs)) where
{
fun
auxmain
( i0: sint
, xs: strm(x0)): bool =
(
case+ !xs of
|strmcon_nil
( (*void*) ) => (true)
|strmcon_cons
(  x1, xs  ) =>
(
if
iforall$test
< x0 >(i0, x1)
then auxmain(i0+1, xs) else false)
)(*case+*)//end-of-[auxmain(i0, xs)]
}(*where*)//end-of-[strm_iforall(xs)]
//
#impltmp
{ x0:t0 }
gseq_iforall
<strm(x0)><x0> = strm_iforall<x0>(*0*)
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
strm_iforall$f2un
  (xs, test) =
(
strm_iforall
<  x0  >(  xs  )) where
{
#impltmp
iforall$test<x0> = test(*ni,x0*)
}(*where*)//end-of-[strm_iforall$f2un]
//
#impltmp
{ x0:t0 }
gseq_iforall$f2un
<strm(x0)><x0> = strm_iforall$f2un<x0>(*0*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-21:
Sun Dec 21 09:32:13 AM EST 2025
*)
//
#impltmp
< x0:t0 >
< y0:t0 >
strm_map(xs) =
(
  auxmain(xs)) where
{
fun
auxmain
( xs
: strm(x0)
) : strm(y0) = $lazy
(
case+ !xs of
| ~
strmcon_nil() =>
strmcon_nil(*void*)
| ~
strmcon_cons(x1, xs) =>
strmcon_cons(
map$fopr<x0><y0>(x1), auxmain(xs))
)
}(*where*)//end-of-[strm_map( xs )]
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
< y0:vt >
strm_map_vt
  (  xs  ) =
(
  auxmain(xs)) where
{
fun
auxmain
( xs
: strm(x0)
) : strm_vt(y0) = $llazy
(
case+ !xs of
| ~
strmcon_nil() =>
strmcon_vt_nil(*void*)
| ~
strmcon_cons(x1, xs) =>
strmcon_vt_cons(
map$fopr<x0><y0>(x1), auxmain(xs))
)
}(*where*)//end-of-[strm_map_vt( xs )]
//
#impltmp
{ x0:t0 }
{ y0:vt }
gseq_map_lstrm
<strm(x0)><x0><y0> = strm_map_vt<x0><y0>(*void*)
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
< y0:t0 >
strm_imap(xs) =
(
auxmain(0, xs)) where
{
fun
auxmain
( i0
: nint
, xs
: strm(x0)
) : strm(y0) = $lazy
(
case+ !xs of
| ~
strmcon_nil() =>
strmcon_nil(*void*)
| ~
strmcon_cons(x1, xs) =>
let
val y1 =
imap$fopr<x0><y0>(i0, x1)
in//let
strmcon_cons(y1,auxmain(i0+1,xs))
end//let//end-of-[strmcon_cons()]
)
}(*where*)//end-of-[strm_imap( xs )]
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
< y0:t0 >
strm_imap_vt
  (  xs  ) =
(
auxmain(0, xs)) where
{
fun
auxmain
( i0
: nint
, xs
: strm(x0)
) : strm_vt(y0) = $llazy
(
case+ !xs of
| ~
strmcon_nil() =>
strmcon_vt_nil(*void*)
| ~
strmcon_cons(x1, xs) =>
let
val y1 =
imap$fopr<x0><y0>(i0, x1)
in//let
strmcon_vt_cons(y1,auxmain(i0+1,xs))
end//let//end-of-[strmcon_cons(x1,xs)]
)
}(*where*)//end-of-[strm_imap_vt( xs )]
//
#impltmp
{ x0:t0 }
{ y0:vt }
gseq_imap_lstrm
<strm(x0)><x0><y0> = strm_imap_vt<x0><y0>(*void*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-21:
Sun Dec 21 10:16:58 AM EST 2025
*)
//
#impltmp
< x0:t0 >
strm_filter
  (  xs  ) =
$lazy(
auxloop
(
strm_eval<x0>(xs)))
where
{
fnx
auxloop
( cs
: strmcon(x0)
) : strmcon(x0) =
(
case+ cs of
|
strmcon_nil
( (*void*) ) =>
(
  strmcon_nil(*void*))
|
strmcon_cons
(  x1, xs  ) =>
let
//
val
test =
filter$test<x0>(x1)
//
in//let
(
if
test
then
strmcon_cons
(
x1,
$lazy
(auxloop(!xs))) else auxloop(!xs))
end//let//end-of(strmcon_cons(...))
)(*case+*)//end-of-[auxloop(  cs  )]
}(*where*)//end-of-[strm_filter(xs)]
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
strm_filter$f1un
  (xs, test) =
(
strm_filter<x0>(xs))
where
{
#impltmp
filter$test<x0> = test(*x0*)
}(*where*)//end-of-[strm_filter$f1un]
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
strm_filter_vt
  (  xs  ) =
$llazy(
auxloop
(
strm_eval<x0>(xs)))
where
{
fnx
auxloop
( cs
: strmcon(x0)
) : strmcon_vt(x0) =
(
case+ cs of
|
strmcon_nil
( (*void*) ) =>
(
strmcon_vt_nil(*void*))
|
strmcon_cons
(  x1, xs  ) =>
let
//
val
test =
filter$test<x0>(x1)
//
in//let
if
test
then
strmcon_vt_cons
(
x1,
$llazy
(auxloop(!xs)))
else auxloop(!xs) end//let
)(*case+*)//end-of-[auxloop(cs)]
}(*where*)//end-of-[strm_filter(xs)]
//
#impltmp
{ x0:t0 }
gseq_filter_lstrm
<strm(x0)><x0> = strm_filter_vt<x0>(*void*)
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
strm_ifilter
  (  xs  ) =
$lazy(
auxloop(0,
strm_eval<x0>(xs)))
where
{
fnx
auxloop
( i0
: nint
, xs
: strmcon(x0)
) : strmcon(x0) =
(
case+ xs of
| ~
strmcon_nil() =>
(
  strmcon_nil(*void*))
| ~
strmcon_cons(x1, xs) =>
let
val
test =
ifilter$test<x0>(i0, x1)
in//let
if
test
then
strmcon_cons
(
x1,
$lazy
(auxloop(i0+1, !xs)))
else auxloop(i0+1, !xs) end//let
)(*case+*)//end-of-[auxloop(i0,cs)]
}(*where*)//end-of-[strm_ifilter(xs)]
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
strm_ifilter$f2un
  (xs, test) =
(
strm_ifilter<x0>(xs))
where
{
#impltmp
ifilter$test<x0> = test(*ni,x0*)
}(*where*)//end-of-[strm_ifilter$f2un]
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
strm_ifilter_vt
  (  xs  ) =
$llazy(
auxloop(0,
strm_eval<x0>(xs)))
where
{
fnx
auxloop
( i0
: nint
, xs
: strmcon(x0)
) : strmcon_vt(x0) =
(
case+ xs of
| ~
strmcon_nil() =>
(
strmcon_vt_nil(*void*))
| ~
strmcon_cons(x1, xs) =>
let
val
test =
ifilter$test<x0>(i0, x1)
in//let
if
test
then
strmcon_vt_cons
(
x1,
$llazy
(auxloop(i0+1, !xs)))
else auxloop(i0+1, !xs) end//let
)(*case+*)//end-of-[auxloop(i0,cs)]
}(*where*)//end-of-[strm_ifilter_vt(xs)]
//
(*
HX-2025-12-21:
This one is not yet declared:
#impltmp
{ x0:t0 }
gseq_ifilter_lstrm
<strm(x0)><x0> = strm_ifilter_vt<x0>(*void*)
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< x0:t0 >
strm_strmize
  (  xs  ) =
(
  auxmain(xs)) where
{
fun
auxmain
(xs: strm(x0)): strm_vt(x0) =
$llazy(
//
case+ !xs of
|
strmcon_nil
(  (*0*)  ) =>
(
  strmcon_vt_nil(*void*))
|
strmcon_cons
(  x1, xs  ) =>
(
  strmcon_vt_cons(x1, auxmain(xs))))
}(*where*)//end-of-[strm_strmize(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-21:
Sun Dec 21 10:36:35 AM EST 2025
*)
//
#impltmp
< x0:t0 >
strm_listize
  (  xs  ) =
let
val xs =
strm_rlistize<x0>(xs)
in//let
list_vt_reverse0<x0>(xs) end
//
#impltmp
< x0:t0 >
strm_rlistize
  (  xs  ) =
(
  loop(xs, rs)) where
{
//
val rs = list_vt_nil()
//
fun loop
( xs: strm(x0)
, rs: list_vt(x0)): list_vt(x0) =
(
case+ !xs of
|
strmcon_nil
(  (*0*)  ) => (rs)
|
strmcon_cons
(  x1, xs  ) =>
(
  loop(xs, list_vt_cons(x1,rs))))
}(*where*)//end-of-[strm_rlistize(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-21:
Sun Dec 21 10:39:48 AM EST 2025
*)
//
#impltmp
< x0:t0 >
< y0:t0 >
< e1:vt >
strm_map$e1nv
  ( xs, e1 ) =
(
strm_map
<x0><y0>(xs)) where
{
#impltmp
map$fopr<x0><y0>(x0) =
(
  map$e1nv$fopr<x0><y0><e1>(x0, e1))
}(*where*)//end-of-[strm_map$e1nv(xs,e1)]
//
#impltmp
< x0:t0 >
< y0:t0 >
< e1:vt >
strq_map$e1nv
  ( xs, e1 ) =
(
strq_map
<x0><y0>(xs)) where
{
#impltmp
map$fopr<x0><y0>(x0) =
(
  map$e1nv$fopr<x0><y0><e1>(x0, e1))
}(*where*)//end-of-[strq_map$e1nv(xs,e1)]
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
< y0:vt >
< e1:vt >
strm_map$e1nv_vt
  ( xs, e1 ) =
(
strm_map_vt
<x0><y0>(xs)) where
{
#impltmp
map$fopr<x0><y0>(x0) =
(
  map$e1nv$fopr<x0><y0><e1>(x0, e1))
}(*where*)//end-of-[strm_map$e1nv_vt(xs,e1)]
//
#impltmp
< x0:t0 >
< y0:vt >
< e1:vt >
strq_map$e1nv_vt
  ( xs, e1 ) =
(
strq_map_vt
<x0><y0>(xs)) where
{
#impltmp
map$fopr<x0><y0>(x0) =
(
  map$e1nv$fopr<x0><y0><e1>(x0, e1))
}(*where*)//end-of-[strq_map$e1nv_vt(xs,e1)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-03:
Sat Jan  3 01:43:58 PM EST 2026
*)
//
#impltmp
< x0:t0 >
< y0:t0 >
< e1:vt >
strm_map$e0nv
  (xs, e1) =
(
  auxmain(xs, e1)) where
{
fun
auxmain
( xs
: strm(x0)
, e1: (~e1)
) : strm(y0) = $lazy
(
case+ !xs of
| ~
strmcon_nil() =>
(
g_free<e1>(e1);
strmcon_nil(*void*))
| ~
strmcon_cons(x1, xs) =>
let
val y1 =
map$e1nv$fopr<x0><y0>(x1, e1)
in//let
strmcon_cons(y1, auxmain(xs, e1))
end//let
)
}(*where*)//end-of-[strm_map$e0nv(xs,e1)]
//
(* ****** ****** *)
//
#impltmp
< x0:t0 >
< y0:t0 >
< e1:vt >
strm_map$e0nv_vt
  (xs, e1) =
(
  auxmain(xs, e1)) where
{
fun
auxmain
( xs
: strm(x0)
, e1: (~e1)
) : strm_vt(y0) = $llazy
(
case+ !xs of
| ~
strmcon_nil() =>
(
g_free<e1>(e1);
strmcon_vt_nil(*void*))
| ~
strmcon_cons(x1, xs) =>
let
val y1 =
map$e1nv$fopr<x0><y0>(x1, e1)
in//let
strmcon_vt_cons(y1, auxmain(xs, e1))
end//let
)
}(*where*)//end-of-[strm_map$e0nv_vt(xs,e1)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_strm001.dats] *)
(***********************************************************************)
`,
  "DATS/strn000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Thu 11 Jul 2024 01:11:20 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
g_0<strn>
((*void*)) = ("")
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
strn_lt<> = g_lt<strn>
#impltmp
strn_gt<> = g_gt<strn>
#impltmp
strn_eq<> = g_eq<strn>
//
#impltmp
strn_lte<> = g_lte<strn>
#impltmp
strn_gte<> = g_gte<strn>
#impltmp
strn_neq<> = g_neq<strn>
//
(* ****** ****** *)
//
#impltmp
g_cmp<strn> = strn_cmp<>
//
(* ****** ****** *)
//
#impltmp
g_equal<strn> = strn_eq<>
#impltmp
g_noteq<strn> = strn_neq<>
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX:
This is in [gdbg000.dats]:
#impltmp
g_ptype
< strn >
( (*void*) ) = pstrn("strn")
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
g_print<strn> = strn_print<>
//
(*
#impltmp
g_print
<strn>(cs) =
(
strn_print("\\"");
strn_print(cs);strn_print("\\""))
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-10:
This one should definitely
be replaced later!!!
Sat 10 Aug 2024 08:49:55 PM EDT
*)
#impltmp
<(*tmp*)>
strn_cmp
(xs, ys) =
let
#typedef xs = strn
#typedef x0 = cgtz
in//let
gseq_cmp<xs><x0>(xs, ys) end
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
gasq_length
<strn><char> = strn_length<>(*0*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-04:
This is a reference version
Sun Jan  4 05:07:54 PM EST 2026
*)
//
(*
#impltmp
<(*tmp*)>
strn_fset$at
(cs, i0, c0) =
(
$UN.strn_fset$at$raw(cs, i0, c0))
*)
//
#impltmp
<(*tmp*)>
strn_fset$at
(cs, i0, c0) =
let
val ln =
strn_length<>(cs)
in//let
strn_make_nfun<>(
ln,
lam i1 =>
(if (i0=i1) then c0 else cs[i1]))
end//let//end-of-[strn_fset$at(...)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
strn_gmake
<list(cgtz)> = strn_make_list<>
//
#impltmp
strn_gmake
<list_vt(cgtz)> = strn_make_llist<>
//
#impltmp
strn_gmake
<strm_vt(cgtz)> = strn_make_lstrm<>
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
g_add
< strn > =
g_append<strn>(*void*)
#impltmp
g_append
< strn > = strn_append<>(*void*)
//
#impltmp
<(*tmp*)>
strn_append
  (xs, ys) =
strn_fmake_fwork<>
(
lam(work) =>
(foritm(xs, work); foritm(ys, work)))
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
strn_reverse
  ( xs ) =
strn_fmake_fwork<>
(lam(work) => rforitm(xs, work))
#impltmp
<(*tmp*)>
strn_rappend
  (xs, ys) =
strn_fmake_fwork<>
(
lam(work) => (
rforitm(xs, work); foritm(ys, work)))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
strn_lower
(   cs   ) =
let
val ln =
strn_length<>(cs)
in//let
strn_make_nfun<>(
ln,
lam(i0) =>
char_lower(
$UN.strn_get$at$raw<>(cs,i0)))
end(*let*)//end-of-[strn_lower(cs)]
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
strn_upper
(   cs   ) =
let
val ln =
strn_length<>(cs)
in//let
strn_make_nfun<>(
ln,
lam(i0) =>
char_upper(
$UN.strn_get$at$raw<>(cs,i0)))
end(*let*)//end-of-[strn_upper(cs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
strn_slice
(cs, i0, j0) =
(
strn_make_nfun<>
(
j0-i0,
lam(k0) =>
$UN.strn_get$at$raw<>(cs,i0+k0)
)
)(*end-of-[strn_slice(cs, i0, j0)]*)
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
strn_prefix
  (cs, i0) =
(
  strn_slice<>(cs, 0, i0))
//
#impltmp
<(*tmp*)>
strn_suffix
  (cs, i0) =
let
val n0 =
strn_length<>(cs) in//let
(
  strn_slice<>(cs, i0, n0)) end
(*let*)//end-of-[strn_suffix(cs,i0)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-17:
Sat 17 Aug 2024 08:32:31 AM EDT
*)
//
#impltmp
<(*tmp*)>
strn_make_ncpy
  (n0, c0) =
strn_fmake_fwork<>
(
lam(work) =>
foritm(n0, //HX:it may not be
  lam(i0) => work(c0)))//efficient!
//
#impltmp
<(*tmp*)>
strn_make_nfun
  (n0, f0) =
strn_fmake_fwork<>
(
lam(work) =>
foritm(n0, //HX:it may not be
  lam(i0) => work(f0(i0))))//efficient!
//
(* ****** ****** *)
//
(*
HX-2024-08-16:
Fri 16 Aug 2024 05:02:22 PM EDT
*)
//
#impltmp
<(*tmp*)>
strn_make_list
  ( cs ) =
(
strn_make_gseq<list(cgtz)>(cs))
//
#impltmp
< cs:t0 >
strn_make_gseq
  ( cs ) =
let
#typedef c0=cgtz
#impltmp
map$fopr<c0><c0>(c0) = c0
in//let
(
  strn_map$make_gseq<cs><c0>(cs))
end//let//end-of-[strn_make_gseq(cs)]
//
#impltmp
< xs:t0 >
< x0:t0 >
strn_map$make_gseq
  ( xs ) =
let
#typedef c0=cgtz
in//let
strn_fmake_fwork<> 
(
lam(work) => // HX: inefficent?
gseq_foritm$f1un<xs><x0>
( xs
, lam(c0)=>work(map$fopr<x0><c0>(c0))))
end//let//end-of-[strn_map$make_gseq(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
strn_make_llist
  ( cs ) =
let
//
#vwtpdef
env = list_vt(cgtz)
//
fun fwork
( cs: env
, work: cgtz->void) =
(
case+ cs of
| ~
list_vt_nil() => ()
| ~
list_vt_cons(c1, cs) =>
(work(c1); fwork(cs, work)))
//
in//let
//
(
strn_fmake_env$fwork<env>(cs, fwork))
end(*let*)//end-of-[strn_make_llist(cs)]
//
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
strn_make_lstrm
  ( cs ) =
let
//
#vwtpdef
env = strm_vt(cgtz)
//
fun fwork
( cs: env
, work: cgtz->void) =
(
case+ !cs of
| ~
strmcon_vt_nil() => ()
| ~
strmcon_vt_cons(c1, cs) =>
(work(c1); fwork(cs, work)))
//
in//let
//
(
strn_fmake_env$fwork<env>(cs, fwork))
end(*let*)//end-of-[strn_make_lstrm(cs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
strn_make1_llist
  (  cs  ) =
let
//
#vwtpdef
env = list_vt(cgtz)
//
fun fwork
( cs: !env
, work: cgtz->void) =
(
case+ cs of
| !
list_vt_nil() => ()
| !
list_vt_cons(c1, cs) =>
(work(c1); fwork(cs, work)))
//
in//let
//
(
strn_fmake1_env$fwork<env>(cs, fwork))
end(*let*)//end-of-[strn_make1_llist(cs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
$UN.gasq_get$at$raw
< strn >< cgtz >(cs, i0) =
$UN.strn_get$at$raw<>(cs, i0)
//
#impltmp
$UN.gasq_lget$at$raw
< strn >< cgtz >(cs, i0) =
let
val c0 =
$UN.strn_get$at$raw<>(cs, i0)
pvx pf = owed_t0_make{cgtz}() in (pf|c0)
end//let
(*end($UN.gasq_lget$at$raw<strn><cgtz>)*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
$UN.strn_fset$at$raw
  (cs, i0, c0) =
strn_fmake_fwork<>
(
lam(work) =>
strn_iforitm$f2un
(
cs,
lam(i1,c1) => (
if(i0=i1)then(work(c0))else(work(c1)))))
//end-of-($UN.strn_fset$at$raw(cs,i0,c0))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-05:
Mon Jan  5 01:37:02 PM EST 2026
*)
#impltmp
gseq_nilq<strn><cgtz> = strn_nilq<>(*cs*)
#impltmp
gseq_consq<strn><cgtz> = strn_consq<>(*cs*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_strn000.dats] *)
(***********************************************************************)
`,
  "DATS/strn001.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Wed 07 Aug 2024 02:18:49 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
(*
#impltmp
strn_forall<> =
gasq_forall<strn><cgtz>
*)
//
#impltmp
<>(*tmp*)
strn_forall(cs) =
(
  nint_forall<>(n0))
where
{
//
val n0 =
(
  strn_length<>(cs))
//
#impltmp
forall$test<ni>(i0) =
(
  forall$test<cgtz>(c0))
where
{
val c0 =
  $UN.strn_get$at$raw<>(cs, i0)
}
}(*where*)//end-of-[strn_forall(cs)]
//
#impltmp
<>(*tmp*)
strn_forall$f1un
  (cs, test) =
(
  strn_forall<>(cs)) where
{
#impltmp
forall$test<cgtz>(ch) = test(ch)
}(*where*)//end-of-[strn_forall$f1un]
//
#impltmp
gseq_forall
<strn><cgtz> = strn_forall<>(*void*)
//
#impltmp
gasq_forall
<strn><cgtz>(cs) =
(
strn_forall<>(cs)) where
{
#impltmp
forall$test<cgtz> = forall$test1<cgtz>
}
//
(* ****** ****** *)
//
#impltmp
<>(*tmp*)
strn_rforall(cs) =
(
  nint_rforall<>(n0))
where
{
//
val n0 = strn_length<>(cs)
//
#impltmp
rforall$test<ni>(i0) =
(
  rforall$test<cgtz>(c0)) where
{
val c0 =
  $UN.strn_get$at$raw<>(cs, i0)
}
}(*where*)//end-of-[strn_rforall(cs)]
//
#impltmp
<>(*tmp*)
strn_rforall$f1un
  (cs, test) =
(
  strn_rforall<>(cs)) where
{
#impltmp
rforall$test<cgtz>(ch) = test(ch)
}(*where*)//end-of-[strn_rforall$f1un]
//
#impltmp
gseq_rforall
<strn><cgtz> = strn_rforall<>(*void*)
//
#impltmp
gasq_rforall
<strn><cgtz>(cs) =
(
strn_rforall<>(cs)) where
{
#impltmp
rforall$test<cgtz> = rforall$test1<cgtz>
}
//
(* ****** ****** *)
//
(*
HX-2024-08-07:
The following code simply
indicate no need for these
special function interfaces!
The code is kept as a referece.
Wed 07 Aug 2024 02:22:37 PM EDT
*)
//
(*
#impltmp
<>(*tmp*)
strn_iforall =
gseq_iforall<strn><cgtz>
*)
//
#impltmp
<>(*tmp*)
strn_iforall(cs) =
(
  nint_forall<>(n0))
where
{
//
val n0 =
(
  strn_length<>(cs))
//
#impltmp
forall$test<ni>(i0) =
(
iforall$test<cgtz>(i0, c0))
where
{
val c0 =
  $UN.strn_get$at$raw<>(cs, i0)
}
}(*where*)//end-of-[strn_iforall(cs)]
//
#impltmp
<>(*tmp*)
strn_iforall$f2un
  (cs, test) =
(
  strn_iforall<>(cs)) where
{
#impltmp
iforall$test<cgtz>(i0,ch) = test(i0,ch)
}
//
#impltmp
gseq_iforall
<strn><cgtz> = strn_iforall<>(*void*)
//
#impltmp
gasq_iforall
<strn><cgtz>(cs) =
(
strn_iforall<>(cs)) where
{
#impltmp
iforall$test<cgtz> = iforall$test1<cgtz>
}
//
(* ****** ****** *)
//
#impltmp
<>(*tmp*)
strn_irforall =
gseq_irforall<strn><cgtz>
//
#impltmp
<>(*tmp*)
strn_irforall$f2un
  (cs, test) =
(
  strn_irforall<>(cs)) where
{
#impltmp
irforall$test<cgtz>(i0,ch) = test(i0,ch)
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<>(*tmp*)
strn_foritm =
gseq_foritm<strn><cgtz>
#impltmp
<>(*tmp*)
strn_foritm$f1un
  (cs, work) =
(
  strn_foritm<>(cs)) where
{
#impltmp
foritm$work<cgtz>(ch) = work(ch)
}
//
(* ****** ****** *)
//
#impltmp
<>(*tmp*)
strn_rforitm =
gseq_rforitm<strn><cgtz>
#impltmp
<>(*tmp*)
strn_rforitm$f1un
  (cs, work) =
(
  strn_rforitm<>(cs)) where
{
#impltmp
rforitm$work<cgtz>(ch) = work(ch)
}
//
(* ****** ****** *)
//
#impltmp
<>(*tmp*)
strn_iforitm =
gseq_iforitm<strn><cgtz>
#impltmp
<>(*tmp*)
strn_iforitm$f2un
  (cs, work) =
(
  strn_iforitm<>(cs)) where
{
#impltmp
iforitm$work<cgtz>(i0,ch) = work(i0,ch)
}
//
(* ****** ****** *)
//
#impltmp
<>(*tmp*)
strn_irforitm =
gseq_irforitm<strn><cgtz>
#impltmp
<>(*tmp*)
strn_irforitm$f2un
  (cs, work) =
(
  strn_irforitm<>(cs)) where
{
#impltmp
irforitm$work<cgtz>(i0,ch) = work(i0,ch)
}
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<>(*tmp*)
strn_listize = gasq_listize<strn><cgtz>
#impltmp
gseq_listize<strn><cgtz> = strn_listize
//
#impltmp
<>(*tmp*)
strn_strmize = gasq_strmize<strn><cgtz>
#impltmp
gseq_strmize<strn><cgtz> = strn_strmize
//
#impltmp
<>(*tmp*)
strn_strqize = gasq_strqize<strn><cgtz>
#impltmp
gseq_strqize<strn><cgtz> = strn_strqize
//
(* ****** ****** *)
//
#impltmp
<>(*tmp*)
strn_rlistize = gasq_rlistize<strn><cgtz>
#impltmp
gseq_rlistize<strn><cgtz> = strn_rlistize
//
#impltmp
<>(*tmp*)
strn_rstrmize = gasq_rstrmize<strn><cgtz>
#impltmp
gseq_rstrmize<strn><cgtz> = strn_rstrmize
//
#impltmp
<>(*tmp*)
strn_rstrqize = gasq_rstrqize<strn><cgtz>
#impltmp
gseq_rstrqize<strn><cgtz> = strn_rstrqize
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< xs:t0 >
gseq_strn$concat
  ( xs ) = let
//
#typedef x0 = strn
//
in//let
strn_fmake_fwork<>
(
lam(work) =>
gseq_foritm$f1un<xs><x0>(xs,
lam(cs) => strn_foritm$f1un<>(cs, work)))
end(*let*)//end-of-[gseq_strn$concat( xs )]
//
#impltmp
< xs:t0 >
gseq_strn$rconcat
  ( xs ) = let
//
#typedef x0 = strn
//
in//let
strn_fmake_fwork<>
(
lam(work) =>
gseq_rforitm$f1un<xs><x0>(xs,
lam(cs) => strn_rforitm$f1un<>(cs, work)))
end(*let*)//end-of-[gseq_strn$rconcat( xs )]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-05-08:
Thu May  8 02:19:19 PM EDT 2025
*)
#impltmp
<(*tmp*)>
strm_vt_strn$concat0
  ( xs ) =
let
//
#vwtpdef
xs = strm_vt(strn)
//
in//let
//
strn_fmake_env$fwork<xs>
(
xs,
lam(xs, work) =>
strm_vt_foritm0$f1un<strn>(xs,
lam(cs) => strn_foritm$f1un(cs, work)))
//
end(*let*)//end-of-[strm_vt_strn$concat0(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_strn001.dats] *)
(***********************************************************************)
`,
  "DATS/strx000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Wed May  7 08:47:50 AM EDT 2025
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX:
This one is also
implemented in [gdbg000.dats]:
*)
#impltmp
{ t0:t0 }
g_ptcon
<strx(t0)>
( (*void*) ) =
(
pstrn("strx"))
#impltmp
{ t0:t0 }
g_ptype
<strx(t0)>
( (*void*) ) =
(
pstrn("strx(");
g_ptype<t0>((*0*)); pstrn(")"))
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_strx000.dats] *)
(***********************************************************************)
`,
  "DATS/strx001.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sun Dec 21 01:14:47 AM EST 2025
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_strx001.dats] *)
(***********************************************************************)
`,
  "DATS/tupl000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(*
** for flat tuples
** for boxd tuples
*)
(* ****** ****** *)
(*
HX-2023-08-06:
@(...): flat tuple
#(...): boxd tuple
$tup(...): boxd tuple
(Change: $(...) -> #(...))
Sun Aug  6 19:45:40 EDT 2023
*)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(Around some time in 2022)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-04:
Copying over from [srcgen1]
Sun 04 Aug 2024 05:41:59 PM EDT
*)
//
(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ a0:t0
, a1:t0 }
g_ptype
<t0up(a0,a1)>
(  (*void*)  ) =
( pstrn"t0up2("
; g_ptype<a0>(); pstrn(",")
; g_ptype<a1>(); pstrn(")"))
//
#impltmp
{ a0:t0
, a1:t0 }
g_ptype
<t1up(a0,a1)>
(  (*void*)  ) =
( pstrn"t1up2("
; g_ptype<a0>(); pstrn(",")
; g_ptype<a1>(); pstrn(")"))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ a0:t0
, a1:t0
, a2:t0 }
g_ptype
<t0up(a0,a1,a2)>
(  (*void*)  ) =
( pstrn"t0up3("
; g_ptype<a0>(); pstrn(",")
; g_ptype<a1>(); pstrn(",")
; g_ptype<a2>(); pstrn(")"))
//
#impltmp
{ a0:t0
, a1:t0
, a2:t0 }
g_ptype
<t1up(a0,a1,a2)>
(  (*void*)  ) =
( pstrn"t1up3("
; g_ptype<a0>(); pstrn(",")
; g_ptype<a1>(); pstrn(",")
; g_ptype<a2>(); pstrn(")"))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ a0:t0
, a1:t0 }
g_print
<t0up(a0,a1)>
  ( tup ) =
let
//
val () =
  strn_print("@(")
val () =
  g_print<a0>(tup.0)
//
val () = pstrn(",")
val () =
  g_print<a1>(tup.1)
//
val () = strn_print(")")
//
end // end of [g_print<t0up2>(tup)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ a0:t0
, a1:t0
, a2:t0 }
g_print
<t0up(a0,a1,a2)>
  ( tup ) =
let
//
val () =
  strn_print("@(")
val () =
  g_print<a0>(tup.0)
//
val () = pstrn(",")
val () =
  g_print<a1>(tup.1)
//
val () = pstrn(",")
val () =
  g_print<a2>(tup.2)
//
val () = strn_print(")")
//
end // end of [g_print<t0up3>(tup)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ a0:t0
, a1:t0
, a2:t0
, a3:t0 }
g_print
<t0up(a0,a1,a2,a3)>
  ( tup ) =
let
//
val () =
  strn_print("@(")
val () =
  g_print<a0>(tup.0)
//
val () = pstrn(",")
val () =
  g_print<a1>(tup.1)
//
val () = pstrn(",")
val () =
  g_print<a2>(tup.2)
//
val () = pstrn(",")
val () =
  g_print<a3>(tup.3)
//
val () = strn_print(")")
//
end // end of [g_print<t0up4>(tup)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ a0:t0
, a1:t0
, a2:t0
, a3:t0
, a4:t0 }
g_print
<t0up(a0,a1,a2,a3,a4)>
  ( tup ) =
let
//
val () =
  strn_print("@(")
val () =
  g_print<a0>(tup.0)
//
val () = pstrn(",")
val () =
  g_print<a1>(tup.1)
//
val () = pstrn(",")
val () =
  g_print<a2>(tup.2)
//
val () = pstrn(",")
val () =
  g_print<a3>(tup.3)
//
val () = pstrn(",")
val () =
  g_print<a4>(tup.4)
//
val () = strn_print(")")
//
end // end of [g_print<t0up5>(tup)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ a0:t0
, a1:t0
, a2:t0
, a3:t0
, a4:t0
, a5:t0 }
g_print
<t0up(a0,a1,a2,a3,a4,a5)>
  ( tup ) =
let
//
val () =
  strn_print("@(")
val () =
  g_print<a0>(tup.0)
//
val () = pstrn(",")
val () =
  g_print<a1>(tup.1)
//
val () = pstrn(",")
val () =
  g_print<a2>(tup.2)
//
val () = pstrn(",")
val () =
  g_print<a3>(tup.3)
//
val () = pstrn(",")
val () =
  g_print<a4>(tup.4)
//
val () = pstrn(",")
val () =
  g_print<a5>(tup.5)
//
val () = strn_print(")")
//
end // end of [g_print<t0up6>(tup)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_tupl000.dats] *)
(***********************************************************************)
`,
  "DATS/tupl001.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Wed 07 Aug 2024 02:30:05 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
gseq_forall
<t0up(x0,x0)><x0>
  ( tup ) =
let
val b0 =
forall$test<x0>(tup.0)
in//let
if b0 then
forall$test<x0>(tup.1) else false
end//let//end-of-[gseq_forall(...)]
//
#impltmp
{ x0:t0 }
gseq_forall
<t1up(x0,x0)><x0>
  ( tup ) =
let
val b0 =
forall$test<x0>(tup.0)
in//let
if b0 then
forall$test<x0>(tup.1) else false
end//let//end-of-[gseq_forall(...)]
//
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
gseq_rforall
<t0up(x0,x0)><x0>
  ( tup ) =
let
val b0 =
rforall$test<x0>(tup.1)
in//let
if b0 then
rforall$test<x0>(tup.0) else false
end//let//end-of-[gseq_rforall(...)]
//
#impltmp
{ x0:t0 }
gseq_rforall
<t1up(x0,x0)><x0>
  ( tup ) =
let
val b0 =
rforall$test<x0>(tup.1)
in//let
if b0 then
rforall$test<x0>(tup.0) else false
end//let//end-of-[gseq_rforall(...)]
//
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
gseq_iforall
<t0up(x0,x0)><x0>
  ( tup ) =
let
val b0 =
iforall$test<x0>(0, tup.0)
in//let
if b0 then
iforall$test<x0>(1, tup.1) else false
end//let//end-of-[gseq_iforall(...)]
//
#impltmp
{ x0:t0 }
gseq_iforall
<t1up(x0,x0)><x0>
  ( tup ) =
let
val b0 =
iforall$test<x0>(0, tup.0)
in//let
if b0 then
iforall$test<x0>(1, tup.1) else false
end//let//end-of-[gseq_iforall(...)]
//
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
gseq_irforall
<t0up(x0,x0)><x0>
  ( tup ) =
let
val b0 =
irforall$test<x0>(1, tup.1)
in//let
if b0 then
irforall$test<x0>(0, tup.0) else false
end//let//end-of-[gseq_iforall(...)]
//
#impltmp
{ x0:t0 }
gseq_irforall
<t1up(x0,x0)><x0>
  ( tup ) =
let
val b0 =
irforall$test<x0>(1, tup.1)
in//let
if b0 then
irforall$test<x0>(0, tup.0) else false
end//let//end-of-[gseq_irforall(...)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-17:
Sat 17 Aug 2024 02:55:13 PM EDT
*)
//
#impltmp
{ x0:t0 }
gseq_forall
<t0up(x0,x0,x0)><x0>
  ( tup ) =
(
if not
(forall$test<x0>(tup.0))
then false else
if not
(forall$test<x0>(tup.1))
then false
else forall$test<x0>(tup.2))//forall
#impltmp
{ x0:t0 }
gseq_exists
<t0up(x0,x0,x0)><x0>
  ( tup ) =
(
if
exists$test<x0>(tup.0)
then true
else if // more
exists$test<x0>(tup.1) 
then true // more
else exists$test<x0>(tup.2))//exists
//
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
gseq_forall
<t1up(x0,x0,x0)><x0>
  ( tup ) =
(
if not(
forall$test<x0>(tup.0))
then false else
if not(
forall$test<x0>(tup.1))
then false
else forall$test<x0>(tup.2))//forall
#impltmp
{ x0:t0 }
gseq_exists
<t1up(x0,x0,x0)><x0>
  ( tup ) =
(
if
exists$test<x0>(tup.0)
then true
else if // more
exists$test<x0>(tup.1) 
then true // more
else exists$test<x0>(tup.2))//exists
//
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
gseq_rforall
<t0up(x0,x0,x0)><x0>
  ( tup ) =
(
if not(
rforall$test<x0>(tup.2))
then false else
if not(
rforall$test<x0>(tup.1))
then false
else rforall$test<x0>(tup.0))//rforall
#impltmp
{ x0:t0 }
gseq_rexists
<t0up(x0,x0,x0)><x0>
  ( tup ) =
(
if
rexists$test<x0>(tup.2)
then true
else if // more
rexists$test<x0>(tup.1) 
then true // more
else rexists$test<x0>(tup.0))//rexists
//
(* ****** ****** *)
//
#impltmp
{ x0:t0 }
gseq_rforall
<t1up(x0,x0,x0)><x0>
  ( tup ) =
(
if not(
rforall$test<x0>(tup.2))
then false else
if not(
rforall$test<x0>(tup.1))
then false
else rforall$test<x0>(tup.0))//rforall
#impltmp
{ x0:t0 }
gseq_rexists
<t1up(x0,x0,x0)><x0>
  ( tup ) =
(
if
rexists$test<x0>(tup.2)
then true
else if // more
rexists$test<x0>(tup.1) 
then true // more
else rexists$test<x0>(tup.0))//rexists
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_tupl001.dats] *)
(***********************************************************************)
`,
  "DATS/tupl002.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sun 11 Aug 2024 08:24:54 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ a0:t0
, a1:t0 }
g_cmp
<t0up(a0,a1)>
  (x0, x1) =
let
//
val sgn =
g_cmp<a0>(x0.0, x1.0)
//
in//let
if
(sgn = 0) then
g_cmp<a1>(x0.1, x1.1) else sgn
end//let//end-of-[g_cmp<t0up(...)>]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_tupl002.dats] *)
(***********************************************************************)
`,
  "DATS/unsfx00.dats": `(* ****** ****** *)
(*
** HX-2020-02:
** for unsafe functions
*)
(* ****** ****** *)
(* ****** ****** *)
//
#staload UN =
"prelude/SATS/unsfx00.sats"
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
< a: vt >
$UN.p2tr_get
(p0) = $eval(p0)
#impltmp
<a>(*tmp*)
$UN.p2tr_set
(p0, x0) = $eval(p0) := x0
//
(* ****** ****** *)
//
#impltmp
< a: vt >
$UN.p2tr_ret
(p0, x0) =
let
val x0 = $UN.delinear(x0) in ()
endlet // end of [$UN.p2tr_ret]
//
(* ****** ****** *)
//
#impltmp
< a: t0 >
$UN.p2tr_set_list_nil
  (p0) =
(
$UN.p2tr_set
<list(a)>(p0, list_nil())
)
//
#impltmp
< a: t0 >
$UN.p2tr_set_list_cons
  (p0, x0) =
let
#typedef
xs = list(a)
val xs = 
$UN.p2tr_get<xs>(p0)
in//let
$UN.p2tr_set<xs>(p0,list_cons(x0,xs))
end//end-of-[$UN.p2tr_set_list_cons(...)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ xs:t0 }
{ x0:t0 }
$UN.gseq_head$raw
  ( xs ) =
let
val (x0, xs) =
$UN.gseq_uncons$raw<xs><x0>(xs) in (x0)
end(*let*)//end-of-[$UN.gseq_head$raw(xs)]
#impltmp
{ xs:t0 }
{ x0:t0 }
$UN.gseq_tail$raw
  ( xs ) =
let
val (x0, xs) =
$UN.gseq_uncons$raw<xs><x0>(xs) in (xs)
end(*let*)//end-of-[$UN.gseq_tail$raw(xs)]
//
#impltmp
{ xs:t0 }
{ x0:t0 }
$UN.gseq_uncons$raw
  ( xs ) =
( 
 @(x0, xs)) where
{
  val x0 = $UN.gseq_head$raw<xs><x0>(xs)
  val xs = $UN.gseq_tail$raw<xs><x0>(xs)
}(*where*)//end-of-[$UN.gseq_uncons$raw(xs)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
{ xs:t0 }
{ x0:t0 }
$UN.gasq_get$at$raw
  (xs, i0) =
let
pvx ((*0*)) =
(
  owed_t0_elim0(pf)) in x0 end
where
{
val (pf|x0) =
$UN.gasq_lget$at$raw<xs><x0>(xs, i0)
}(*where*)//end-of-[$UN.gasq_get$at$raw(...)]
//
#impltmp
{xs:t0}
{x0:t0}
$UN.gasq_lget$at$raw
  (xs, i0) =
(
  owed_t0_make() | x0) where
{ val x0 =
  $UN.gasq_get$at$raw<xs><x0>(xs, i0)
}(*where*)//end-of-[$UN.gasq_lget$at$raw(...)]
//
(* ****** ****** *)
//
#impltmp
{xs:t0}
{x0:t0}
$UN.gasq_set$at$raw
  (xs, i0, x0) =
let
pvx pf = owed_t0_make()
in//let
$UN.gasq_lset$at$raw<xs><x0>(pf|xs,i0,x0)
end(*let*)//end-of-[$UN.gasq_set$at$raw(...)]
//
#impltmp
{xs:t0}
{x0:t0}
$UN.gasq_lset$at$raw
  (pf | xs, i0, x0) =
let
pvx () = owed_t0_elim0(pf)
in//let
(
  $UN.gasq_set$at$raw<xs><x0>(xs, i0, x0))
end(*let*)//end-of-$UN.gasq_lset$at$raw(...)]
//
(* ****** ****** *)
//
#impltmp
{xs:t0}
{x0:vt}
$UN.gasq_cget$at$raw
  (xs, i0) =
let
//
val x1 = g_copy<x0>(x0)
//
pvx () =
(
owed_vt_return0(pf, x1)) in x0 end
where
{
val (pf | x0) =
(
  $UN.gasq_lget$at$raw<xs><x0>(xs, i0))
}(*where*)//end-of-[$UN.gasq_cget$at$raw(...)]
//
(* ****** ****** *)
//
(*
HX:
[gasq_setf]
is not efficient
as it involves two "trips"!
We can eliminate the inefficiency
by employing pointer arithmetic!!!
*)
#impltmp
{xs:t0}
{x0:vt}
$UN.gasq_setf$at$raw
  (xs, i0, x0) =
let
//
val (pf | x1) =
(
  $UN.gasq_lget$at$raw<xs><x0>(xs, i0))
//
in//let
//
let
val ((*void*)) = g_free<x0>(x1)
in//let
$UN.gasq_lset$at$raw<xs><x0>(pf|xs,i0,x0)
end//let
//
end(*let*)//end-of-[$UN.gasq_setf$at$raw(...)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
$UN.gseq_head$raw
<strn><cgtz>(*cs*) = $UN.strn_head$raw<>(*cs*)
//
#impltmp
<(*tmp*)>
$UN.strn_head$raw(cs) = $UN.strn_get$at$raw<>(cs,0)
//
(* ****** ****** *)
(* ****** ****** *)
//
#include
"./VT/unsfx00_vt.dats" // HX: no need for explicit inclusion
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_DATS_unsfx00_and_unsfx00_vt.dats] *)
(***********************************************************************)
`,
  "HATS/prelude_JS_cats.hats": `(* ****** ****** *)
(* ****** ****** *)
(*
HX-2025-04-19:
This is for loading
ATS3_XANADU/
prelude/DATS/CATS/JS
(*
Sat Apr 19 11:36:36 AM EDT 2025
*)
*)
(* ****** ****** *)
(* ****** ****** *)
//
#extcode file
"prelude/DATS/CATS/JS/xtop000.cats"
//
(* ****** ****** *)
//
#extcode file
"prelude/DATS/CATS/JS/gbas000.cats"
#extcode file
"prelude/DATS/CATS/JS/gdbg000.cats"
//
(* ****** ****** *)
(* ****** ****** *)
//
#extcode
file"prelude/DATS/CATS/JS/bool000.cats"
#extcode
file"prelude/DATS/CATS/JS/char000.cats"
#extcode
file"prelude/DATS/CATS/JS/gint000.cats"
#extcode
file"prelude/DATS/CATS/JS/gflt000.cats"
#extcode
file"prelude/DATS/CATS/JS/strn000.cats"
//
(* ****** ****** *)
(* ****** ****** *)
//
#extcode
file"prelude/DATS/CATS/JS/list000.cats"
#extcode
file"prelude/DATS/CATS/JS/optn000.cats"
//
#extcode
file"prelude/DATS/CATS/JS/strm000.cats"
#extcode
file"prelude/DATS/CATS/JS/strx000.cats"
//
(* ****** ****** *)
//
#extcode
file"prelude/DATS/CATS/JS/axrf000.cats"
#extcode
file"prelude/DATS/CATS/JS/axsz000.cats"
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3_XANADU_prelude_HATS_prelude_JS_cats.hats] *)
(***********************************************************************)
`,
  "HATS/prelude_JS_dats.hats": `(* ****** ****** *)
(* ****** ****** *)
(*
HX-2024-07-14:
This is for loading
ATS3_XANADU/
prelude/DATS/CATS/JS
(*
Sun 14 Jul 2024 12:14:49 PM EDT
*)
*)
(* ****** ****** *)
(* ****** ****** *)
//
#staload // XTOP
"prelude/DATS/CATS/JS/xtop000.dats"
//
(* ****** ****** *)
(* ****** ****** *)
//
#staload _ =
"prelude/DATS/CATS/JS/gbas000.dats"
#staload _ =
"prelude/DATS/CATS/JS/gdbg000.dats"
//
(* ****** ****** *)
(* ****** ****** *)
//
#staload _ =
"prelude/DATS/CATS/JS/bool000.dats"
#staload _ =
"prelude/DATS/CATS/JS/char000.dats"
#staload _ =
"prelude/DATS/CATS/JS/gint000.dats"
#staload _ =
"prelude/DATS/CATS/JS/gflt000.dats"
//
(* ****** ****** *)
(* ****** ****** *)
//
#staload _ =
"prelude/DATS/CATS/JS/strn000.dats"
//
(* ****** ****** *)
(* ****** ****** *)
//
#staload _ =
"prelude/DATS/CATS/JS/list000.dats"
#staload _ =
"prelude/DATS/CATS/JS/optn000.dats"
//
(* ****** ****** *)
//
#staload _ =
"prelude/DATS/CATS/JS/strm000.dats"
#staload _ =
"prelude/DATS/CATS/JS/strx000.dats"
//
(* ****** ****** *)
(* ****** ****** *)
//
#staload _ =
"prelude/DATS/CATS/JS/axrf000.dats"
#staload _ =
"prelude/DATS/CATS/JS/axsz000.dats"
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3_XANADU_prelude_HATS_prelude_JS_dats.hats] *)
(***********************************************************************)
`,
  "HATS/prelude_NODE_dats.hats": `(* ****** ****** *)
(* ****** ****** *)
(*
HX-2024-09-01:
This is for loading
ATS3_XANADU/
prelude/DATS/CATS/JS/NODE
(*
Sun 01 Sep 2024 08:14:07 AM EDT
*)
*)
(* ****** ****** *)
(* ****** ****** *)
//
#staload _ =
"prelude/DATS/CATS/JS/NODE/node000.dats"
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3_XANADU_prelude_prelude_NODE_dats.hats] *)
(***********************************************************************)
`,
  "HATS/prelude_PY_dats.hats": `(* ****** ****** *)
(* ****** ****** *)
(*
HX-2025-01-01:
This is for loading
ATS3_XANADU/
prelude/DATS/CATS/PY
(*
Wed Jan  1 03:18:54 PM EST 2025
*)
*)
(* ****** ****** *)
(* ****** ****** *)
//
#staload // XTOP
"prelude/DATS/CATS/PY/xtop000.dats"
//
(* ****** ****** *)
(* ****** ****** *)
//
#staload _ =
"prelude/DATS/CATS/PY/gbas000.dats"
#staload _ =
"prelude/DATS/CATS/PY/gdbg000.dats"
//
(* ****** ****** *)
(* ****** ****** *)
//
#staload _ =
"prelude/DATS/CATS/PY/bool000.dats"
#staload _ =
"prelude/DATS/CATS/PY/char000.dats"
#staload _ =
"prelude/DATS/CATS/PY/gint000.dats"
#staload _ =
"prelude/DATS/CATS/PY/gflt000.dats"
//
(* ****** ****** *)
(* ****** ****** *)
//
#staload _ =
"prelude/DATS/CATS/PY/strn000.dats"
//
(* ****** ****** *)
(* ****** ****** *)
//
#staload _ =
"prelude/DATS/CATS/PY/list000.dats"
#staload _ =
"prelude/DATS/CATS/PY/optn000.dats"
//
(* ****** ****** *)
//
#staload _ =
"prelude/DATS/CATS/PY/strm000.dats"
//
(* ****** ****** *)
(* ****** ****** *)
//
#staload _ =
"prelude/DATS/CATS/PY/axrf000.dats"
#staload _ =
"prelude/DATS/CATS/PY/axsz000.dats"
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3_XANADU_prelude_HATS_prelude_PY_dats.hats] *)
(***********************************************************************)
`,
  "HATS/prelude_dats.hats": `(* ****** ****** *)
(* ****** ****** *)
(*
HX-2024-07-14:
This is for loading
ATS3_XANADU_prelude/DATS
(*
Sun 14 Jul 2024 12:14:49 PM EDT
*)
*)
(* ****** ****** *)
(* ****** ****** *)
// prelude/DATS
(* ****** ****** *)
(* ****** ****** *)
//
#staload
_(*BAS*) =
"prelude/DATS/gbas000.dats"
#staload
_(*BAS*) =
"prelude/DATS/gbas001.dats"
#staload
_(*BAS*) =
"prelude/DATS/gbas002.dats"
//
(* ****** ****** *)
//
#staload
_(*DBG*) =
"prelude/DATS/gdbg000.dats"
//
(* ****** ****** *)
//
#staload
_(*BAS*) =
"prelude/DATS/VT/gbas000_vt.dats"
#staload
_(*BAS*) =
"prelude/DATS/VT/gbas001_vt.dats"
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-03:
Sat 03 Aug 2024 05:44:33 PM EDT
The code in this files serves as
"switches" during template resolution!
*)
#staload _ = "prelude/DATS/gxyz000.dats"
//
(* ****** ****** *)
(* ****** ****** *)
//
#staload _ = "prelude/DATS/unsfx00.dats"
(*
This one is included by [DATS/unsfx00.dats]
#staload _ = "prelude/DATS/VT/unsfx00_vt.dats"
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#staload _ = "prelude/DATS/gnum000.dats"
#staload _ = "prelude/DATS/gord000.dats"
#staload _ = "prelude/DATS/gfun000.dats"
//
#staload _ = "prelude/DATS/gseq000.dats"
#staload _ = "prelude/DATS/gseq001.dats"
#staload _ = "prelude/DATS/gseq002.dats"
//
#staload _ = "prelude/DATS/gasq000.dats"
#staload _ = "prelude/DATS/gasq001.dats"
#staload _ = "prelude/DATS/gasq002.dats"
//
#staload _ = "prelude/DATS/gmap000.dats"
#staload _ = "prelude/DATS/gmap001.dats"
//
#staload _ = "prelude/DATS/gcls000.dats"
#staload _ = "prelude/DATS/gsyn000.dats"
#staload _ = "prelude/DATS/gsyn001.dats"
//
(* ****** ****** *)
//
#staload _ = "prelude/DATS/bool000.dats"
#staload _ = "prelude/DATS/char000.dats"
#staload _ = "prelude/DATS/gint000.dats"
#staload _ = "prelude/DATS/gint001.dats"
#staload _ = "prelude/DATS/gflt000.dats"
//
(* ****** ****** *)
//
#staload _ = "prelude/DATS/strn000.dats"
#staload _ = "prelude/DATS/strn001.dats"
//
(* ****** ****** *)
//
#staload _ = "prelude/DATS/axrf000.dats"
#staload _ = "prelude/DATS/axrf001.dats"
#staload _ = "prelude/DATS/axsz000.dats"
#staload _ = "prelude/DATS/axsz001.dats"
#staload _ = "prelude/DATS/asrt000.dats"
#staload _ = "prelude/DATS/tupl000.dats"
#staload _ = "prelude/DATS/tupl001.dats"
#staload _ = "prelude/DATS/tupl002.dats"
#staload _ = "prelude/DATS/list000.dats"
#staload _ = "prelude/DATS/list001.dats"
#staload _ = "prelude/DATS/list002.dats"
#staload _ = "prelude/DATS/lsrt000.dats"
#staload _ = "prelude/DATS/optn000.dats"
#staload _ = "prelude/DATS/optn001.dats"
#staload _ = "prelude/DATS/strm000.dats"
#staload _ = "prelude/DATS/strm001.dats"
#staload _ = "prelude/DATS/strx000.dats"
#staload _ = "prelude/DATS/strx001.dats"
//
(* ****** ****** *)
(* ****** ****** *)
//
#staload _ = "prelude/DATS/CATS/gbas000.dats"
//
#staload _ = "prelude/DATS/CATS/bool000.dats"
#staload _ = "prelude/DATS/CATS/char000.dats"
//
#staload _ = "prelude/DATS/CATS/gint000.dats"
#staload _ = "prelude/DATS/CATS/gflt000.dats"
//
#staload _ = "prelude/DATS/CATS/strn000.dats"
//
#staload _ = "prelude/DATS/CATS/axrf000.dats"
#staload _ = "prelude/DATS/CATS/axsz000.dats"
//
(* ****** ****** *)
(* ****** ****** *)
#staload _ = "prelude/DATS/VT/gnum000_vt.dats"
#staload _ = "prelude/DATS/VT/gord000_vt.dats"
#staload _ = "prelude/DATS/VT/gfun000_vt.dats"
#staload _ = "prelude/DATS/VT/gcls000_vt.dats"
#staload _ = "prelude/DATS/VT/gseq000_vt.dats"
#staload _ = "prelude/DATS/VT/gseq001_vt.dats"
#staload _ = "prelude/DATS/VT/gseq002_vt.dats"
#staload _ = "prelude/DATS/VT/gasq000_vt.dats"
#staload _ = "prelude/DATS/VT/gasq001_vt.dats"
#staload _ = "prelude/DATS/VT/gsyn000_vt.dats"
(* ****** ****** *)
#staload _ = "prelude/DATS/VT/strn000_vt.dats"
(* ****** ****** *)
//
#staload _ = "prelude/DATS/VT/axrf000_vt.dats"
#staload _ = "prelude/DATS/VT/axsz000_vt.dats"
#staload _ = "prelude/DATS/VT/tupl000_vt.dats"
//
#staload _ = "prelude/DATS/VT/list000_vt.dats"
#staload _ = "prelude/DATS/VT/list001_vt.dats"
#staload _ = "prelude/DATS/VT/lsrt000_vt.dats"
#staload _ = "prelude/DATS/VT/optn000_vt.dats"
#staload _ = "prelude/DATS/VT/optn001_vt.dats"
//
#staload _ = "prelude/DATS/VT/strm000_vt.dats"
#staload _ = "prelude/DATS/VT/strm001_vt.dats"
#staload _ = "prelude/DATS/VT/strm002_vt.dats"
#staload _ = "prelude/DATS/VT/strx000_vt.dats"
#staload _ = "prelude/DATS/VT/strx001_vt.dats"
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-04:
Sun 04 Aug 2024 10:37:22 PM EDT
The code in this file serves as
"switches" during template resolution!
*)
#staload _ = "prelude/DATS/VT/gxyz000_vt.dats"
//
(* ****** ****** *)(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3_XANADU_prelude_prelude_dats.hats] *)
(***********************************************************************)
`,
  "HATS/prelude_py_cats.hats": `(* ****** ****** *)
(* ****** ****** *)
(*
HX-2025-04-19:
This is for loading
ATS3_XANADU/
prelude/DATS/CATS/PY
(*
Sat Apr 19 11:36:36 AM EDT 2025
*)
*)
(* ****** ****** *)
(* ****** ****** *)
//
#extcode file
"prelude/DATS/CATS/PY/xtop000.cats"
//
(* ****** ****** *)
//
#extcode file
"prelude/DATS/CATS/PY/gbas000.cats"
#extcode file
"prelude/DATS/CATS/PY/gdbg000.cats"
//
(* ****** ****** *)
(* ****** ****** *)
//
#extcode
file"prelude/DATS/CATS/PY/bool000.cats"
#extcode
file"prelude/DATS/CATS/PY/char000.cats"
#extcode
file"prelude/DATS/CATS/PY/gint000.cats"
#extcode
file"prelude/DATS/CATS/PY/gflt000.cats"
#extcode
file"prelude/DATS/CATS/PY/strn000.cats"
//
(* ****** ****** *)
(* ****** ****** *)
//
#extcode
file"prelude/DATS/CATS/PY/axrf000.cats"
#extcode
file"prelude/DATS/CATS/PY/axsz000.cats"
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3_XANADU_prelude_HATS_prelude_PY_cats.hats] *)
(***********************************************************************)
`,
  "INIT/prelude_sats.hats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2023 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
#include "prelude/SATS/gbas000.sats"
#include "prelude/SATS/gbas001.sats"
#include "prelude/SATS/gbas002.sats"
//
(* ****** ****** *)
//
#include "prelude/SATS/gdbg000.sats"
//
#include "prelude/SATS/gnum000.sats"
//
#include "prelude/SATS/gord000.sats"
//
#include "prelude/SATS/gcls000.sats"
//
#include "prelude/SATS/gfun000.sats"
//
(* ****** ****** *)
//
#include "prelude/SATS/gseq000.sats"
#include "prelude/SATS/gseq001.sats"
#include "prelude/SATS/gseq002.sats"
//
#include "prelude/SATS/gasq000.sats"
#include "prelude/SATS/gasq001.sats"
#include "prelude/SATS/gasq002.sats"
//
#include "prelude/SATS/gmap000.sats"
#include "prelude/SATS/gmap001.sats"
//
#include "prelude/SATS/gamp000.sats"
#include "prelude/SATS/gamp001.sats"
//
(* ****** ****** *)
//
#include "prelude/SATS/gsyn000.sats"
#include "prelude/SATS/gsyn001.sats"
//
(* ****** ****** *)
(* ****** ****** *)
//
#include "prelude/SATS/bool000.sats"
//
#include "prelude/SATS/char000.sats"
//
#include "prelude/SATS/gint000.sats"
#include "prelude/SATS/gint001.sats"
//
#include "prelude/SATS/gflt000.sats"
//
#include "prelude/SATS/strn000.sats"
#include "prelude/SATS/strn001.sats"
//
(* ****** ****** *)
//
#include "prelude/SATS/axrf000.sats"
#include "prelude/SATS/axrf001.sats"
//
#include "prelude/SATS/axsz000.sats"
#include "prelude/SATS/axsz001.sats"
//
#include "prelude/SATS/asrt000.sats"
//
(* ****** ****** *)
//
#include "prelude/SATS/tupl000.sats"
//
#include "prelude/SATS/list000.sats"
#include "prelude/SATS/list001.sats"
#include "prelude/SATS/list002.sats"
//
#include "prelude/SATS/lsrt000.sats"
//
#include "prelude/SATS/optn000.sats"
#include "prelude/SATS/optn001.sats"
//
#include "prelude/SATS/strm000.sats"
#include "prelude/SATS/strm001.sats"
#include "prelude/SATS/strx000.sats"
#include "prelude/SATS/strx001.sats"
//
(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)
//
(*
HX: for viewtypes (that is, linear types)
*)
//
#include "prelude/SATS/VT/gbas000_vt.sats"
#include "prelude/SATS/VT/gbas001_vt.sats"
#include "prelude/SATS/VT/gbas002_vt.sats"
//
#include "prelude/SATS/VT/gnum000_vt.sats"
//
#include "prelude/SATS/VT/gord000_vt.sats"
//
#include "prelude/SATS/VT/gfun000_vt.sats"
//
#include "prelude/SATS/VT/gcls000_vt.sats"
//
#include "prelude/SATS/VT/gseq000_vt.sats"
#include "prelude/SATS/VT/gseq001_vt.sats"
#include "prelude/SATS/VT/gseq002_vt.sats"
//
#include "prelude/SATS/VT/gasq000_vt.sats"
#include "prelude/SATS/VT/gasq001_vt.sats"
#include "prelude/SATS/VT/gasq002_vt.sats"
//
#include "prelude/SATS/VT/gsyn000_vt.sats"
#include "prelude/SATS/VT/gsyn001_vt.sats"
//
#include "prelude/SATS/VT/strn000_vt.sats"
#include "prelude/SATS/VT/strn001_vt.sats"
//
#include "prelude/SATS/VT/axrf000_vt.sats"
#include "prelude/SATS/VT/axsz000_vt.sats"
//
#include "prelude/SATS/VT/list000_vt.sats"
#include "prelude/SATS/VT/list001_vt.sats"
//
#include "prelude/SATS/VT/lsrt000_vt.sats"
//
#include "prelude/SATS/VT/optn000_vt.sats"
#include "prelude/SATS/VT/optn001_vt.sats"
//
#include "prelude/SATS/VT/strm000_vt.sats"
#include "prelude/SATS/VT/strm001_vt.sats"
#include "prelude/SATS/VT/strm002_vt.sats"
//
#include "prelude/SATS/VT/strx000_vt.sats"
#include "prelude/SATS/VT/strx001_vt.sats"
//
#include "prelude/SATS/VT/tupl000_vt.sats"
//
(* ********* ********* *)(* ********* ********* *)
(* ********* ********* *)(* ********* ********* *)

(* end of [ATS3/XANADU_prelude_INIT_prelude_sats.hats] *)
`,
  "INIT/srcgen2_excptn0.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2018 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
//
// This one should be loaded after xsetup.sats
//
(* ****** ****** *)
//
(*
HX-2024-01-11:
For general errors
Thu Jan 11 20:32:29 EST 2024
*)
excptcon
ErrorExn of ((*void*))
excptcon
ErrmsgExn of ( string )
//
(* ****** ****** *)
//
(*
HX-2020-03-05:
Out-of-range subscripting
*)
//
excptcon
SubemptyExn of ((*void*))
excptcon
SubscriptExn of ((*void*))
//
(* ****** ****** *)
//
(*
HX-2024-07-15:
Generally undefined value
*)
//
excptcon
UndefinedExn of ((*void*))
//
(* ****** ****** *)
//
// For indicating the failure of
excptcon AssertExn of () // an assertion
// For indicating something expected
excptcon NotFoundExn of () // to be found but not
//
(* ****** ****** *)
(* ****** ****** *)
//
(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)

(* end of [ATS3/XANADU_prelude_INIT_srcgen2_excptn0.sats] *)
`,
  "INIT/srcgen2_xsetup0.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2019 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// HX-2019-09-09:
// These can be re-defined
//
(* ****** ****** *)

#typedef
the_s2exp_void = void

(* ****** ****** *)
//
#typedef
the_s2exp_p1tr0 = p1tr0
//
#typedef
the_s2exp_p2tr0(x:vt) = p2tr0(x)
#viewdef
the_s2exp_p2at0(x:vt) = p2at0(x)
//
(* ****** ****** *)
//
// single precision
#typedef
the_s2exp_sflt0 = sflt
// double precision
#typedef
the_s2exp_dflt0 = dflt
//
// ldouble precision
#typedef
the_s2exp_ldflt = ldflt
//
(* ****** ****** *)
//
#typedef
the_s2exp_sint0 = sint0
#typedef
the_s2exp_uint0 = uint0
#typedef
the_s2exp_bool0 = bool0
#typedef
the_s2exp_char0 = char0
#typedef
the_s2exp_strn0 = strn0
//
(* ****** ****** *)
//
#typedef
the_s2exp_slint0 = slint0
#typedef
the_s2exp_ulint0 = ulint0
//
#typedef
the_s2exp_sllint0 = sllint0
#typedef
the_s2exp_ullint0 = ullint0
//
(* ****** ****** *)
//
#typedef
the_s2exp_lazy0(a:t0) = lazy(a)
#vwtpdef
the_s2exp_llazy0(a:vt) = lazy_vt(a)
//
(* ****** ****** *)
//
#typedef
the_s2exp_list0(a:t0) = list(a)
#vwtpdef
the_s2exp_llist0(a:vt) = list_vt(a)
//
(* ****** ****** *)
//
#typedef
the_s2exp_optn0(a:t0) = optn(a)
#vwtpdef
the_s2exp_loptn0(a:vt) = optn_vt(a)
//
(* ****** ****** *)
//
(*
#vwtpdef
the_s2exp_excptn(*void*) = excptn_vt
*)
//
(* ****** ****** *)
//
#viewdef // @
the_s2exp_a0ptr(*void*) = a0ptr_view
#viewdef // arrvw
the_s2exp_a1ptr(*void*) = a1ptr_view
//
(* ****** ****** *)
//
#typedef the_s2exp_sint1(i:i0) = sint1(i)
#typedef the_s2exp_uint1(i:i0) = uint1(i)
#typedef the_s2exp_bool1(b:b0) = bool1(b)
#typedef the_s2exp_char1(c:c0) = char1(c)
#typedef the_s2exp_strn1(n:i0) = strn1(n)
//
(* ****** ****** *)
(* ****** ****** *)
//
(* ****** ****** *)(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)(* ****** ****** *)

(* end of [ATS3/XANADU_prelude_INIT_srcgen2_xsetup0.sats] *)
`,
  "README.00": `############################################################
HX-2024-07-13:
############################################################
The prelude library for ATS3/Xanadu is
a concrete example that clearly demonstrates
the power of template-based programming.
############################################################
Here are some notes for helping understand the
design and implementation of this library.
############################################################
Rough split:
gbas000: basic
gbas001: strmize,
         forall, foldall,
         map, filter, etc
gbas001: r-variants and i-variants
gbas002: z2-variants and x2-variants
############################################################
This may look kind of cryptic :)
For geq-functions, we have the following (partial) ordering:
strmize < forall0
forall0 < foritm0
forall0 < iforall0
foritm0 < iforitm0
forall0 < foldall0
foritm0 < folditm0
rlistize < rforall0
folditm0 < map0
folditm0 < filter0
foldall0 < ifoldall0
folditm0 < ifolditm0
(strmize, strmize) < z2forall
############################################################
`,
  "README.md": `# The ATS3-prelude library

[comment]: # HX-2025-05-15: Let's start documenting!

What is presented here should be seen as a set of comments aiming at
helping someone understand the design and implementation of the
prelude library for ATS3. These comments are made selectively and are
not meant to be thorough.

## Special Files

### fixity0.sats

ATS3 supports prefix, infix and postfix operators.
The file \`fixity0.sats\` contains fixity declarations for
various commonly used symbols.

For instance, the following lines declare the 5 common arithmetic
operators as being left-associative; addition (+) and substraction (-)
are given the precedence value 50 while the other three are given the
precedence value 60. In general, these precedence values should not be
altered for otherwise a great deal of confusion is likely to be
introduced.

\`\`\`
#infixl + of 50 (*add*)
#infixl - of 50 (*sub*)
#infixl * of 60 (*mul*)
#infixl / of 60 (*div*)
#infixl % of 60 (*mod*)
\`\`\`

Note that \`infixl\` and \`infixr\` are for left-associativity and
right-associativity respectively. And \`infix0\` (which can also
be written as \`infix\`) is for non-associative infix operators.

In a case like \`1+2-3\`, the expression is parsed as \`(1+2)-3\` instead
of \`1+(2-3)\` due to the fact that addition and subtraction are given
the same precedence value while they are left-associative.

In a case like \`1+2*3\`, the expression is parsed as \`1+(2*3)\` instead
of \`(1+2)*3\` due to multiplication being given a higher precedence
value than addition.

In ATS3, a symbol can be given an infix status as well as a prefix
status. For instance, we have the following declarations:

\`\`\`
#prefix + of +(+1) (*uplus*)
#prefix - of -(+1) (*uminus*)
\`\`\`

As a prefix operator, the precedence value of \`+\` (resp. \`-\`) is 1 higher
than the precedence value of \`+\` (resp. \`-\`) as an infix operator.

### basics0.sats

The file \`basics0.sats\` contains the declarations of various
basic constants in ATS3.

For instance, the following lines introduce some aliases for
the 4 basic predicative sorts \`int0\`, \`bool\`, \`addr\`, and \`char\`
in ATS3:

\`\`\`
#sortdef i0 = int0 // integers // (-inf, +inf)
#sortdef a0 = addr // addresses // 0 <= a < +inf
#sortdef b0 = bool // booleans  // true | false
#sortdef c0 = char // characters // 0 <= c < 256
\`\`\`

And the following lines introduce some aliases for the 6 basic
impredicative sorts \`prop\`, \`view\`, \`type\`, \`tbox\`, \`vwtp\`, and \`vtbx\`
in ATS3:

\`\`\`
#sortdef p0 = prop // proof
#sortdef t0 = type // dynexp
#sortdef tx = tbox // boxed dynexp
#sortdef v0 = view // linear proof
#sortdef vw = view // linear proof
#sortdef vt = vwtp // linear dynexp
#sortdef vx = vtbx // linear boxed dynexp
\`\`\`

There are also some subset sorts:

\`\`\`
#sortdef nat = {n: i0 | n >= 0}
#sortdef pos = {n: i0 | n >= 1}
#sortdef neg = {n: i0 | n <= -1}
\`\`\`

After sort definitions, there are various declared static constants in
\`basics0.sats\`.  For instance, the following lines introduce
some static constants for the two boolean values \`true\` and \`false\` and also
the disjunction (\`add_b0_b0\`) and the conjunction (\`mul_b0_b0\`):

\`\`\`
#stacst0 tt_b0 : b0 // true
#stacst0 ff_b0 : b0 // false
#stacst0 add_b0_b0: (b0, b0)->b0
#stacst0 mul_b0_b0: (b0, b0)->b0

\`\`\`

Furthermore, some aliases are introduced as follows:

\`\`\`
#sexpdef tt = tt_b0 // overloading
#sexpdef ff = ff_b0 // overloading
#sexpdef + = add_b0_b0 // overloading
#sexpdef * = mul_b0_b0 // overloading
#sexpdef || = add_b0_b0 // overloading
#sexpdef && = mul_b0_b0 // overloading
\`\`\`

For instance, we can write \`true+false\` or \`true||false\` for
\`add_b0_b0(true, false)\`, \`true*false\` or \`true&&false\` for
\`mul_b0_b0(true, false)\`, etc. Please note that the fixity
declarations for \`+\`, \`*\`, \`||\`, and \`&&\` are given in \`fixity0.sats\`.


### xparam0.hats

This file is largely empty as of now.  It is supposed to contain
various system-related constants.  For instance, the the forward slash
symbol is used in UNIX-like systems for separating components in a
file path; and the backward slash symbol is used for this purpose in
Windows.

## Handling of Partial Functions

Handling of partial functions is an issue of crucial importance in
programming. The convention followed in the prelude library for
handling partial functions can be illustrated through a simple
example.  For instance, \`gseq_head\`, which returns the head (that is,
the first elememnt) of a given sequence is given the following
interface:

\`\`\`
fun
<xs:t0>
<x0:t0>
gseq_head(xs: xs): x0
\`\`\`

Clearly, \`gseq_head\` is a partial function as the head of an empty
sequence is undefined. When applied to an empty sequence, the behavior
of \`gseq_head\` is unspecified; it may return some value or it may raise
an exception.

The following declared function \`gseq_head$exn\` is a variant of
\`gseq_head\`:

\`\`\`
fun
<xs:t0>
<x0:t0>
gseq_head$exn(xs: xs): x0
\`\`\`

which, when applied to an empty sequence, should raise an exception to
indicate that the head of an empty sequence is undefined.

The following declared function \`gseq_head$opt\` is another variant of
\`gseq_head\`:

\`\`\`
fun
<xs:t0>
<x0:t0>
gseq_head$opt(xs: xs): optn_vt(x0)
\`\`\`

which returns a (linear) option value to indicate whether the head of
a given sequence is well-defined.

There is yet another variant of \`gseq_head\`, which is declared as follows:

\`\`\`
fun
<xs:t0>
<x0:t0>
gseq_head$raw(xs): x0
\`\`\`

Like \`gseq_head\`, the behavior of \`gseq_head$raw\` on an empty sequence
is unspecified. However, unlike the function \`gseq_head\`,
\`gseq_head$raw\` may even behave unsafely when applied to an empty
sequence. For instance, \`gseq_head$raw\` may do something like
out-of-bounds array access, which can be taken advantage of by a
malicious program. Therefore, when applying \`gseq_head$raw\` to a
sequence, one must possess, formally or informally, a proof of some
kind that attests to the non-emptiness of the sequence.

## Naming Convention for Combinators

Let us take \`map\` as an example to illustrate some conventional rules
employed for naming various combinators in the prelude library of
ATS3.  In general, \`map\` means to apply some function \`fopr\` to each
value in a collection to form another collection of values (where each
value is a result of \`fopr\`). For instance, a sequence of values of
type \`X\` can be "mapped" to another sequence of values of type \`Y\`,
where each value of type \`X\` is mapped to a value of type \`Y\`. The
\`fopr\` function for \`map\` is declared as follows in
\`prelude/SATS/gbas001.sats\`:

\`\`\`
fun
<x0:t0>
<y0:vt>
map$fopr(itm: x0): (y0)
\`\`\`

We use \`gseq_map\` for an operation that traverses a given sequence and
applies \`map$fopr\` to the value of each encountered item; the sequence
traversal performed by \`gseq_map\` is referred to as the default or
standard traversal of the sequence.

The output sequence of performing \`gseq_map\` on an input sequence may be
represented differently from the input sequence. For instance, the
input sequence can be an array-based string (representing a sequence
of characters) while the output sequence can be a linked list of some
kind. The most generic sequence-based \`map\` is declared as follows:

\`\`\`
fun
<xs:t0>
<x0:t0>
<ys:vt>
<y0:vt>
gseq_map_ares(xs: xs): (ys)
\`\`\`

where the (suffix) word \`ares\` indicates that the return value of
\`gseq_map_ares\` is the most generic (that is, threre is practically no
information revealed on the representation of the return value).

There are many variants of \`gseq_map_ares\`. For instance, the
following variant indicates that the return value is represented as
a linear list (given the type \`list_vt\`):

\`\`\`
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_map_llist(xs: xs): list_vt(y0)
\`\`\`

### Reversed Traversal

There is a default or standard traversal associated with a given
sequence, and we refer to this traversal as the left-to-right
traversal of sequence. Then there is also the right-to-left traversal
(completely opposite to the left-to-right traversal), which we refer
to as the reversed traversal. We use the verb \`r-traverse\` to mean
performing a reversed traversal.

When r-traversing a sequence of items, \`gseq_rmap\` employs the
following function to process each encountered item:

\`\`\`
fun
<x0:t0>
<y0:vt>
rmap$fopr(itm: x0): (y0)
\`\`\`

The most generic sequence-based \`rmap\` is declared as follows:

\`\`\`
fun
<xs:t0>
<x0:t0>
<ys:vt>
<y0:vt>
gseq_rmap_ares(xs: xs): (ys)
\`\`\`

The naming convention we follow changes \`map\` into \`rmap\` to indicate
that the (standard) sequence traversal (for \`map\`) is replaced with
the reversed sequence traversal (for \`rmap\`).

### Indexed Traversal

When traversing a sequence of items, \`gseq_imap\` employs the following
function to process each encountered item:

\`\`\`
fun
<x0:t0>
<y0:vt>
imap$fopr(pos: ni, itm: x0): (y0)
\`\`\`

Note that the first argument of \`imap$fopr\` is a natural number of
the type \`ni\` (a shorthand for \`nint\`) that indicates the position
of the encountered item in the given sequence while the second
argument is the value of the item.  The most generic sequence-based
\`imap\` is declared as follows:

\`\`\`
fun
<xs:t0>
<x0:t0>
<ys:vt>
<y0:vt>
gseq_imap_ares(xs: xs): (ys)
\`\`\`

The naming convention we follow changes \`map\` into \`imap\` to indicate
that the (standard) sequence traversal (for \`map\`) is replaced with
the indexed sequence traversal (for \`imap\`) that records the position
of each encountered item.

### Z-Combined Traversal

The letter \`z\` in \`z-combined\` stands for \`zip\`.

What \`gseq_z2map\` does is essentially to perform \`gseq_map\` on the
sequence obtained from zipping two given sequences. It should be easy
to extrapolate what \`gseq_z3map\` does and beyond. The fopr-function employed
by \`gseq_z2map\` is given as follows:

\`\`\`
fun
<x0:t0>
<y0:t0>
<z0:vt>
z2map$fopr(x0: x0, y0: y0): (z0)
\`\`\`

The most generic sequence-based \`z2map\` is declared as follows:


\`\`\`
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
<zs:vt>
<z0:vt>
gseq_z2map_ares(xs: xs, ys: ys): (zs)
\`\`\`

The naming convention we follow changes \`map\` into \`z2map\` to indicate
the traversal of a seqeunce obtained from zipping two given sequences.
And the interpretation for \`z3map\` (and beyond) extrapolates naturally.

### X-Combined Traversal

The letter \`x\` in \`x-combined\` stands for \`cross\`.

Given two sequences \`[1, 2, 3]\` and \`["a", "b"]\`, their cross product
is the following sequence of pairs:

\`\`\`
[(1, "a"), (1, "b"), (2, "a"), (2, "b"), (3, "a"), (3, "b")]
\`\`\`

It is straightforward to defined the cross product of two sequences.
What \`gseq_x2map\` does is essentially to perform \`gseq_map\` on the
sequence obtained from the cross product of two given sequences. It
should be easy to extrapolate what \`gseq_x3map\` does and beyond. The
fopr-function employed by \`gseq_x2map\` is given as follows:

\`\`\`
fun
<x0:t0>
<y0:t0>
<z0:vt>
x2map$fopr(x0: x0, y0: y0): (x0)
\`\`\`

The most generic sequence-based \`x2map\` is declared as follows:


\`\`\`
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
<zs:vt>
<z0:vt>
gseq_x2map_ares(xs: xs, ys: ys): (zs)
\`\`\`

The naming convention we follow changes \`map\` into \`x2map\` to
indicate the traversal of a seqeunce obtained from the cross product
of two given sequences.  And the interpretation for \`x3map\` (and
beyond) extrapolates naturally.

### IX-Combined Traversal

The prefix \`ix\` in \`ix-combined\` stands for \`i-cross\`.

Given a sequence \`["a", "b", "c"]\`, its indexed version is
the following sequence of pairs:

\`\`\`
[(0, "a"), (1, "b"), (2, "c")]
\`\`\`

where each pair consists of an integer and a value such that the
integer refers to the position of the value in the original sequence.

It is straightforward to define the indexed version of a given
sequence.

The indexed cross (i-cross) product of two given sequences consists of
quadruples of the form \`(i, x, j, y)\`, where \`i\` and \`j\` are integers
referring, respectively, to the positions of \`x\` and \`y\` in the first
and second of the given sequences. For instance, the corresponding
\`fopr\` for \`ix2map\` (which does mapping via i-crossing) is given as
follows:

\`\`\`
fun
<x0:t0>
<y0:t0>
<z0:vt>
ix2map$fopr(px: ni, x0: x0, py: ni, y0: y0): (z0)
\`\`\`

### Many Styles of Traversal Combination

There are unlimited number of ways to combine traversals.

We can combine indexed traversal with reversed traversal to form
index-reversed traversal.  What \`gseq_irmap\` does is essentially to
perform mapping via an indexed-traversal over the reverse of a given
sequence. In other words, it does \`gseq_imap\` on the reverse of a
given sequence.

We can also combine reversed traversal with indexed traversal to form
reverse-indexed traversal.  What \`gseq_rimap\` does is essentially to
perform \`gseq_rmap\` on the sequence obtained from indexing a given
sequence. However, \`gseq_rimap\` is of little practical use as it can
be readily replaced with \`gseq_irmap\`.

From this point on, one should be clear about the meaning of
combinators like \`gseq_z2imap\`, \`gseq_x2imap\`, \`gseq_ix2rmap\`, etc.
For instance, given \`[0, 1]\` and \`["a", "b"]\`, \`gseq_ix2rmap\`
should process the following four quadruples from left to right:

\`\`\`
(1, 1, 1, "b"), (1, 1, 0, "a"), (0, 0, 1, "b"), (0, 0, 0, "a")
\`\`\`

<!--
##############################(README.md)##############################
-->
`,
  "SATS/.keeper": ``,
  "SATS/VT/.keeper": ``,
  "SATS/VT/axrf000_vt.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Sun 11 Aug 2024 01:10:04 PM EDT
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:vt>
a0rf_vt_free(A: ~a0rf_vt(a)): void
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:vt>
a0rf_vt_make_1val(x: a): a0rf_vt(a)
//
#symload
ref_vt with a0rf_vt_make_1val of 1000
#symload
a0rf_vt with a0rf_vt_make_1val of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:t0>
a0rf_vt_get(A: !a0rf_vt(a)): (a)
fun
<a:t0>
a0rf_vt_set(A: !a0rf_vt(a), x:a): void
//
#symload [] with a0rf_vt_set of 1000
#symload [] with a0rf_vt_get of 1000
#symload get with a0rf_vt_get of 1000
#symload set with a0rf_vt_set of 1000
//
(* ****** ****** *)
//
fun
<a:vt>
a0rf_vt_cget(A: !a0rf_vt(a)): (a)
fun
<a:vt>
a0rf_vt_setf(A: !a0rf_vt(a), x:a): void
//
#symload cget with a0rf_vt_cget of 1000
#symload setf with a0rf_vt_setf of 1000
//
(* ****** ****** *)
//
fun
<a:vt>
a0rf_vt_lget
( A:
! a0rf_vt( a) >> a0rf_vt(?a)): (a)
fun
<a:vt>
a0rf_vt_lset
( A:
! a0rf_vt(?a) >> a0rf_vt( a), x:a): void
//
#symload lget with a0rf_vt_lget of 1000
#symload lset with a0rf_vt_lset of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_VT_axrf000_vt.sats] *)
(***********************************************************************)
`,
  "SATS/VT/axsz000_vt.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Sun 11 Aug 2024 07:19:56 PM EDT
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:t0>
a1sz_vt_get$at1
{n:i0}
(!a1sz_vt(a, n), nint(n)): ( a )
fun
<a:t0>
a1sz_vt_set$at1
{n:i0}
(!a1sz_vt(a, n), nint(n), a): void
//
#symload
[] with a1sz_vt_get$at1 of 1000
#symload
[] with a1sz_vt_set$at1 of 1000
#symload
get$at1 with a1sz_vt_get$at1 of 1000
#symload
set$at1 with a1sz_vt_set$at1 of 1000
//
(* ****** ****** *)
//
fun
<a:vt>
a1sz_vt_cget$at1
{n:i0}
(!a1sz_vt(a,n), nintlt(n)): (a)
fun
<a:vt>
a1sz_vt_setf$at1
{n:i0}
(!a1sz_vt(a,n), nintlt(n), a): void
//
#symload
cget$at1 with a1sz_vt_cget$at1 of 1000
#symload
setf$at1 with a1sz_vt_setf$at1 of 1000
//
(* ****** ****** *)
//
fun
<a:vt>
a1sz_vt_lget$at1
{n:i0}
( A:
! a1sz_vt(a,n)
, i: nintlt(n)): (owed(a) | a)
fun
<a:vt>
a1sz_vt_lset$at1
{n:i0}
( f: owed(a)
| A:
! a1sz_vt(a,n), nintlt(n), a): void
//
#symload
lget$at1 with a1sz_vt_lget$at1 of 1000
#symload
lset$at1 with a1sz_vt_lset$at1 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fcast // fun
GLSEQ_make_a1sz_vt
{a:vt}
(A:a1sz_vt(a)): GLSEQ(a1sz_vt(a), a)
#symload GLSEQ with GLSEQ_make_a1sz_vt of 1000
fcast // fun
GLASQ_make_a1sz_vt
{a:vt}
(A:a1sz_vt(a)): GLASQ(a1sz_vt(a), a)
#symload GLASQ with GLASQ_make_a1sz_vt of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_VT_axsz000_vt.sats] *)
(***********************************************************************)
`,
  "SATS/VT/gasq000_vt.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon 22 Jul 2024 12:14:37 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#typedef ni = nint
(* ****** ****** *)
(* ****** ****** *)
#typedef ni = nint
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gasq_length1(xs: !xs): nint
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:t0> // HX: t0(not(vt))
gasq_get$at1
(xs: !xs, i0: ni): (x0)
fun
<xs:vt>
<x0:t0> // HX: t0(not(vt))
gasq_set$at1
(xs: !xs, i0: ni, x0: x0): void
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_VT_gasq000_vt.sats] *)
(***********************************************************************)
`,
  "SATS/VT/gasq001_vt.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon 22 Jul 2024 12:14:37 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#typedef ni = nint
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gasq_listize0
(xs: ~xs): list_vt(x0)//fun
//
fun
<xs:vt>
<x0:vt>
gasq_strmize0
(xs: ~xs): strm_vt(x0)//fun
fun
<xs:vt>
<x0:vt>
gasq_strqize0
(xs: ~xs): strq_vt(x0)//fun
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gasq_rlistize0
(xs: ~xs): list_vt(x0)//fun
//
fun
<xs:vt>
<x0:vt>
gasq_rstrmize0
(xs: ~xs): strm_vt(x0)//fun
fun
<xs:vt>
<x0:vt>
gasq_rstrqize0
(xs: ~xs): strq_vt(x0)//fun
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gasq_forall0(xs: ~xs): bool
fun
<xs:vt>
<x0:vt>
gasq_forall1(xs: !xs): bool
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gasq_rforall0(xs: ~xs): bool
fun
<xs:vt>
<x0:vt>
gasq_rforall1(xs: !xs): bool
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gasq_iforall0(xs: ~xs): bool
fun
<xs:vt>
<x0:vt>
gasq_iforall1(xs: !xs): bool
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gasq_irforall0(xs: ~xs): bool
fun
<xs:vt>
<x0:vt>
gasq_irforall1(xs: !xs): bool
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_VT_gasq001_vt.sats] *)
(***********************************************************************)
`,
  "SATS/VT/gbas000_vt.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Wed 10 Jul 2024 08:24:22 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
fun
<a:vt>
g_free0( ~a ): void
fun
<a:vt>
g_free1( !a ): void
*)
(*
fun
<a:vt>
g_copy0( ~a ): ( a )
fun
<a:vt>
g_copy1( !a ): ( a )
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:vt>
g_equal0(~a, ~a): bool
fun
<a:vt>
g_noteq0(~a, ~a): bool
//
fun
<a:vt>
g_equal1(!a, !a): bool
fun
<a:vt>
g_noteq1(!a, !a): bool
//
(* ****** ****** *)
//
fun
<a:vt>
g_eqref1(!a, !a): bool
fun
<a:vt>
g_neqrf1(!a, !a): bool
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:vt>
g_torep0(obj: ~a): strn
fun
<a:vt>
g_tostr0(obj: ~a): strn
//
fun
<a:vt>
g_torep1(obj: !a): strn
fun
<a:vt>
g_tostr1(obj: !a): strn
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
g_print0(obj: ~x0): void
fun
<x0:vt>
g_print1(obj: !x0): void
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_VT_gbas000_vt.sats] *)
(***********************************************************************)
`,
  "SATS/VT/gbas001_vt.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Wed 10 Jul 2024 09:26:36 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
#typedef ni = nint
(* ****** ****** *)
//
(*
HX-2024-07-15
*)
fun
<x0:vt>
max$nil0((*nil*)): (x0)
fun
<x0:vt>
max$nil1((*nil*)): (x0)
//
fun
<x0:vt>
min$nil0((*nil*)): (x0)
fun
<x0:vt>
min$nil1((*nil*)): (x0)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-15
*)
fun
<xs:vt>
<x0:vt>
get$at$exn0
(xs: ~xs, i0: ni): x0
fun
<xs:vt>
<x0:vt>
get$at$exn1
(xs: !xs, i0: ni): x0
//
(*
HX-2024-08-02:
This makes no sense!
fun
<xs:vt>
<x0:vt>
set$at$exn0
(xs: ~xs, ni, x0): void
*)
fun
<xs:vt>
<x0:vt>
set$at$exn1
(xs: !xs, ni, x0): void
//
fun
<xs:vt>
<x0:vt>
fset$at$exn0
(xs: ~xs, ni, x0): (xs)
fun
<xs:vt>
<x0:vt>
fset$at$exn1
(xs: !xs, ni, x0): (xs)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
forall$test0(x0: ~x0): bool
fun
<x0:vt>
forall$test1(x0: !x0): bool
//
fun
<x0:vt>
exists$test0(x0: ~x0): bool
fun
<x0:vt>
exists$tcmp0(x0: ~x0): sint
fun
<x0:vt>
exists$test1(x0: !x0): bool
fun
<x0:vt>
exists$tcmp1(x0: !x0): sint
//
(* ****** ****** *)
//
fun
<x0:vt>
rforall$test0(x0: ~x0): bool
fun
<x0:vt>
rforall$test1(x0: !x0): bool
//
fun
<x0:vt>
rexists$test0(x0: ~x0): bool
fun
<x0:vt>
rexists$tcmp0(x0: ~x0): sint
fun
<x0:vt>
rexists$test1(x0: !x0): bool
fun
<x0:vt>
rexists$tcmp1(x0: !x0): sint
//
(* ****** ****** *)
//
fun
<x0:vt>
iforall$test0(ni, ~x0): bool
fun
<x0:vt>
iforall$test1(ni, !x0): bool
//
fun
<x0:vt>
iexists$test0(ni, ~x0): bool
fun
<x0:vt>
iexists$test1(ni, !x0): bool
//
(* ****** ****** *)
//
fun
<x0:vt>
irforall$test0(ni, ~x0): bool
fun
<x0:vt>
irforall$test1(ni, !x0): bool
//
fun
<x0:vt>
irexists$test0(ni, ~x0): bool
fun
<x0:vt>
irexists$test1(ni, !x0): bool
//
(* ****** ****** *)
//
fun
<x0:vt>
foritm$work0(x0: ~x0): void
fun
<x0:vt>
foritm$work1(x0: !x0): void
fun
<x0:vt>
foritm$work1x(x0: &x0): void
//
fun
<x0:vt>
rforitm$work0(x0: ~x0): void
fun
<x0:vt>
rforitm$work1(x0: !x0): void
fun
<x0:vt>
rforitm$work1x(x0: &x0): void
//
fun
<x0:vt>
iforitm$work0(ni, ~x0): void
fun
<x0:vt>
iforitm$work1(ni, !x0): void
fun
<x0:vt>
iforitm$work1x(x0: &x0): void
//
fun
<x0:vt>
irforitm$work0(ni, ~x0): void
fun
<x0:vt>
irforitm$work1(ni, !x0): void
fun
<x0:vt>
irforitm$work1x(x0: &x0): void
//
(* ****** ****** *)
//
fun
<x0:vt>
<r0:vt>
folditm$fopr0(r0, ~x0): (r0)
fun
<x0:vt>
<r0:vt>
folditm$fopr1(r0, !x0): (r0)
fun
<x0:vt>
<r0:vt>
folditm$fopr1x(r0, &x0): (r0)
//
fun
<x0:vt>
<r0:vt>
rfolditm$fopr0(~x0, r0): (r0)
fun
<x0:vt>
<r0:vt>
rfolditm$fopr1(!x0, r0): (r0)
fun
<x0:vt>
<r0:vt>
rfolditm$fopr1x(&x0, r0): (r0)
//
fun
<x0:vt>
<r0:vt>
ifolditm$fopr0(r0, ni, ~x0): (r0)
fun
<x0:vt>
<r0:vt>
ifolditm$fopr1(r0, ni, !x0): (r0)
fun
<x0:vt>
<r0:vt>
ifolditm$fopr1x(r0, ni, &x0): (r0)
//
fun
<x0:vt>
<r0:vt>
irfolditm$fopr0(ni, ~x0, r0): (r0)
fun
<x0:vt>
<r0:vt>
irfolditm$fopr1(ni, !x0, r0): (r0)
fun
<x0:vt>
<r0:vt>
irfolditm$fopr1x(ni, &x0, r0): (r0)
//
(* ****** ****** *)
//
fun
<x0:vt>
<r0:vt>
scanitm$fopr0(!r0, ~x0): (r0)
fun
<x0:vt>
<r0:vt>
scanitm$fopr1(!r0, !x0): (r0)
fun
<x0:vt>
<r0:vt>
scanitm$fopr1x(!r0, &x0): (r0)
//
fun
<x0:vt>
<r0:vt>
iscanitm$fopr0(!r0, ni, ~x0): (r0)
fun
<x0:vt>
<r0:vt>
iscanitm$fopr1(!r0, ni, !x0): (r0)
fun
<x0:vt>
<r0:vt>
iscanitm$fopr1x(!r0, ni, &x0): (r0)
//
(* ****** ****** *)
//
fun
<x0:vt>
<r0:vt>
foldall$fopr0(r0, ~x0): (bool, r0)
fun
<x0:vt>
<r0:vt>
foldall$fopr1(r0, !x0): (bool, r0)
fun
<x0:vt>
<r0:vt>
foldall$fopr1x(r0, &x0): (bool, r0)
//
fun
<x0:vt>
<r0:vt>
rfoldall$fopr0(~x0, r0): (bool, r0)
fun
<x0:vt>
<r0:vt>
rfoldall$fopr1(!x0, r0): (bool, r0)
fun
<x0:vt>
<r0:vt>
rfoldall$fopr1x(r0, &x0): (bool, r0)
//
fun
<x0:vt>
<r0:vt>
ifoldall$fopr0(r0, ni, ~x0): (bool, r0)
fun
<x0:vt>
<r0:vt>
ifoldall$fopr1(r0, ni, !x0): (bool, r0)
fun
<x0:vt>
<r0:vt>
ifoldall$fopr1x(r0, ni, &x0): (bool, r0)
//
fun
<x0:vt>
<r0:vt>
irfoldall$fopr0(ni, ~x0, r0): (bool, r0)
fun
<x0:vt>
<r0:vt>
irfoldall$fopr1(ni, !x0, r0): (bool, r0)
fun
<x0:vt>
<r0:vt>
irfoldall$fopr1x(ni, &x0, r0): (bool, r0)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
<y0:vt>
map$fopr0(x0: ~x0): ( y0 )
fun
<x0:vt>
<y0:vt>
map$fopr1(x0: !x0): ( y0 )
fun
<x0:vt>
<y0:vt>
map$fopr1x(x0: &x0): ( y0 )
//
fun
<x0:vt>
<y0:vt>
rmap$fopr0(x0: ~x0): ( y0 )
fun
<x0:vt>
<y0:vt>
rmap$fopr1(x0: !x0): ( y0 )
fun
<x0:vt>
<y0:vt>
rmap$fopr1x(x0: &x0): ( y0 )
//
fun
<x0:vt>
<y0:vt>
imap$fopr0(ni, ~x0): ( y0 )
fun
<x0:vt>
<y0:vt>
imap$fopr1(ni, !x0): ( y0 )
fun
<x0:vt>
<y0:vt>
imap$fopr1x(ni, &x0): ( y0 )
//
fun
<x0:vt>
<y0:vt>
irmap$fopr0(ni, ~x0): ( y0 )
fun
<x0:vt>
<y0:vt>
irmap$fopr1(ni, !x0): ( y0 )
fun
<x0:vt>
<y0:vt>
irmap$fopr1x(ni, &x0): ( y0 )
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-29:
There is no [search$test0]!
fun
<x0:vt>
<y0:vt>
search$test0(x0: ~x0): bool
*)
//
fun
<x0:vt>
search$test1(x0: !x0): bool
fun
<x0:vt>
search$tcmp1(x0: !x0): sint
//
fun
<x0:vt>
rsearch$test1(x0: !x0): bool
fun
<x0:vt>
rsearch$tcmp1(x0: !x0): sint
//
fun
<x0:vt>
isearch$test1(ni, !x0): bool
fun
<x0:vt>
isearch$tcmp1(ni, !x0): sint
//
fun
<x0:vt>
irsearch$test1(ni, !x0): bool
fun
<x0:vt>
irsearch$tcmp1(ni, !x0): sint
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-24:
[filter$test0] is removed!
fun
<x0:vt>
<y0:vt>
filter$test0(x0: ~x0): bool
*)
//
fun
<x0:vt>
filter$test1(x0: !x0): bool
fun
<x0:vt>
filter$test1x(x0: &x0): bool
//
fun
<x0:vt>
rfilter$test1(x0: !x0): bool
fun
<x0:vt>
rfilter$test1x(x0: &x0): bool
//
fun
<x0:vt>
ifilter$test1(ni, !x0): bool
fun
<x0:vt>
ifilter$test1x(ni, &x0): bool
//
fun
<x0:vt>
irfilter$test1(ni, !x0): bool
fun
<x0:vt>
irfilter$test1x(ni, &x0): bool
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
<y0:vt>
mapoptn$fopr0(x0: ~x0): optn_vt(y0)
fun
<x0:vt>
<y0:vt>
maplist$fopr0(x0: ~x0): list_vt(y0)
fun
<x0:vt>
<y0:vt>
mapstrm$fopr0(x0: ~x0): strm_vt(y0)
fun
<x0:vt>
<y0:vt>
mapstrq$fopr0(x0: ~x0): strq_vt(y0)
//
fun
<x0:vt>
<y0:vt>
mapoptn$fopr1(x0: !x0): optn_vt(y0)
fun
<x0:vt>
<y0:vt>
maplist$fopr1(x0: !x0): list_vt(y0)
fun
<x0:vt>
<y0:vt>
mapstrm$fopr1(x0: !x0): strm_vt(y0)
fun
<x0:vt>
<y0:vt>
mapstrq$fopr1(x0: !x0): strq_vt(y0)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-31:
It is in [gbas001.sats]!
fun
<x0:vt> // HX: vt!
fmake$fwork((*void*)): void
*)
fun
<x0:vt>
fmake$fwork$work0(x0: ~x0): void
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
c2hoose$forall$test0(~x0, ~x0): bool
fun
<x0:vt>
c3hoose$forall$test0(~x0, ~x0, ~x0): bool
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-05-31:
Sat May 31 08:14:34 PM EDT 2025
*)
//
fun
<x0:vt>
<y0:vt>
<e1:vt>
map$e1nv$fopr0(x0: ~x0, e1: !e1): ( y0 )
fun
<x0:vt>
<y0:vt>
<e1:vt>
map$e1nv$fopr1(x0: !x0, e1: !e1): ( y0 )
fun
<x0:vt>
<y0:vt>
<e1:vt>
map$e1nv$fopr1x(x0: &x0, e1: !e1): ( y0 )
//
fun
<x0:vt>
<y0:vt>
<e1:vt>
rmap$e1nv$fopr0(x0: ~x0, e1: !e1): ( y0 )
fun
<x0:vt>
<y0:vt>
<e1:vt>
rmap$e1nv$fopr1(x0: !x0, e1: !e1): ( y0 )
fun
<x0:vt>
<y0:vt>
<e1:vt>
rmap$e1nv$fopr1x(x0: &x0, e1: !e1): ( y0 )
//
fun
<x0:vt>
<y0:vt>
<e1:vt>
imap$e1nv$fopr0(ni, ~x0, e1: !e1): ( y0 )
fun
<x0:vt>
<y0:vt>
<e1:vt>
imap$e1nv$fopr1(ni, !x0, e1: !e1): ( y0 )
fun
<x0:vt>
<y0:vt>
<e1:vt>
imap$e1nv$fopr1x(ni, &x0, e1: !e1): ( y0 )
//
fun
<x0:vt>
<y0:vt>
<e1:vt>
irmap$e1nv$fopr0(ni, ~x0, e1: !e1): ( y0 )
fun
<x0:vt>
<y0:vt>
<e1:vt>
irmap$e1nv$fopr1(ni, !x0, e1: !e1): ( y0 )
fun
<x0:vt>
<y0:vt>
<e1:vt>
irmap$e1nv$fopr1x(ni, &x0, e1: !e1): ( y0 )
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_VT_gbas001_vt.sats] *)
(***********************************************************************)
`,
  "SATS/VT/gbas002_vt.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Tue 23 Jul 2024 05:53:46 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#typedef ni = nint
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
<y0:vt>
z2forall$test0
(x0: ~x0, y0: ~y0): bool
fun
<x0:vt>
<y0:vt>
z2forall$test1
(x0: !x0, y0: !y0): bool
//
fun
<x0:vt>
<y0:vt>
z2rforall$test0
(x0: ~x0, y0: ~y0): bool
fun
<x0:vt>
<y0:vt>
z2rforall$test1
(x0: !x0, y0: !y0): bool
//
fun
<x0:vt>
<y0:vt>
z2iforall$test0
(i0: ni, x0: ~x0, y0: ~y0): bool
fun
<x0:vt>
<y0:vt>
z2iforall$test1
(i0: ni, x0: !x0, y0: !y0): bool
//
fun
<x0:vt>
<y0:vt>
z2irforall$test0
(i0: ni, x0: ~x0, y0: ~y0): bool
fun
<x0:vt>
<y0:vt>
z2irforall$test1
(i0: ni, x0: !x0, y0: !y0): bool
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
<y0:vt>
z2forcmp$test0
(x0: ~x0, y0: ~y0): sint
fun
<x0:vt>
<y0:vt>
z2forcmp$test1
(x0: !x0, y0: !y0): sint
//
fun
<x0:vt>
<y0:vt>
z2iforcmp$test0
(i0: ni, x0: ~x0, y0: ~y0): sint
fun
<x0:vt>
<y0:vt>
z2iforcmp$test1
(i0: ni, x0: !x0, y0: !y0): sint
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
<y0:vt>
z2foritm$work0
(x0: ~x0, y0: ~y0): void
fun
<x0:vt>
<y0:vt>
z2foritm$work1
(x0: !x0, y0: !y0): void
//
fun
<x0:vt>
<y0:vt>
z2rforitm$work0
(x0: ~x0, y0: ~y0): void
fun
<x0:vt>
<y0:vt>
z2rforitm$work1
(x0: !x0, y0: !y0): void
//
fun
<x0:vt>
<y0:vt>
z2iforitm$work0
(i0: ni, x0: ~x0, y0: ~y0): void
fun
<x0:vt>
<y0:vt>
z2iforitm$work1
(i0: ni, x0: !x0, y0: !y0): void
//
fun
<x0:vt>
<y0:vt>
z2irforitm$work0
(i0: ni, x0: ~x0, y0: ~y0): void
fun
<x0:vt>
<y0:vt>
z2irforitm$work1
(i0: ni, x0: !x0, y0: !y0): void
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
<y0:vt>
<z0:vt>
z2map$fopr0(x0: ~x0, y0: ~y0): ( z0 )
fun
<x0:vt>
<y0:vt>
<z0:vt>
z2map$fopr1(x0: !x0, y0: !y0): ( z0 )
//
fun
<x0:vt>
<y0:vt>
<z0:vt>
z2rmap$fopr0(x0: ~x0, y0: ~y0): ( z0 )
fun
<x0:vt>
<y0:vt>
<z0:vt>
z2rmap$fopr1(x0: !x0, y0: !y0): ( z0 )
//
fun
<x0:vt>
<y0:vt>
<z0:vt>
z2imap$fopr0(i0: ni, x0: ~x0, y0: ~y0): ( z0 )
fun
<x0:vt>
<y0:vt>
<z0:vt>
z2imap$fopr1(i0: ni, x0: !x0, y0: !y0): ( z0 )
//
fun
<x0:vt>
<y0:vt>
<z0:vt>
z2irmap$fopr0(i0: ni, x0: ~x0, y0: ~y0): ( z0 )
fun
<x0:vt>
<y0:vt>
<z0:vt>
z2irmap$fopr1(i0: ni, x0: !x0, y0: !y0): ( z0 )
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_VT_gbas002_vt.sats] *)
(***********************************************************************)
`,
  "SATS/VT/gcls000_vt.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon 29 Jul 2024 06:15:29 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
(*
HX-2026-01-12:
Mon Jan 12 11:55:56 PM EST 2026
This is 100% boilerplate stuff!
It should be automated eventually.
*)
(* ****** ****** *)
(* ****** ****** *)
//
#absvwtp
GSEQ_vt(
xs: vt, x0: vt) <= xs
#sexpdef GLSEQ = GSEQ_vt
//
(* ****** ****** *)
//
(*
HX-2026-01-13:
[GSEQ_vt]
can sub for [GASQ_vt]!
*)
#absvwtp
GASQ_vt(
xs: vt, x0: vt) <= xs
#sexpdef GLASQ = GASQ_vt
//
(* ****** ****** *)
(* ****** ****** *)
#typedef ni = nint
#typedef si = sint
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-13:
These are not needed!
Tue Jan 13 09:38:19 AM EST 2026
fun
<xs:vt>
<x0:vt>
GLSEQ_make(xs): GLSEQ(xs, x0)
fun
<xs:vt>
<x0:vt>
GLASQ_make(xs): GLASQ(xs, x0)
#symload GLSEQ with GLSEQ_make of 0000
#symload GLASQ with GLASQ_make of 0000
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
GLSEQ_unmk0
(gseq: ~GLSEQ(xs, x0)): (xs)
fun
<xs:vt>
<x0:vt>
GLSEQ_unmk1
(gseq: !GLSEQ(xs, x0)): (owed(xs)|xs)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-13:
GLASQ is a subclass of GLSEQ!
Tue Jan 13 09:30:46 AM EST 2026
*)
fcast
GLASQ_GLSEQ$cast
{xs:vt}{x0:vt}
(gasq: GLASQ(xs, x0)): GLSEQ(xs, x0)
#symload GLSEQ with GLASQ_GLSEQ$cast of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
GLSEQ_length0
(gseq: ~GLSEQ(xs, x0)): nint
fun
<xs:vt>
<x0:vt>
GLSEQ_length1
(gseq: !GLSEQ(xs, x0)): nint
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
GLSEQ_forall0
(gseq: ~GLSEQ(xs, x0)): bool
fun
<xs:vt>
<x0:vt>
GLSEQ_forall1
(gseq: !GLSEQ(xs, x0)): bool
//
#symload forall0 with GLSEQ_forall0 of 1000
#symload forall1 with GLSEQ_forall1 of 1000
//
fun
<xs:vt>
<x0:vt>
GLSEQ_forall0$f1un
( gseq: ~GLSEQ(xs, x0)
, test: ( ~x0 ) -> bool): bool
//
#symload forall0 with GLSEQ_forall0$f1un of 1000
#symload forall0$fun with GLSEQ_forall0$f1un of 1000
//
fun
<xs:vt>
<x0:vt>
GLSEQ_forall1$f1un
( gseq: !GLSEQ(xs, x0)
, test: ( !x0 ) -> bool): bool
//
#symload forall1 with GLSEQ_forall1$f1un of 1000
#symload forall1$fun with GLSEQ_forall1$f1un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
GLSEQ_rforall0
(gseq: ~GLSEQ(xs, x0)): bool
fun
<xs:vt>
<x0:vt>
GLSEQ_rforall1
(gseq: !GLSEQ(xs, x0)): bool
//
#symload rforall0 with GLSEQ_rforall0 of 1000
#symload rforall1 with GLSEQ_rforall1 of 1000
//
fun
<xs:vt>
<x0:vt>
GLSEQ_rforall0$f1un
( gseq: ~GLSEQ(xs, x0)
, test: ( ~x0 ) -> bool): bool
//
#symload rforall0 with GLSEQ_rforall0$f1un of 1000
#symload rforall0$fun with GLSEQ_rforall0$f1un of 1000
//
fun
<xs:vt>
<x0:vt>
GLSEQ_rforall1$f1un
( gseq: !GLSEQ(xs, x0)
, test: ( !x0 ) -> bool): bool
//
#symload rforall1 with GLSEQ_rforall1$f1un of 1000
#symload rforall1$fun with GLSEQ_rforall1$f1un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
GLSEQ_iforall0
(gseq: ~GLSEQ(xs, x0)): bool
fun
<xs:vt>
<x0:vt>
GLSEQ_iforall1
(gseq: !GLSEQ(xs, x0)): bool
//
#symload iforall0 with GLSEQ_iforall0 of 1000
#symload iforall1 with GLSEQ_iforall1 of 1000
//
fun
<xs:vt>
<x0:vt>
GLSEQ_iforall0$f2un
( gseq: ~GLSEQ(xs, x0)
, test: (ni, ~x0) -> bool): bool
//
#symload iforall0 with GLSEQ_iforall0$f2un of 1000
#symload iforall0$fun with GLSEQ_iforall0$f2un of 1000
//
fun
<xs:vt>
<x0:vt>
GLSEQ_iforall1$f2un
( gseq: !GLSEQ(xs, x0)
, test: (ni, !x0) -> bool): bool
//
#symload iforall1 with GLSEQ_iforall1$f2un of 1000
#symload iforall1$fun with GLSEQ_iforall1$f2un of 1000
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
GLSEQ_irforall0
(gseq: ~GLSEQ(xs, x0)): bool
fun
<xs:vt>
<x0:vt>
GLSEQ_irforall1
(gseq: !GLSEQ(xs, x0)): bool
//
#symload irforall0 with GLSEQ_irforall0 of 1000
#symload irforall1 with GLSEQ_irforall1 of 1000
//
fun
<xs:vt>
<x0:vt>
GLSEQ_irforall0$f2un
( gseq: ~GLSEQ(xs, x0)
, test: (ni, ~x0) -> bool): bool
//
#symload irforall0 with GLSEQ_irforall0$f2un of 1000
#symload irforall0$fun with GLSEQ_irforall0$f2un of 1000
//
fun
<xs:vt>
<x0:vt>
GLSEQ_irforall1$f2un
( gseq: !GLSEQ(xs, x0)
, test: (ni, !x0) -> bool): bool
//
#symload irforall1 with GLSEQ_irforall1$f2un of 1000
#symload irforall1$fun with GLSEQ_irforall1$f2un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-13:
Tue Jan 13 12:03:35 AM EST 2026
*)
fun
<xs:vt>
<x0:vt>
GLSEQ_foritm0
(gseq: ~GLSEQ(xs, x0)): void
fun
<xs:vt>
<x0:vt>
GLSEQ_foritm1
(gseq: !GLSEQ(xs, x0)): void
//
#symload foritm0 with GLSEQ_foritm0 of 1000
#symload foritm1 with GLSEQ_foritm1 of 1000
//
fun
<xs:vt>
<x0:vt>
GLSEQ_foritm0$f1un
( gseq: ~GLSEQ(xs, x0)
, work: ( ~x0 ) -> void): void
//
#symload foritm0 with GLSEQ_foritm0$f1un of 1000
#symload foritm0$fun with GLSEQ_foritm0$f1un of 1000
//
fun
<xs:vt>
<x0:vt>
GLSEQ_foritm1$f1un
( gseq: !GLSEQ(xs, x0)
, work: ( !x0 ) -> void): void
//
#symload foritm1 with GLSEQ_foritm1$f1un of 1000
#symload foritm1$fun with GLSEQ_foritm1$f1un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
GLSEQ_rforitm0
(gseq: ~GLSEQ(xs, x0)): void
fun
<xs:vt>
<x0:vt>
GLSEQ_rforitm1
(gseq: !GLSEQ(xs, x0)): void
//
#symload rforitm0 with GLSEQ_rforitm0 of 1000
#symload rforitm1 with GLSEQ_rforitm1 of 1000
//
fun
<xs:vt>
<x0:vt>
GLSEQ_rforitm0$f1un
( gseq: ~GLSEQ(xs, x0)
, work: ( ~x0 ) -> void): void
//
#symload rforitm0 with GLSEQ_rforitm0$f1un of 1000
#symload rforitm0$fun with GLSEQ_rforitm0$f1un of 1000
//
fun
<xs:vt>
<x0:vt>
GLSEQ_rforitm1$f1un
( gseq: !GLSEQ(xs, x0)
, work: ( !x0 ) -> void): void
//
#symload rforitm1 with GLSEQ_rforitm1$f1un of 1000
#symload rforitm1$fun with GLSEQ_rforitm1$f1un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
GLSEQ_iforitm0
(gseq: ~GLSEQ(xs, x0)): void
fun
<xs:vt>
<x0:vt>
GLSEQ_iforitm1
(gseq: !GLSEQ(xs, x0)): void
//
#symload iforitm0 with GLSEQ_iforitm0 of 1000
#symload iforitm1 with GLSEQ_iforitm1 of 1000
//
fun
<xs:vt>
<x0:vt>
GLSEQ_iforitm0$f2un
( gseq: ~GLSEQ(xs, x0)
, work: (ni, ~x0) -> void): void
//
#symload iforitm0 with GLSEQ_iforitm0$f2un of 1000
#symload iforitm0$fun with GLSEQ_iforitm0$f2un of 1000
//
fun
<xs:vt>
<x0:vt>
GLSEQ_iforitm1$f2un
( gseq: !GLSEQ(xs, x0)
, work: (ni, !x0) -> void): void
//
#symload iforitm1 with GLSEQ_iforitm1$f2un of 1000
#symload iforitm1$fun with GLSEQ_iforitm1$f2un of 1000
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
GLSEQ_irforitm0
(gseq: ~GLSEQ(xs, x0)): void
fun
<xs:vt>
<x0:vt>
GLSEQ_irforitm1
(gseq: !GLSEQ(xs, x0)): void
//
#symload irforitm0 with GLSEQ_irforitm0 of 1000
#symload irforitm1 with GLSEQ_irforitm1 of 1000
//
fun
<xs:vt>
<x0:vt>
GLSEQ_irforitm0$f2un
( gseq: ~GLSEQ(xs, x0)
, work: (ni, ~x0) -> void): void
//
#symload irforitm0 with GLSEQ_irforitm0$f2un of 1000
#symload irforitm0$fun with GLSEQ_irforitm0$f2un of 1000
//
fun
<xs:vt>
<x0:vt>
GLSEQ_irforitm1$f2un
( gseq: !GLSEQ(xs, x0)
, work: (ni, !x0) -> void): void
//
#symload irforitm1 with GLSEQ_irforitm1$f2un of 1000
#symload irforitm1$fun with GLSEQ_irforitm1$f2un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_VT_gcls000_vt.sats] *)
(***********************************************************************)
`,
  "SATS/VT/gfun000_vt.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sat 10 Aug 2024 03:27:21 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_VT_gfun000_vt.sats] *)
(***********************************************************************)
`,
  "SATS/VT/gnum000_vt.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Fri 12 Jul 2024 06:59:23 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
g_neg0(x0: ~x0): (x0)
fun
<x0:vt>
g_abs0(x0: ~x0): (x0)
//
fun
<x0:vt>
g_suc0(x0: ~x0): (x0)
fun
<x0:vt>
g_pre0(x0: ~x0): (x0)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
g_max00(~x0, ~x0): (x0)
fun
<x0:vt>
g_min00(~x0, ~x0): (x0)
//
(* ****** ****** *)
//
fun
<x0:vt>
g_add00(~x0, ~x0): (x0)
fun
<x0:vt>
g_add01(~x0, !x0): (x0)
//
fun
<x0:vt>
g_sub00(~x0, ~x0): (x0)
fun
<x0:vt>
g_sub00(~x0, !x0): (x0)
//
fun
<x0:vt>
g_mul00(~x0, ~x0): (x0)
fun
<x0:vt>
g_mul01(~x0, !x0): (x0)
//
fun
<x0:vt>
g_div00(~x0, ~x0): (x0)
fun
<x0:vt>
g_div01(~x0, !x0): (x0)
//
fun
<x0:vt>
g_mod00(~x0, ~x0): (x0)
fun
<x0:vt>
g_mod01(~x0, !x0): (x0)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_VT_gnum000_vt.sats] *)
(***********************************************************************)
`,
  "SATS/VT/gord000_vt.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sat 10 Aug 2024 03:06:45 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:vt>
g_lt00(~a, ~a): bool
fun
<a:vt>
g_lt11(!a, !a): bool
//
fun
<a:vt>
g_gt00(~a, ~a): bool
fun
<a:vt>
g_gt11(!a, !a): bool
//
fun
<a:vt>
g_lte00(~a, ~a): bool
fun
<a:vt>
g_lte11(!a, !a): bool
//
fun
<a:vt>
g_gte00(~a, ~a): bool
fun
<a:vt>
g_gte11(!a, !a): bool
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:vt>
g_cmp00(~a, ~a): sint
fun
<a:vt>
g_cmp01(~a, !a): sint
fun
<a:vt>
g_cmp10(!a, ~a): sint
fun
<a:vt>
g_cmp11(!a, !a): sint
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:vt>
g_max00(~a, ~a): ( a )
fun
<a:vt>
g_max01(~a, !a): ( a )
fun
<a:vt>
g_max10(!a, ~a): ( a )
fun
<a:vt>
g_max11(!a, !a): ( a )
//
fun
<a:vt>
g_min00(~a, ~a): ( a )
fun
<a:vt>
g_min01(~a, !a): ( a )
fun
<a:vt>
g_min10(!a, ~a): ( a )
fun
<a:vt>
g_min11(!a, !a): ( a )
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_VT_gord000_vt.sats] *)
(***********************************************************************)
`,
  "SATS/VT/gseq000_vt.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon 08 Jul 2024 02:15:16 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_free( ~xs ): void
fun
<xs:vt>
<x0:vt>
gseq_copy( !xs ): (xs)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_max0(xs: ~xs): (x0)
fun
<xs:vt>
<x0:vt>
gseq_max1(xs: !xs): (x0)
//
fun
<xs:vt>
<x0:vt>
gseq_min0(xs: ~xs): (x0)
fun
<xs:vt>
<x0:vt>
gseq_min1(xs: !xs): (x0)
//
fun
<xs:vt>
<x0:vt>
gseq_max$opt0
  (xs: ~xs): optn_vt(x0)
fun
<xs:vt>
<x0:vt>
gseq_max$opt1
  (xs: !xs): optn_vt(x0)
//
fun
<xs:vt>
<x0:vt>
gseq_min$opt0
  (xs: ~xs): optn_vt(x0)
fun
<xs:vt>
<x0:vt>
gseq_min$opt1
  (xs: !xs): optn_vt(x0)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_sum0(xs: ~xs): (x0)
fun
<xs:vt>
<x0:vt>
gseq_sum1(xs: !xs): (x0)
//
fun
<xs:vt>
<x0:vt>
gseq_prod0(xs: ~xs): (x0)
fun
<xs:vt>
<x0:vt>
gseq_prod1(xs: !xs): (x0)
//
(*
#symload sum0 with gseq_sum0 of 0100
#symload sum1 with gseq_sum1 of 0100
#symload prod0 with gseq_prod0 of 0100
#symload prod1 with gseq_prod1 of 0100
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_nil0((*nil*)): (xs)
fun
<xs:vt>
<x0:vt>
gseq_cons0(x0, xs): (xs)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_nilq0(xs: ~xs): bool
fun
<xs:vt>
<x0:vt>
gseq_nilq1(xs: !xs): bool
//
fun
<xs:vt>
<x0:vt>
gseq_consq0(xs: ~xs): bool
fun
<xs:vt>
<x0:vt>
gseq_consq1(xs: !xs): bool
//
(*
#symload nilq0 with gseq_nilq0 of 0100
#symload nilq0 with gseq_nilq1 of 0100
#symload consq0 with gseq_consq0 of 0100
#symload consq0 with gseq_consq1 of 0100
*)
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_head0(xs: ~xs): (x0)
fun
<xs:vt>
<x0:vt>
gseq_head1(xs: !xs): (x0)
//
fun
<xs:vt>
<x0:vt>
gseq_head$opt0
  ( xs: ~xs ): optn_vt(x0)
fun
<xs:vt>
<x0:vt>
gseq_head$opt1
  ( xs: !xs ): optn_vt(x0)
//
(*
#symload head0 with gseq_head0 of 0100
#symload head0 with gseq_head1 of 0100
#symload head0 with gseq_head$opt0 of 0100
#symload head0 with gseq_head$opt1 of 0100
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_tail0(xs: ~xs): (xs)
fun
<xs:vt>
<x0:vt>
gseq_tail$opt0
  ( xs: ~xs ): optn_vt(xs)
//
(*
#symload tail0 with gseq_tail0 of 0100
#symload tail0 with gseq_tail$opt0 of 0100
*)
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_uncons0(~xs): (x0, xs)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_torep0(xs: ~xs): (strn)
fun
<xs:vt>
<x0:vt>
gseq_torep1(xs: !xs): (strn)
//
fun
<xs:vt>
<x0:vt>
gseq_tostr0(xs: ~xs): (strn)
fun
<xs:vt>
<x0:vt>
gseq_tostr1(xs: !xs): (strn)
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_print0(xs: ~xs): (void)
fun
<xs:vt>
<x0:vt>
gseq_print1(xs: !xs): (void)
//
(*
#symload print0 with gseq_print0 of 0100
#symload print1 with gseq_print1 of 0100
*)
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_length0(xs: ~xs): sint
fun
<xs:vt>
<x0:vt>
gseq_length1(xs: !xs): sint
//
(*
#symload length0 with gseq_length0 of 0100
#symload length1 with gseq_length1 of 0100
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-15:
Mon 15 Jul 2024 04:09:48 PM EDT
*)
//
fun
<xs:vt>
<x0:vt>
gseq_get$at0
(xs: ~xs, i0: ni): (x0)
fun
<xs:vt>
<x0:vt>
gseq_get$at1
(xs: !xs, i0: ni): (x0)
//
fun
<xs:vt>
<x0:vt>
gseq_get$at$opt0
(xs: ~xs, i0: ni): optn_vt(x0)
fun
<xs:vt>
<x0:vt>
gseq_get$at$opt1
(xs: !xs, i0: ni): optn_vt(x0)
//
(*
#symload get$at1 with gseq_get$at1 of 0100
#symload get$atopt$1 with gseq_get$atopt$1 of 0100
*)
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-17:
Wed 17 Jul 2024 12:48:59 PM EDT
*)
//
fun
<xs:vt>
<x0:vt>
<ys:vt>
gseq_append00(xs: ~xs, ys: ~ys): (xs)
fun
<xs:vt>
<x0:vt>
<ys:vt>
gseq_append01(xs: ~xs, ys: !ys): (xs)
fun
<xs:vt>
<x0:vt>
<ys:vt>
gseq_append01(xs: ~xs, ys: ~ys): (xs)
fun
<xs:vt>
<x0:vt>
<ys:vt>
gseq_append10(xs: !xs, ys: !ys): (xs)
fun
<xs:vt>
<x0:vt>
<ys:vt>
gseq_append11(xs: !xs, ys: !ys): (xs)
//
(*
#symload append00 with gseq_append00 of 0100
#symload append01 with gseq_append01 of 0100
#symload append10 with gseq_append10 of 0100
#symload append11 with gseq_append11 of 0100
*)
//
(* ****** ****** *)
//
(*
HX-2024-07-17:
Wed 17 Jul 2024 12:48:59 PM EDT
*)
//
fun
<xs:vt>
<x0:vt>
<ys:vt>
gseq_prepend00(xs: ~xs, ys: ~ys): (xs)
fun
<xs:vt>
<x0:vt>
<ys:vt>
gseq_prepend01(xs: ~xs, ys: !ys): (xs)
fun
<xs:vt>
<x0:vt>
<ys:vt>
gseq_prepend10(xs: !xs, ys: ~ys): (xs)
fun
<xs:vt>
<x0:vt>
<ys:vt>
gseq_prepend11(xs: !xs, ys: !ys): (xs)
//
(*
#symload prepend00 with gseq_prepend00 of 0100
#symload prepend01 with gseq_prepend01 of 0100
#symload prepend10 with gseq_prepend10 of 0100
#symload prepend11 with gseq_prepend11 of 0100
*)
//
(* ****** ****** *)
//
(*
HX-2024-07-17:
Wed 17 Jul 2024 04:12:58 PM EDT
*)
//
fun
<xs:vt>
<x0:vt>
<ys:vt>
gseq_rappend00(xs: ~xs, ys: ~ys): (xs)
fun
<xs:vt>
<x0:vt>
<ys:vt>
gseq_rappend01(xs: ~xs, ys: !ys): (xs)
fun
<xs:vt>
<x0:vt>
<ys:vt>
gseq_rappend10(xs: !xs, ys: ~ys): (xs)
fun
<xs:vt>
<x0:vt>
<ys:vt>
gseq_rappend11(xs: !xs, ys: !ys): (xs)
//
(*
#symload rappend00 with gseq_rappend00 of 0100
#symload rappend01 with gseq_rappend01 of 0100
#symload rappend10 with gseq_rappend10 of 0100
#symload rappend11 with gseq_rappend11 of 0100
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-14:
Sun Dec 14 05:12:02 PM EST 2025
*)
fun
<xz:vt>
<xs:vt>
<x0:vt>
gseq_concat0_lstrm(xz: xz): strm_vt(x0)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_VT_gseq000_vt.sats] *)
(***********************************************************************)
`,
  "SATS/VT/gseq001_vt.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sat 13 Jul 2024 10:09:41 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_listize0
(xs: ~xs): list_vt(x0)//fun
fun
<xs:vt>
<x0:vt>
gseq_listize1
(xs: !xs): list_vt(x0)//fun
//
#typedef
gseq_listize0
(xs:vt, x0:vt) = (~xs) -> list_vt(x0)
#typedef
gseq_listize1
(xs:vt, x0:vt) = (!xs) -> list_vt(x0)
//
(*
#symload listize0 with gseq_listize0 of 0100
#symload listize1 with gseq_listize1 of 0100
*)
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_strmize0
(xs: ~xs): strm_vt(x0)//fun
fun
<xs:vt>
<x0:vt>
gseq_strmize1
(xs: !xs): strm_vt(x0)//fun
fun
<xs:vt>
<x0:vt>
gseq_strqize0
(xs: ~xs): strq_vt(x0)//fun
fun
<xs:vt>
<x0:vt>
gseq_strqize1
(xs: !xs): strq_vt(x0)//fun
//
#typedef
gseq_strmize0
(xs:vt, x0:vt) = (~xs) -> strm_vt(x0)
#typedef
gseq_strmize1
(xs:vt, x0:vt) = (!xs) -> strm_vt(x0)
#typedef
gseq_strqize0
(xs:vt, x0:vt) = (~xs) -> strq_vt(x0)
#typedef
gseq_strqize1
(xs:vt, x0:vt) = (!xs) -> strq_vt(x0)
//
(*
#symload strmize0 with gseq_strmize0 of 0100
#symload strmize1 with gseq_strmize1 of 0100
#symload strqize0 with gseq_strqize0 of 0100
#symload strqize1 with gseq_strqize1 of 0100
*)
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_rlistize0
(xs: ~xs): list_vt(x0)//fun
fun
<xs:vt>
<x0:vt>
gseq_rlistize1
(xs: !xs): list_vt(x0)//fun
//
#typedef
gseq_rlistize0
(xs:vt, x0:vt) = (~xs) -> list_vt(x0)
#typedef
gseq_rlistize1
(xs:vt, x0:vt) = (!xs) -> list_vt(x0)
//
(*
#symload rlistize0 with gseq_rlistize0 of 0100
#symload rlistize1 with gseq_rlistize1 of 0100
*)
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_rstrmize0
(xs: ~xs): strm_vt(x0)//fun
fun
<xs:vt>
<x0:vt>
gseq_rstrmize1
(xs: !xs): strm_vt(x0)//fun
fun
<xs:vt>
<x0:vt>
gseq_rstrqize0
(xs: ~xs): strq_vt(x0)//fun
fun
<xs:vt>
<x0:vt>
gseq_rstrqize1
(xs: !xs): strq_vt(x0)//fun
//
#typedef
gseq_rstrmize0
(xs:vt, x0:vt) = (~xs) -> strm_vt(x0)
#typedef
gseq_rstrmize1
(xs:vt, x0:vt) = (!xs) -> strm_vt(x0)
#typedef
gseq_rstrqize0
(xs:vt, x0:vt) = (~xs) -> strq_vt(x0)
#typedef
gseq_rstrqize1
(xs:vt, x0:vt) = (!xs) -> strq_vt(x0)
//
(*
#symload rstrmize0 with gseq_rstrmize0 of 0100
#symload rstrmize1 with gseq_rstrmize1 of 0100
#symload rstrqize0 with gseq_rstrqize0 of 0100
#symload rstrqize1 with gseq_rstrqize1 of 0100
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_forall0(xs: ~xs): bool
fun
<xs:vt>
<x0:vt>
gseq_forall1(xs: !xs): bool
//
(*
#symload forall0 with gseq_forall0 of 0100
#symload forall1 with gseq_forall1 of 0100
*)
//
fun
<xs:vt>
<x0:vt>
gseq_forall0$f1un
(xs: xs, test: (~x0)->bool): bool
//
(*
#symload forall0 with gseq_forall0$f1un of 0100
#symload forall0$fun with gseq_forall0$f1un of 0100
*)
#symload gseq_forall0 with gseq_forall0$f1un of 0100
//
fun
<xs:vt>
<x0:vt>
gseq_forall1$f1un
(xs: xs, test: (!x0)->bool): bool
//
(*
#symload forall1 with gseq_forall1$f1un of 0100
#symload forall1$fun with gseq_forall1$f1un of 0100
*)
#symload gseq_forall1 with gseq_forall1$f1un of 0100
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_exists0(xs: ~xs): bool
fun
<xs:vt>
<x0:vt>
gseq_exists1(xs: !xs): bool
//
(*
#symload exists0 with gseq_exists0 of 0100
#symload exists1 with gseq_exists1 of 0100
*)
//
fun
<xs:vt>
<x0:vt>
gseq_exists0$f1un
(xs: xs, test: (~x0)->bool): bool
//
(*
#symload exists0 with gseq_exists0$f1un of 0100
#symload exists0$fun with gseq_exists0$f1un of 0100
*)
#symload gseq_exists0 with gseq_exists0$f1un of 0100
//
fun
<xs:vt>
<x0:vt>
gseq_exists1$f1un
(xs: xs, test: (!x0)->bool): bool
//
(*
#symload exists1 with gseq_exists1$f1un of 0100
#symload exists1$fun with gseq_exists1$f1un of 0100
*)
#symload gseq_exists1 with gseq_exists1$f1un of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_rforall0(xs: ~xs): bool
fun
<xs:vt>
<x0:vt>
gseq_rforall1(xs: !xs): bool
//
(*
#symload rforall0 with gseq_rforall0 of 0100
#symload rforall1 with gseq_rforall1 of 0100
*)
//
fun
<xs:vt>
<x0:vt>
gseq_rforall0$f1un
(xs: xs, test: (~x0)->bool): bool
//
(*
#symload rforall0 with gseq_rforall0$f1un of 0100
#symload rforall0$fun with gseq_rforall0$f1un of 0100
*)
#symload gseq_rforall0 with gseq_rforall0$f1un of 0100
//
fun
<xs:vt>
<x0:vt>
gseq_rforall1$f1un
(xs: xs, test: (!x0)->bool): bool
//
(*
#symload rforall1 with gseq_rforall1$f1un of 0100
#symload rforall1$fun with gseq_rforall1$f1un of 0100
*)
#symload gseq_rforall1 with gseq_rforall1$f1un of 0100
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_rexists0(xs: ~xs): bool
fun
<xs:vt>
<x0:vt>
gseq_rexists1(xs: !xs): bool
//
(*
#symload rexists0 with gseq_rexists0 of 0100
#symload rexists1 with gseq_rexists1 of 0100
*)
//
fun
<xs:vt>
<x0:vt>
gseq_rexists0$f1un
(xs: xs, test: (~x0)->bool): bool
//
(*
#symload rexists0 with gseq_rexists0$f1un of 0100
#symload rexists0$fun with gseq_rexists0$f1un of 0100
*)
#symload gseq_rexists0 with gseq_rexists0$f1un of 0100
//
fun
<xs:vt>
<x0:vt>
gseq_rexists1$f1un
(xs: xs, test: (!x0)->bool): bool
//
(*
#symload rexists1 with gseq_rexists1$f1un of 0100
#symload rexists1$fun with gseq_rexists1$f1un of 0100
*)
#symload gseq_rexists1 with gseq_rexists1$f1un of 0100
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_iforall0(xs: ~xs): bool
fun
<xs:vt>
<x0:vt>
gseq_iforall1(xs: !xs): bool
//
(*
#symload iforall0 with gseq_iforall0 of 0100
#symload iforall1 with gseq_iforall1 of 0100
*)
//
fun
<xs:vt>
<x0:vt>
gseq_iforall0$f2un
(xs: xs, test: (ni, ~x0)->bool): bool
//
(*
#symload iforall0 with gseq_iforall0$f2un of 0100
#symload iforall0$fun with gseq_iforall0$f2un of 0100
*)
#symload gseq_iforall0 with gseq_iforall0$f2un of 0100
//
fun
<xs:vt>
<x0:vt>
gseq_iforall1$f2un
(xs: xs, test: (ni, !x0)->bool): bool
//
(*
#symload iforall1 with gseq_iforall1$f2un of 0100
#symload iforall1$fun with gseq_iforall1$f2un of 0100
*)
#symload gseq_iforall1 with gseq_iforall1$f2un of 0100
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_iexists0(xs: ~xs): bool
fun
<xs:vt>
<x0:vt>
gseq_iexists1(xs: !xs): bool
//
(*
#symload iexists0 with gseq_iexists0 of 0100
#symload iexists1 with gseq_iexists1 of 0100
*)
//
fun
<xs:vt>
<x0:vt>
gseq_iexists0$f2un
(xs: xs, test: (ni, ~x0)->bool): bool
//
(*
#symload iexists0 with gseq_iexists0$f2un of 0100
#symload iexists0$fun with gseq_iexists0$f2un of 0100
*)
#symload gseq_iexists0 with gseq_iexists0$f2un of 0100
//
fun
<xs:vt>
<x0:vt>
gseq_iexists1$f2un
(xs: xs, test: (ni, !x0)->bool): bool
//
(*
#symload iexists1 with gseq_iexists1$f2un of 0100
#symload iexists1$fun with gseq_iexists1$f2un of 0100
*)
#symload gseq_iexists1 with gseq_iexists1$f2un of 0100
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_irforall0(xs: ~xs): bool
fun
<xs:vt>
<x0:vt>
gseq_irforall1(xs: !xs): bool
//
(*
#symload irforall0 with gseq_irforall0 of 0100
#symload irforall1 with gseq_irforall1 of 0100
*)
//
fun
<xs:vt>
<x0:vt>
gseq_irforall0$f2un
(xs: xs, test: (ni, ~x0)->bool): bool
//
(*
#symload irforall0 with gseq_irforall0$f2un of 0100
#symload irforall0$fun with gseq_irforall0$f2un of 0100
*)
#symload gseq_irforall0 with gseq_irforall0$f2un of 0100
//
fun
<xs:vt>
<x0:vt>
gseq_irforall1$f2un
(xs: xs, test: (ni, !x0)->bool): bool
//
(*
#symload irforall1 with gseq_irforall1$f2un of 0100
#symload irforall1$fun with gseq_irforall1$f2un of 0100
*)
#symload gseq_irforall1 with gseq_irforall1$f2un of 0100
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_irexists0(xs: ~xs): bool
fun
<xs:vt>
<x0:vt>
gseq_irexists1(xs: !xs): bool
//
(*
#symload irexists0 with gseq_irexists0 of 0100
#symload irexists1 with gseq_irexists1 of 0100
*)
//
fun
<xs:vt>
<x0:vt>
gseq_irexists0$f2un
(xs: xs, test: (ni, ~x0)->bool): bool
//
(*
#symload irexists0 with gseq_irexists0$f2un of 0100
#symload irexists0$fun with gseq_irexists0$f2un of 0100
*)
#symload gseq_irexists0 with gseq_irexists0$f2un of 0100
//
fun
<xs:vt>
<x0:vt>
gseq_irexists1$f2un
(xs: xs, test: (ni, !x0)->bool): bool
//
(*
#symload irexists1 with gseq_irexists1$f2un of 0100
#symload irexists1$fun with gseq_irexists1$f2un of 0100
*)
#symload gseq_irexists1 with gseq_irexists1$f2un of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_foritm0(xs: ~xs): void
fun
<xs:vt>
<x0:vt>
gseq_foritm1(xs: !xs): void
//
(*
#symload foritm0 with gseq_foritm0 of 0100
#symload foritm1 with gseq_foritm1 of 0100
*)
//
fun
<xs:vt>
<x0:vt>
gseq_foritm0$f1un
(xs: xs, work: (~x0)->void): void
//
(*
#symload foritm0 with gseq_foritm0$f1un of 0100
#symload foritm0$fun with gseq_foritm0$f1un of 0100
*)
#symload gseq_foritm0 with gseq_foritm0$f1un of 0100
//
fun
<xs:vt>
<x0:vt>
gseq_foritm1$f1un
(xs: xs, work: (!x0)->void): void
//
(*
#symload foritm1 with gseq_foritm1$f1un of 0100
#symload foritm1$fun with gseq_foritm1$f1un of 0100
*)
#symload gseq_foritm1 with gseq_foritm1$f1un of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_rforitm0(xs: ~xs): void
fun
<xs:vt>
<x0:vt>
gseq_rforitm1(xs: !xs): void
//
(*
#symload rforitm0 with gseq_rforitm0 of 0100
#symload rforitm1 with gseq_rforitm1 of 0100
*)
//
fun
<xs:vt>
<x0:vt>
gseq_rforitm0$f1un
(xs: xs, work: (~x0)->void): void
//
(*
#symload rforitm0 with gseq_rforitm0$f1un of 0100
#symload rforitm0$fun with gseq_rforitm0$f1un of 0100
*)
#symload gseq_rforitm0 with gseq_rforitm0$f1un of 0100
//
fun
<xs:vt>
<x0:vt>
gseq_rforitm1$f1un
(xs: xs, work: (!x0)->void): void
//
(*
#symload rforitm1 with gseq_rforitm1$f1un of 0100
#symload rforitm1$fun with gseq_rforitm1$f1un of 0100
*)
#symload gseq_rforitm1 with gseq_rforitm1$f1un of 0100
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_iforitm0(xs: ~xs): void
fun
<xs:vt>
<x0:vt>
gseq_iforitm1(xs: !xs): void
//
(*
#symload iforitm0 with gseq_iforitm0 of 0100
#symload iforitm1 with gseq_iforitm1 of 0100
*)
//
fun
<xs:vt>
<x0:vt>
gseq_iforitm0$f2un
(xs: xs, work: (ni, ~x0)->void): void
//
(*
#symload iforitm0 with gseq_iforitm0$f2un of 0100
#symload iforitm0$fun with gseq_iforitm0$f2un of 0100
*)
#symload gseq_iforitm0 with gseq_iforitm0$f2un of 0100
//
fun
<xs:vt>
<x0:vt>
gseq_iforitm1$f2un
(xs: xs, work: (ni, !x0)->void): void
//
(*
#symload iforitm1 with gseq_iforitm1$f2un of 0100
#symload iforitm1$fun with gseq_iforitm1$f2un of 0100
*)
#symload gseq_iforitm1 with gseq_iforitm1$f2un of 0100
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_irforitm0(xs: ~xs): void
fun
<xs:vt>
<x0:vt>
gseq_irforitm1(xs: !xs): void
//
(*
#symload irforitm0 with gseq_irforitm0 of 0100
#symload irforitm1 with gseq_irforitm1 of 0100
*)
//
fun
<xs:vt>
<x0:vt>
gseq_irforitm0$f2un
(xs: xs, work: (ni, ~x0)->void): void
//
(*
#symload irforitm0 with gseq_irforitm0$f2un of 0100
#symload irforitm0$fun with gseq_irforitm0$f2un of 0100
*)
#symload gseq_irforitm0 with gseq_irforitm0$f2un of 0100
//
fun
<xs:vt>
<x0:vt>
gseq_irforitm1$f2un
(xs: xs, work: (ni, !x0)->void): void
//
(*
#symload irforitm1 with gseq_irforitm1$f2un of 0100
#symload irforitm1$fun with gseq_irforitm1$f2un of 0100
*)
#symload gseq_irforitm1 with gseq_irforitm1$f2un of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_folditm0(~xs, r0): (r0)
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_folditm1(!xs, r0): (r0)
//
(*
#symload folditm0 with gseq_folditm0 of 0100
#symload folditm1 with gseq_folditm1 of 0100
*)
//
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_folditm0$f2un
( xs: ~xs, r0: r0
, fopr: (r0, ~x0)-> (r0)): (r0)
//
(*
#symload folditm0 with gseq_folditm0$f2un of 1000
#symload folditm0$fun with gseq_folditm0$f2un of 1000
*)
#symload gseq_folditm0 with gseq_folditm0$f2un of 1000
//
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_folditm1$f2un
( xs: !xs, r0: r0
, fopr: (r0, !x0)-> (r0)): (r0)
//
(*
#symload folditm1 with gseq_folditm1$f2un of 1000
#symload folditm1$fun with gseq_folditm1$f2un of 1000
*)
#symload gseq_folditm1 with gseq_folditm1$f2un of 1000
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_rfolditm0(~xs, r0): (r0)
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_rfolditm1(!xs, r0): (r0)
//
(*
#symload rfolditm0 with gseq_rfolditm0 of 0100
#symload rfolditm1 with gseq_rfolditm1 of 0100
*)
//
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_rfolditm0$f2un
( xs: ~xs, r0: r0
, fopr: (~x0, r0)-> (r0)): (r0)
//
(*
#symload rfolditm0 with gseq_rfolditm0$f2un of 1000
#symload rfolditm0$fun with gseq_rfolditm0$f2un of 1000
*)
#symload gseq_rfolditm0 with gseq_rfolditm0$f2un of 1000
//
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_rfolditm1$f2un
( xs: !xs, r0: r0
, fopr: (!x0, r0)-> (r0)): (r0)
//
(*
#symload rfolditm1 with gseq_rfolditm1$f2un of 1000
#symload rfolditm1$fun with gseq_rfolditm1$f2un of 1000
*)
#symload gseq_rfolditm1 with gseq_rfolditm1$f2un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_ifolditm0(~xs, r0): (r0)
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_ifolditm1(!xs, r0): (r0)
//
(*
#symload ifolditm0 with gseq_ifolditm0 of 0100
#symload ifolditm1 with gseq_ifolditm1 of 0100
*)
//
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_ifolditm0$f3un
( xs: ~xs, r0: r0
, fopr: (r0, ni, ~x0)-> (r0)): (r0)
//
(*
#symload ifolditm0 with gseq_ifolditm0$f3un of 1000
#symload ifolditm0$fun with gseq_ifolditm0$f3un of 1000
*)
#symload gseq_ifolditm0 with gseq_ifolditm0$f3un of 1000
//
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_ifolditm1$f3un
( xs: !xs, r0: r0
, fopr: (r0, ni, !x0)-> (r0)): (r0)
//
(*
#symload ifolditm1 with gseq_ifolditm1$f3un of 1000
#symload ifolditm1$fun with gseq_ifolditm1$f3un of 1000
*)
#symload gseq_ifolditm1 with gseq_ifolditm1$f3un of 1000
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_irfolditm0(~xs, r0): (r0)
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_irfolditm1(!xs, r0): (r0)
//
(*
#symload irfolditm0 with gseq_irfolditm0 of 0100
#symload irfolditm1 with gseq_irfolditm1 of 0100
*)
//
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_irfolditm0$f3un
( xs: ~xs, r0: r0
, fopr: (ni, ~x0, r0)-> (r0)): (r0)
//
(*
#symload irfolditm0 with gseq_irfolditm0$f3un of 1000
#symload irfolditm0$fun with gseq_irfolditm0$f3un of 1000
*)
#symload gseq_irfolditm0 with gseq_irfolditm0$f3un of 1000
//
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_irfolditm1$f3un
( xs: !xs, r0: r0
, fopr: (ni, !x0, r0)-> (r0)): (r0)
//
(*
#symload irfolditm1 with gseq_irfolditm1$f3un of 1000
#symload irfolditm1$fun with gseq_irfolditm1$f3un of 1000
*)
#symload gseq_irfolditm1 with gseq_irfolditm1$f3un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_foldall0(~xs, r0): (r0)
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_foldall1(!xs, r0): (r0)
//
(*
#symload foldall0 with gseq_foldall0 of 0100
#symload foldall1 with gseq_foldall1 of 0100
*)
//
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_foldall0$f2un
( xs: ~xs, r0: r0
, fopr: (r0, ~x0)->(bool,r0)): (r0)
//
(*
#symload foldall0 with gseq_foldall0$f2un of 1000
#symload foldall0$fun with gseq_foldall0$f2un of 1000
*)
#symload gseq_foldall0 with gseq_foldall0$f2un of 1000
//
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_foldall1$f2un
( xs: !xs, r0: r0
, fopr: (r0, !x0)->(bool,r0)): (r0)
//
(*
#symload foldall1 with gseq_foldall1$f2un of 1000
#symload foldall1$fun with gseq_foldall1$f2un of 1000
*)
#symload gseq_foldall1 with gseq_foldall1$f2un of 1000
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_rfoldall0(~xs, r0): (r0)
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_rfoldall1(!xs, r0): (r0)
//
(*
#symload rfoldall0 with gseq_rfoldall0 of 0100
#symload rfoldall1 with gseq_rfoldall1 of 0100
*)
//
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_rfoldall0$f2un
( xs: ~xs, r0: r0
, fopr: (~x0, r0)->(bool,r0)): (r0)
//
(*
#symload rfoldall0 with gseq_rfoldall0$f2un of 1000
#symload rfoldall0$fun with gseq_rfoldall0$f2un of 1000
*)
#symload gseq_rfoldall0 with gseq_rfoldall0$f2un of 1000
//
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_rfoldall1$f2un
( xs: !xs, r0: r0
, fopr: (!x0, r0)->(bool,r0)): (r0)
//
(*
#symload rfoldall1 with gseq_rfoldall1$f2un of 1000
#symload rfoldall1$fun with gseq_rfoldall1$f2un of 1000
*)
#symload gseq_rfoldall1 with gseq_rfoldall1$f2un of 1000
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_ifoldall0(~xs, r0): (r0)
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_ifoldall1(!xs, r0): (r0)
//
(*
#symload ifoldall0 with gseq_ifoldall0 of 0100
#symload ifoldall1 with gseq_ifoldall1 of 0100
*)
//
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_ifoldall0$f3un
( xs: ~xs, r0: r0
, fopr: (ni,r0,~x0)->(bool,r0)): (r0)
//
(*
#symload ifoldall0 with gseq_ifoldall0$f3un of 1000
#symload ifoldall0$fun with gseq_ifoldall0$f3un of 1000
*)
#symload gseq_ifoldall0 with gseq_ifoldall0$f3un of 1000
//
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_ifoldall1$f3un
( xs: !xs, r0: r0
, fopr: (ni,r0,!x0)->(bool,r0)): (r0)
//
(*
#symload ifoldall1 with gseq_ifoldall1$f3un of 1000
#symload ifoldall1$fun with gseq_ifoldall1$f3un of 1000
*)
#symload gseq_ifoldall1 with gseq_ifoldall1$f3un of 1000
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_irfoldall0(~xs, r0): (r0)
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_irfoldall1(!xs, r0): (r0)
//
(*
#symload irfoldall0 with gseq_irfoldall0 of 0100
#symload irfoldall1 with gseq_irfoldall1 of 0100
*)
//
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_irfoldall0$f3un
( xs: ~xs, r0: r0
, fopr: (ni,~x0,r0)->(bool,r0)): (r0)
//
(*
#symload irfoldall0 with gseq_irfoldall0$f3un of 1000
#symload irfoldall0$fun with gseq_irfoldall0$f3un of 1000
*)
#symload gseq_irfoldall0 with gseq_irfoldall0$f3un of 1000
//
fun
<xs:vt>
<x0:vt>
<r0:vt>
gseq_irfoldall1$f3un
( xs: !xs, r0: r0
, fopr: (ni,!x0,r0)->(bool,r0)): (r0)
//
(*
#symload irfoldall1 with gseq_irfoldall1$f3un of 1000
#symload irfoldall1$fun with gseq_irfoldall1$f3un of 1000
*)
#symload gseq_irfoldall1 with gseq_irfoldall1$f3un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
<ys:vt>
gseq_map0_ares(xs: ~xs): (ys)
fun
<xs:vt>
<x0:vt>
<ys:vt>
gseq_map1_ares(xs: !xs): (ys)
//
fun
<xs:vt>
<x0:vt>
gseq_map0_self(xs: ~xs): (xs)
fun
<xs:vt>
<x0:vt>
gseq_map1_self(xs: !xs): (xs)
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_map0_llist(xs: ~xs): list_vt(y0)
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_map1_llist(xs: !xs): list_vt(y0)
//
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_map0$f1un_llist
(xs: xs, fopr: (~x0)->(y0)): list_vt(y0)
#symload
gseq_map0_llist with gseq_map0$f1un_llist of 0100
//
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_map1$f1un_llist
(xs: xs, fopr: (!x0)->(y0)): list_vt(y0)
#symload
gseq_map1_llist with gseq_map1$f1un_llist of 0100
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_map0_lstrm(xs: ~xs): strm_vt(y0)
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_map0_lstrq(xs: ~xs): strq_vt(y0)
//
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_map1_lstrm(xs: !xs): strm_vt(y0)
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_map1_lstrq(xs: !xs): strq_vt(y0)
//
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_map0$f1un_lstrm
(xs: xs, fopr: (~x0)->(y0)): strm_vt(y0)
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_map0$f1un_lstrq
(xs: xs, fopr: (~x0)->(y0)): strq_vt(y0)
//
#symload
gseq_map0_lstrm with gseq_map0$f1un_lstrm of 0100
#symload
gseq_map0_lstrq with gseq_map0$f1un_lstrq of 0100
//
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_map1$f1un_lstrm
(xs: xs, fopr: (!x0)->(y0)): strm_vt(y0)
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_map1$f1un_lstrq
(xs: xs, fopr: (!x0)->(y0)): strq_vt(y0)
//
#symload
gseq_map1_lstrm with gseq_map1$f1un_lstrm of 0100
#symload
gseq_map1_lstrq with gseq_map1$f1un_lstrq of 0100
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_rmap0_llist(xs: ~xs): list_vt(y0)
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_rmap1_llist(xs: !xs): list_vt(y0)
//
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_rmap0$f1un_llist
(xs: xs, fopr: (~x0)->(y0)): list_vt(y0)
//
#symload
gseq_rmap0_llist with gseq_rmap0$f1un_llist of 0100
//
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_rmap1$f1un_llist
(xs: xs, fopr: (!x0)->(y0)): list_vt(y0)
//
#symload
gseq_rmap1_llist with gseq_rmap1$f1un_llist of 0100
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_rmap0_lstrm(xs: ~xs): strm_vt(y0)
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_rmap0_lstrq(xs: ~xs): strq_vt(y0)
//
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_rmap1_lstrm(xs: !xs): strm_vt(y0)
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_rmap1_lstrq(xs: !xs): strq_vt(y0)
//
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_rmap0$f1un_lstrm
(xs: xs, fopr: (~x0)->(y0)): strm_vt(y0)
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_rmap0$f1un_lstrq
(xs: xs, fopr: (~x0)->(y0)): strq_vt(y0)
//
#symload
gseq_rmap0_lstrm with gseq_rmap0$f1un_lstrm of 0100
#symload
gseq_rmap0_lstrq with gseq_rmap0$f1un_lstrq of 0100
//
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_rmap1$f1un_lstrm
(xs: xs, fopr: (!x0)->(y0)): strm_vt(y0)
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_rmap1$f1un_lstrq
(xs: xs, fopr: (!x0)->(y0)): strq_vt(y0)
//
#symload
gseq_rmap1_lstrm with gseq_rmap1$f1un_lstrm of 0100
#symload
gseq_rmap1_lstrq with gseq_rmap1$f1un_lstrq of 0100
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_imap0_llist(xs: ~xs): list_vt(y0)
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_imap1_llist(xs: !xs): list_vt(y0)
//
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_imap0_lstrm(xs: ~xs): strm_vt(y0)
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_imap0_lstrq(xs: ~xs): strq_vt(y0)
//
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_imap1_lstrm(xs: !xs): strm_vt(y0)
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_imap1_lstrq(xs: !xs): strq_vt(y0)
//
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_imap0$f1un_lstrm
(xs: xs, fopr: (ni,~x0)->(y0)): strm_vt(y0)
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_imap0$f1un_lstrq
(xs: xs, fopr: (ni,~x0)->(y0)): strq_vt(y0)
//
#symload
gseq_imap0_lstrm with gseq_imap0$f1un_lstrm of 0100
#symload
gseq_imap0_lstrq with gseq_imap0$f1un_lstrq of 0100
//
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_imap1$f1un_lstrm
(xs: xs, fopr: (ni,!x0)->(y0)): strm_vt(y0)
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_imap1$f1un_lstrq
(xs: xs, fopr: (ni,!x0)->(y0)): strq_vt(y0)
//
#symload
gseq_imap1_lstrm with gseq_imap1$f1un_lstrm of 0100
#symload
gseq_imap1_lstrq with gseq_imap1$f1un_lstrq of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-28:
Sun 28 Jul 2024 05:45:15 PM EDT
*)
//
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_irmap0_llist(xs: ~xs): list_vt(y0)
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_irmap1_llist(xs: !xs): list_vt(y0)
//
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_irmap0_lstrm(xs: ~xs): strm_vt(y0)
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_irmap0_lstrq(xs: ~xs): strq_vt(y0)
//
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_irmap1_lstrm(xs: !xs): strm_vt(y0)
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_irmap1_lstrq(xs: !xs): strq_vt(y0)
//
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_irmap0$f1un_lstrm
(xs: xs, fopr: (ni,~x0)->(y0)): strm_vt(y0)
//
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_irmap0$f1un_lstrq
(xs: xs, fopr: (ni,~x0)->(y0)): strq_vt(y0)
//
#symload
gseq_irmap0_lstrm with gseq_irmap0$f1un_lstrm of 0100
#symload
gseq_irmap0_lstrq with gseq_irmap0$f1un_lstrq of 0100
//
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_irmap1$f1un_lstrm
(xs: xs, fopr: (ni,!x0)->(y0)): strm_vt(y0)
fun
<xs:vt>
<x0:vt>
<y0:vt>
gseq_irmap1$f1un_lstrq
(xs: xs, fopr: (ni,!x0)->(y0)): strq_vt(y0)
//
#symload
gseq_irmap1_lstrm with gseq_irmap1$f1un_lstrm of 0100
#symload
gseq_irmap1_lstrq with gseq_irmap1$f1un_lstrq of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
<ys:vt>
gseq_filter0_ares(xs: ~xs): (ys)
fun
<xs:vt>
<x0:vt>
<ys:vt>
gseq_filter1_ares(xs: !xs): (ys)
//
fun
<xs:vt>
<x0:vt>
gseq_filter0_self(xs: ~xs): (xs)
fun
<xs:vt>
<x0:vt>
gseq_filter1_self(xs: !xs): (xs)
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_filter0_llist(xs: ~xs): list_vt(x0)
fun
<xs:vt>
<x0:vt>
gseq_filter1_llist(xs: !xs): list_vt(x0)
//
fun
<xs:vt>
<x0:vt>
gseq_filter0$f1un_llist
(xs: xs, fopr: (~x0)->bool): list_vt(x0)
fun
<xs:vt>
<x0:vt>
gseq_filter1$f1un_llist
(xs: xs, fopr: (!x0)->bool): list_vt(x0)
//
#symload
gseq_filter0_llist with gseq_filter0$f1un_llist of 0100
#symload
gseq_filter1_llist with gseq_filter1$f1un_llist of 0100
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_filter0_lstrm(xs: ~xs): strm_vt(x0)
fun
<xs:vt>
<x0:vt>
gseq_filter0_lstrq(xs: ~xs): strq_vt(x0)
//
fun
<xs:vt>
<x0:vt>
gseq_filter1_lstrm(xs: !xs): strm_vt(x0)
fun
<xs:vt>
<x0:vt>
gseq_filter1_lstrq(xs: !xs): strq_vt(x0)
//
fun
<xs:vt>
<x0:vt>
gseq_filter0$f1un_lstrm
(xs: xs, fopr: (~x0)->bool): strm_vt(x0)
fun
<xs:vt>
<x0:vt>
gseq_filter0$f1un_lstrq
(xs: xs, fopr: (~x0)->bool): strq_vt(x0)
//
#symload
gseq_filter0_lstrm with gseq_filter0$f1un_lstrm of 0100
#symload
gseq_filter0_lstrq with gseq_filter0$f1un_lstrq of 0100
//
fun
<xs:vt>
<x0:vt>
gseq_filter1$f1un_lstrm
(xs: xs, fopr: (!x0)->bool): strm_vt(x0)
fun
<xs:vt>
<x0:vt>
gseq_filter1$f1un_lstrq
(xs: xs, fopr: (!x0)->bool): strq_vt(x0)
//
#symload
gseq_filter1_lstrm with gseq_filter1$f1un_lstrm of 0100
#symload
gseq_filter1_lstrq with gseq_filter1$f1un_lstrq of 0100
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_rfilter0_llist(xs: ~xs): list_vt(x0)
fun
<xs:vt>
<x0:vt>
gseq_rfilter1_llist(xs: !xs): list_vt(x0)
//
fun
<xs:vt>
<x0:vt>
gseq_rfilter0$f1un_llist
(xs: xs, fopr: (~x0)->bool): list_vt(x0)
fun
<xs:vt>
<x0:vt>
gseq_rfilter1$f1un_llist
(xs: xs, fopr: (!x0)->bool): list_vt(x0)
//
#symload
gseq_rfilter0_llist with gseq_rfilter0$f1un_llist of 0100
#symload
gseq_rfilter1_llist with gseq_rfilter1$f1un_llist of 0100
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_rfilter0_lstrm(xs: ~xs): strm_vt(x0)
fun
<xs:vt>
<x0:vt>
gseq_rfilter0_lstrq(xs: ~xs): strq_vt(x0)
//
fun
<xs:vt>
<x0:vt>
gseq_rfilter1_lstrm(xs: !xs): strm_vt(x0)
fun
<xs:vt>
<x0:vt>
gseq_rfilter1_lstrq(xs: !xs): strq_vt(x0)
//
fun
<xs:vt>
<x0:vt>
gseq_rfilter0$f1un_lstrm
(xs: xs, fopr: (~x0)->bool): strm_vt(x0)
fun
<xs:vt>
<x0:vt>
gseq_rfilter0$f1un_lstrq
(xs: xs, fopr: (~x0)->bool): strq_vt(x0)
//
#symload
gseq_rfilter0_lstrm with gseq_rfilter0$f1un_lstrm of 0100
#symload
gseq_rfilter0_lstrq with gseq_rfilter0$f1un_lstrq of 0100
//
fun
<xs:vt>
<x0:vt>
gseq_rfilter1$f1un_lstrm
(xs: xs, fopr: (!x0)->bool): strm_vt(x0)
fun
<xs:vt>
<x0:vt>
gseq_rfilter1$f1un_lstrq
(xs: xs, fopr: (!x0)->bool): strq_vt(x0)
//
#symload
gseq_rfilter1_lstrm with gseq_rfilter1$f1un_lstrm of 0100
#symload
gseq_rfilter1_lstrq with gseq_rfilter1$f1un_lstrq of 0100
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_ifilter0_self(xs: ~xs): (xs)
fun
<xs:vt>
<x0:vt>
gseq_ifilter1_self(xs: !xs): (xs)
//
fun
<xs:vt>
<x0:vt>
gseq_ifilter0_llist(xs: ~xs): list_vt(x0)
fun
<xs:vt>
<x0:vt>
gseq_ifilter1_llist(xs: !xs): list_vt(x0)
//
fun
<xs:vt>
<x0:vt>
gseq_ifilter0$f1un_llist
(xs: xs, fopr: (ni,~x0)->bool): list_vt(x0)
fun
<xs:vt>
<x0:vt>
gseq_ifilter1$f1un_llist
(xs: xs, fopr: (ni,!x0)->bool): list_vt(x0)
//
#symload
gseq_ifilter0_llist with gseq_ifilter0$f1un_llist of 0100
#symload
gseq_ifilter1_llist with gseq_ifilter1$f1un_llist of 0100
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gseq_ifilter0_lstrm(xs: ~xs): strm_vt(x0)
fun
<xs:vt>
<x0:vt>
gseq_ifilter0_lstrq(xs: ~xs): strq_vt(x0)
//
fun
<xs:vt>
<x0:vt>
gseq_ifilter1_lstrm(xs: !xs): strm_vt(x0)
fun
<xs:vt>
<x0:vt>
gseq_ifilter1_lstrq(xs: !xs): strq_vt(x0)
//
fun
<xs:vt>
<x0:vt>
gseq_ifilter0$f1un_lstrm
(xs: xs, fopr: (ni,~x0)->bool): strm_vt(x0)
fun
<xs:vt>
<x0:vt>
gseq_ifilter0$f1un_lstrq
(xs: xs, fopr: (ni,~x0)->bool): strq_vt(x0)
//
#symload
gseq_ifilter0_lstrm with gseq_ifilter0$f1un_lstrm of 0100
#symload
gseq_ifilter0_lstrq with gseq_ifilter0$f1un_lstrq of 0100
//
fun
<xs:vt>
<x0:vt>
gseq_ifilter1$f1un_lstrm
(xs: xs, fopr: (ni,!x0)->bool): strm_vt(x0)
fun
<xs:vt>
<x0:vt>
gseq_ifilter1$f1un_lstrq
(xs: xs, fopr: (ni,!x0)->bool): strq_vt(x0)
//
#symload
gseq_ifilter1_lstrm with gseq_ifilter1$f1un_lstrm of 0100
#symload
gseq_ifilter1_lstrq with gseq_ifilter1$f1un_lstrq of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-06-01:
Sun Jun  1 07:39:56 PM EDT 2025
*)
//
fun
<xs:vt>
<x0:vt>
<y0:vt>
<e1:vt>
gseq_map$e1nv0_llist
( xs: ~xs, e1: !e1 ): list_vt(y0)
fun
<xs:vt>
<x0:vt>
<y0:vt>
<e1:vt>
gseq_map$e1nv1_llist
( xs: !xs, e1: !e1 ): list_vt(y0)
//
fun
<xs:vt>
<x0:vt>
<y0:vt>
<e1:vt>
gseq_map$e1nv0$f2un_llist
( xs: ~xs
, e1: !e1, fopr: (~x0, !e1)->(y0)): list_vt(y0)
#symload
gseq_map0_llist with gseq_map$e1nv0$f2un_llist of 0100
#symload
gseq_map$e1nv0_llist with gseq_map$e1nv0$f2un_llist of 0100
//
fun
<xs:vt>
<x0:vt>
<y0:vt>
<e1:vt>
gseq_map$e1nv1$f2un_llist
( xs: !xs
, e1: !e1, fopr: (!x0, !e1)->(y0)): list_vt(y0)
#symload
gseq_map1_llist with gseq_map$e1nv1$f2un_llist of 0100
#symload
gseq_map$e1nv1_llist with gseq_map$e1nv1$f2un_llist of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
<y0:vt>
<e1:vt>
gseq_map$e1nv0_lstrm
( xs: ~xs, e1: !e1 ): strm_vt(y0)
fun
<xs:vt>
<x0:vt>
<y0:vt>
<e1:vt>
gseq_map$e1nv0_lstrq
( xs: ~xs, e1: !e1 ): strq_vt(y0)
//
fun
<xs:vt>
<x0:vt>
<y0:vt>
<e1:vt>
gseq_map$e1nv1_lstrm
( xs: !xs, e1: !e1 ): strm_vt(y0)
fun
<xs:vt>
<x0:vt>
<y0:vt>
<e1:vt>
gseq_map$e1nv1_lstrq
( xs: !xs, e1: !e1 ): strq_vt(y0)
//
fun
<xs:vt>
<x0:vt>
<y0:vt>
<e1:vt>
gseq_map$e1nv0$f2un_lstrm
( xs: ~xs
, e1: !e1, fopr: (~x0, !e1)->(y0)): strm_vt(y0)
#symload
gseq_map0_lstrm with gseq_map$e1nv0$f2un_lstrm of 0100
#symload
gseq_map$e1nv0_lstrm with gseq_map$e1nv0$f2un_lstrm of 0100
fun
<xs:vt>
<x0:vt>
<y0:vt>
<e1:vt>
gseq_map$e1nv0$f2un_lstrq
( xs: ~xs
, e1: !e1, fopr: (~x0, !e1)->(y0)): strq_vt(y0)
#symload
gseq_map0_lstrq with gseq_map$e1nv0$f2un_lstrq of 0100
#symload
gseq_map$e1nv0_lstrq with gseq_map$e1nv0$f2un_lstrq of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-16:
Fri Dec 26 01:32:57 PM EST 2025
*)
//
fun
<xs:vt>
<x0:vt>
gseq_ord$exists0(xs: ~xs): bool
fun
<xs:vt>
<x0:vt>
gseq_ord$exists1(xs: !xs): bool
//
fun
<xs:vt>
<x0:vt>
gseq_ord$iexists0(xs: ~xs): bool
fun
<xs:vt>
<x0:vt>
gseq_ord$iexists1(xs: !xs): bool
//
fun
<xs:vt>
<x0:vt>
gseq_ord$exists0$f1un
(xs: xs, tcmp: (~x0)->sint): bool
fun
<xs:vt>
<x0:vt>
gseq_ord$exists1$f1un
(xs: xs, tcmp: (!x0)->sint): bool
//
#symload
gseq_ord$exists0 with gseq_ord$exists0$f1un of 0100
#symload
gseq_ord$exists1 with gseq_ord$exists1$f1un of 0100
//
//
fun
<xs:vt>
<x0:vt>
gseq_ord$iexists0$f2un
(xs: xs, tcmp: (ni, ~x0)->sint): bool
fun
<xs:vt>
<x0:vt>
gseq_ord$iexists1$f2un
(xs: xs, tcmp: (ni, !x0)->sint): bool
//
#symload
gseq_ord$iexists0 with gseq_ord$iexists0$f2un of 0100
#symload
gseq_ord$iexists1 with gseq_ord$iexists1$f2un of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_VT_gseq001_vt.sats] *)
(***********************************************************************)
`,
  "SATS/VT/gseq002_vt.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sat 13 Jul 2024 04:35:37 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-24:
Wed 24 Jul 2024 06:54:17 PM EDT
*)
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
gseq_z2forall0(xs: ~xs, ys: ~ys): bool
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
gseq_z2forall1(xs: !xs, ys: !ys): bool
//
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
gseq_z2rforall0(xs: ~xs, ys: ~ys): bool
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
gseq_z2rforall1(xs: !xs, ys: !ys): bool
//
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
gseq_z2iforall0(xs: ~xs, ys: ~ys): bool
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
gseq_z2iforall1(xs: !xs, ys: !ys): bool
//
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
gseq_z2irforall0(xs: ~xs, ys: ~ys): bool
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
gseq_z2irforall1(xs: !xs, ys: !ys): bool
//
(* ****** ****** *)
//
#symload z2forall0 with gseq_z2forall0 of 0100
#symload z2forall1 with gseq_z2forall1 of 0100
#symload z2rforall0 with gseq_z2rforall0 of 0100
#symload z2rforall1 with gseq_z2rforall1 of 0100
#symload z2iforall0 with gseq_z2iforall0 of 0100
#symload z2iforall1 with gseq_z2iforall1 of 0100
#symload z2irforall0 with gseq_z2irforall0 of 0100
#symload z2irforall1 with gseq_z2irforall1 of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
gseq_z2foritm0(xs: ~xs, ys: ~ys): void
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
gseq_z2foritm1(xs: !xs, ys: !ys): void
//
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
gseq_z2rforitm0(xs: ~xs, ys: ~ys): void
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
gseq_z2rforitm1(xs: !xs, ys: !ys): void
//
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
gseq_z2iforitm0(xs: ~xs, ys: ~ys): void
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
gseq_z2iforitm1(xs: !xs, ys: !ys): void
//
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
gseq_z2irforitm0(xs: ~xs, ys: ~ys): void
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
gseq_z2irforitm1(xs: !xs, ys: !ys): void
//
(* ****** ****** *)
//
#symload z2foritm0 with gseq_z2foritm0 of 0100
#symload z2foritm1 with gseq_z2foritm1 of 0100
#symload z2rforitm0 with gseq_z2rforitm0 of 0100
#symload z2rforitm1 with gseq_z2rforitm1 of 0100
#symload z2iforitm0 with gseq_z2iforitm0 of 0100
#symload z2iforitm1 with gseq_z2iforitm1 of 0100
#symload z2irforitm0 with gseq_z2irforitm0 of 0100
#symload z2irforitm1 with gseq_z2irforitm1 of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-24:
Wed 24 Jul 2024 06:54:17 PM EDT
*)
//
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
<zs:vt>
<z0:vt>
gseq_z2map0_ares(xs: ~xs, ys: ~ys): ( zs )
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
gseq_z2map0_self(xs: ~xs, ys: ~ys): ( xs )
//
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
<z0:vt>
gseq_z2map0_llist(xs: ~xs, ys: ~ys): list_vt(z0)
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
<z0:vt>
gseq_z2map1_llist(xs: !xs, ys: !ys): list_vt(z0)
//
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
<z0:vt>
gseq_z2map0_lstrm(xs: ~xs, ys: ~ys): strm_vt(z0)
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
<z0:vt>
gseq_z2map1_lstrm(xs: !xs, ys: !ys): strm_vt(z0)
//
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
<z0:vt>
gseq_z2map0_lstrq(xs: ~xs, ys: ~ys): strq_vt(z0)
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
<z0:vt>
gseq_z2map1_lstrq(xs: !xs, ys: !ys): strq_vt(z0)
//
#symload z2map0_llist with gseq_z2map0_llist of 0100
#symload z2map1_llist with gseq_z2map1_llist of 0100
#symload z2map0_lstrm with gseq_z2map0_lstrm of 0100
#symload z2map1_lstrm with gseq_z2map1_lstrm of 0100
#symload z2map0_lstrq with gseq_z2map0_lstrq of 0100
#symload z2map1_lstrq with gseq_z2map1_lstrq of 0100
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
<z0:vt>
gseq_z2rmap0_llist(xs: ~xs, ys: ~ys): list_vt(z0)
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
<z0:vt>
gseq_z2rmap1_llist(xs: !xs, ys: !ys): list_vt(z0)
//
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
<z0:vt>
gseq_z2rmap0_lstrm(xs: ~xs, ys: ~ys): strm_vt(z0)
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
<z0:vt>
gseq_z2rmap1_lstrm(xs: !xs, ys: !ys): strm_vt(z0)
//
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
<z0:vt>
gseq_z2rmap0_lstrq(xs: ~xs, ys: ~ys): strq_vt(z0)
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
<z0:vt>
gseq_z2rmap1_lstrq(xs: !xs, ys: !ys): strq_vt(z0)
//
#symload z2rmap0_llist with gseq_z2rmap0_llist of 0100
#symload z2rmap1_llist with gseq_z2rmap1_llist of 0100
#symload z2rmap0_lstrm with gseq_z2rmap0_lstrm of 0100
#symload z2rmap1_lstrm with gseq_z2rmap1_lstrm of 0100
#symload z2rmap0_lstrq with gseq_z2rmap0_lstrq of 0100
#symload z2rmap1_lstrq with gseq_z2rmap1_lstrq of 0100
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
<z0:vt>
gseq_z2imap0_llist(xs: ~xs, ys: ~ys): list_vt(z0)
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
<z0:vt>
gseq_z2imap1_llist(xs: !xs, ys: !ys): list_vt(z0)
//
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
<z0:vt>
gseq_z2imap0_lstrm(xs: ~xs, ys: ~ys): strm_vt(z0)
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
<z0:vt>
gseq_z2imap1_lstrm(xs: !xs, ys: !ys): strm_vt(z0)
//
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
<z0:vt>
gseq_z2imap0_lstrq(xs: ~xs, ys: ~ys): strq_vt(z0)
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
<z0:vt>
gseq_z2imap1_lstrq(xs: !xs, ys: !ys): strq_vt(z0)
//
#symload z2imap0_llist with gseq_z2imap0_llist of 0100
#symload z2imap1_llist with gseq_z2imap1_llist of 0100
#symload z2imap0_lstrm with gseq_z2imap0_lstrm of 0100
#symload z2imap1_lstrm with gseq_z2imap1_lstrm of 0100
#symload z2imap0_lstrq with gseq_z2imap0_lstrq of 0100
#symload z2imap1_lstrq with gseq_z2imap1_lstrq of 0100
//
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
<z0:vt>
gseq_z2irmap0_llist(xs: ~xs, ys: ~ys): list_vt(z0)
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
<z0:vt>
gseq_z2irmap1_llist(xs: !xs, ys: !ys): list_vt(z0)
//
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
<z0:vt>
gseq_z2irmap0_lstrm(xs: ~xs, ys: ~ys): strm_vt(z0)
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
<z0:vt>
gseq_z2irmap1_lstrm(xs: !xs, ys: !ys): strm_vt(z0)
//
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
<z0:vt>
gseq_z2irmap0_lstrq(xs: ~xs, ys: ~ys): strq_vt(z0)
fun
<xs:vt>
<x0:vt>
<ys:vt>
<y0:vt>
<z0:vt>
gseq_z2irmap1_lstrq(xs: !xs, ys: !ys): strq_vt(z0)
//
#symload z2irmap0_llist with gseq_z2irmap0_llist of 0100
#symload z2irmap1_llist with gseq_z2irmap1_llist of 0100
#symload z2irmap0_lstrm with gseq_z2irmap0_lstrm of 0100
#symload z2irmap1_lstrm with gseq_z2irmap1_lstrm of 0100
#symload z2irmap0_lstrq with gseq_z2irmap0_lstrq of 0100
#symload z2irmap1_lstrq with gseq_z2irmap1_lstrq of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_VT_gseq002_vt.sats] *)
(***********************************************************************)
`,
  "SATS/VT/gsyn000_vt.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sun 28 Jul 2024 04:08:09 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<(*tmp*)>
gs_print$beg0(): void
fun
<(*tmp*)>
gs_print$end0(): void
//
(* ****** ****** *)
//
fun
<(*tmp*)>
gs_print$beg1(): void
fun
<(*tmp*)>
gs_print$end1(): void
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
gs_print0_a1
(x0: ~x0): void
fun
<x0:vt>
<x1:vt>
gs_print0_a2
(~x0, ~x1): void
fun
<x0:vt>
<x1:vt>
<x2:vt>
gs_print0_a3
(~x0, ~x1, ~x2): void
//
fun
<x0:vt>
<x1:vt>
<x2:vt>
<x3:vt>
gs_print0_a4
(~x0, ~x1, ~x2, ~x3): void
//
fun
<x0:vt>
<x1:vt>
<x2:vt>
<x3:vt>
<x4:vt>
gs_print0_a5
(~x0, ~x1, ~x2, ~x3, ~x4): void
//
fun
<x0:vt>
<x1:vt>
<x2:vt>
<x3:vt>
<x4:vt>
<x5:vt>
gs_print0_a6
(~x0, ~x1, ~x2, ~x3, ~x4, ~x5): void
//
fun
<x0:vt>
<x1:vt>
<x2:vt>
<x3:vt>
<x4:vt>
<x5:vt>
<x6:vt>
gs_print0_a7
(~x0, ~x1, ~x2, ~x3, ~x4, ~x5, ~x6): void
//
fun
<x0:vt>
<x1:vt>
<x2:vt>
<x3:vt>
<x4:vt>
<x5:vt>
<x6:vt>
<x7:vt>
gs_print0_a8
(~x0, ~x1, ~x2, ~x3, ~x4, ~x5, ~x6, ~x7): void
//
fun
<x0:vt>
<x1:vt>
<x2:vt>
<x3:vt>
<x4:vt>
<x5:vt>
<x6:vt>
<x7:vt>
<x8:vt>
gs_print0_a9
(~x0, ~x1, ~x2, ~x3, ~x4, ~x5, ~x6, ~x7, ~x8): void
//
fun
<x0:vt>
<x1:vt>
<x2:vt>
<x3:vt>
<x4:vt>
<x5:vt>
<x6:vt>
<x7:vt>
<x8:vt>
<x9:vt>
gs_print0_a10
(~x0, ~x1, ~x2, ~x3, ~x4, ~x5, ~x6, ~x7, ~x8, ~x9): void
//
(* ****** ****** *)
//
fun
<x0:vt>
<x1:vt>
<x2:vt>
<x3:vt>
<x4:vt>
<x5:vt>
<x6:vt>
<x7:vt>
<x8:vt>
<x9:vt>
<x10:vt>
gs_print0_a11
(~x0, ~x1, ~x2, ~x3, ~x4, ~x5, ~x6, ~x7, ~x8, ~x9, ~x10): void
//
fun
<x0:vt>
<x1:vt>
<x2:vt>
<x3:vt>
<x4:vt>
<x5:vt>
<x6:vt>
<x7:vt>
<x8:vt>
<x9:vt>
<x10:vt>
<x11:vt>
gs_print0_a12
(~x0, ~x1, ~x2, ~x3, ~x4, ~x5, ~x6, ~x7, ~x8, ~x9, ~x10, ~x11): void
//
(* ****** ****** *)
//
#symload print0s with gs_print0_a1
#symload print0s with gs_print0_a2
#symload print0s with gs_print0_a3
#symload print0s with gs_print0_a4
#symload print0s with gs_print0_a5
#symload print0s with gs_print0_a6
#symload print0s with gs_print0_a7
#symload print0s with gs_print0_a8
#symload print0s with gs_print0_a9
#symload print0s with gs_print0_a10
#symload print0s with gs_print0_a11
#symload print0s with gs_print0_a12
//
(* ****** ****** *)
(* ****** ****** *)
//
//
fun
<x0:vt>
gs_print1_a1
(x0: !x0): void
fun
<x0:vt>
<x1:vt>
gs_print1_a2
(!x0, !x1): void
fun
<x0:vt>
<x1:vt>
<x2:vt>
gs_print1_a3
(!x0, !x1, !x2): void
//
fun
<x0:vt>
<x1:vt>
<x2:vt>
<x3:vt>
gs_print1_a4
(!x0, !x1, !x2, !x3): void
//
fun
<x0:vt>
<x1:vt>
<x2:vt>
<x3:vt>
<x4:vt>
gs_print1_a5
(!x0, !x1, !x2, !x3, !x4): void
//
fun
<x0:vt>
<x1:vt>
<x2:vt>
<x3:vt>
<x4:vt>
<x5:vt>
gs_print1_a6
(!x0, !x1, !x2, !x3, !x4, !x5): void
//
fun
<x0:vt>
<x1:vt>
<x2:vt>
<x3:vt>
<x4:vt>
<x5:vt>
<x6:vt>
gs_print1_a7
(!x0, !x1, !x2, !x3, !x4, !x5, !x6): void
//
fun
<x0:vt>
<x1:vt>
<x2:vt>
<x3:vt>
<x4:vt>
<x5:vt>
<x6:vt>
<x7:vt>
gs_print1_a8
(!x0, !x1, !x2, !x3, !x4, !x5, !x6, !x7): void
//
fun
<x0:vt>
<x1:vt>
<x2:vt>
<x3:vt>
<x4:vt>
<x5:vt>
<x6:vt>
<x7:vt>
<x8:vt>
gs_print1_a9
(!x0, !x1, !x2, !x3, !x4, !x5, !x6, !x7, !x8): void
//
fun
<x0:vt>
<x1:vt>
<x2:vt>
<x3:vt>
<x4:vt>
<x5:vt>
<x6:vt>
<x7:vt>
<x8:vt>
<x9:vt>
gs_print1_a10
(!x0, !x1, !x2, !x3, !x4, !x5, !x6, !x7, !x8, !x9): void
//
(* ****** ****** *)
//
fun
<x0:vt>
<x1:vt>
<x2:vt>
<x3:vt>
<x4:vt>
<x5:vt>
<x6:vt>
<x7:vt>
<x8:vt>
<x9:vt>
<x10:vt>
gs_print1_a11
(!x0, !x1, !x2, !x3, !x4, !x5, !x6, !x7, !x8, !x9, !x10): void
//
fun
<x0:vt>
<x1:vt>
<x2:vt>
<x3:vt>
<x4:vt>
<x5:vt>
<x6:vt>
<x7:vt>
<x8:vt>
<x9:vt>
<x10:vt>
<x11:vt>
gs_print1_a12
(!x0, !x1, !x2, !x3, !x4, !x5, !x6, !x7, !x8, !x9, !x10, !x11): void
//
(* ****** ****** *)
//
#symload print1s with gs_print1_a1
#symload print1s with gs_print1_a2
#symload print1s with gs_print1_a3
#symload print1s with gs_print1_a4
#symload print1s with gs_print1_a5
#symload print1s with gs_print1_a6
#symload print1s with gs_print1_a7
#symload print1s with gs_print1_a8
#symload print1s with gs_print1_a9
#symload print1s with gs_print1_a10
#symload print1s with gs_print1_a11
#symload print1s with gs_print1_a12
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_VT_gsyn000_vt.sats] *)
(***********************************************************************)
`,
  "SATS/VT/list000_vt.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon 08 Jul 2024 04:08:25 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
list_vt_nil_
{a:vt}(): list_vt(a,0)
fun
<a:vt>
list_vt_cons_
{n:i0}
(
x0: (a),
xs: list_vt(a,n)): list_vt(a,n+1)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
list_vt_nilq1
{a:t0}{n:i0}
(xs: !list_vt(a,n)): bool(n=0)
fun<>
list_vt_consq1
{a:t0}{n:i0}
(xs: !list_vt(a,n)): bool(n>0)
//
#symload
nilq1 with list_vt_nilq1 of 1000
#symload
consq1 with list_vt_consq1 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:vt>
list_vt_head0
{n:i0|n>0}
(xs: ~list_vt(a,n)): (  a  )
fun
<a:vt>
list_vt_head1
{n:i0|n>0}
(xs: !list_vt(a,n)): (  a  )
fun
<a:vt>
list_vt_tail0
{n:i0|n>0}
(xs: ~list_vt(a,n)): list_vt(a,n-1)
fun
<a:vt>
list_vt_tail1
{n:i0|n>0}
(xs: !list_vt(a,n)): list_vt(a,n-1)
//
#symload head0 with list_vt_head0 of 1000
#symload head1 with list_vt_head1 of 1000
#symload tail0 with list_vt_tail0 of 1000
#symload tail1 with list_vt_tail1 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-08:
Thu Jan  8 11:32:41 AM EST 2026
*)
//
fun
<a:vt>
list_vt_make(): list_vt(a)
fun<>
list_vt_make'len((*0*)): nint
(*
g_make<list_vt(a)>=list_vt_make<a>
*)
//
(* ****** ****** *)
//
fun
<a:vt>
list_vt_make_1val
(x1: a): list_vt(a,1)
fun
<a:vt>
list_vt_make_2val
(x1: a, x2: a): list_vt(a,2)
fun
<a:vt>
list_vt_make_3val
(x1: a
,x2: a, x3: a): list_vt(a,3)
//
(* ****** ****** *)
//
#symload
list_vt_sing
with list_vt_make_1val//of 1000
#symload
list_vt_pair
with list_vt_make_2val//of 1000
//
#symload
list_vt_1val
with list_vt_make_1val//of 1000
#symload
list_vt_2val
with list_vt_make_2val//of 1000
#symload
list_vt_3val
with list_vt_make_3val//of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:vt>
list_vt_make_nfun
{n:nat}
(n0: sint(n)
,f0: nintlt(n)->(a)): list_vt(a,n)
//
(* ****** ****** *)
(* ****** ****** *)
//
#symload
list_vt with list_vt_make_nfun
#symload
list_vt_nfun with list_vt_make_nfun
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
list_vt_length0
{n0:i0}
(xs: ~list_vt(x0,n0)): sint(n0)
//
fun
<x0:vt>
list_vt_length1
{n0:i0}
(xs: !list_vt(x0,n0)): sint(n0)
//
#symload
length0 with list_vt_length0 of 1000
#symload
length1 with list_vt_length1 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
list_vt_free
 {n0:i0}
(xs: ~list_vt(x0,n0)): void
//
#symload free with list_vt_free of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
list_vt_copy
 {n0:i0}
( xs
: !list_vt(x0,n0)): list_vt(x0,n0)
//
#symload copy with list_vt_copy of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
list_vt_append0
{n1,n2:i0}
( xs
: ~list_vt(x0,n1)
, ys
: ~list_vt(x0,n2)): list_vt(x0,n1+n2)
fun
<x0:vt>
list_vt_append00
{n1,n2:i0}
( xs
: ~list_vt(x0,n1)
, ys
: ~list_vt(x0,n2)): list_vt(x0,n1+n2)
//
fun
<x0:vt>
list_vt_append10
{n1,n2:i0}
( xs
: !list_vt(x0,n1)
, ys
: ~list_vt(x0,n2)): list_vt(x0,n1+n2)
//
(* ****** ****** *)
//
#symload
append0 with list_vt_append0 of 1000
#symload
append00 with list_vt_append00 of 1000
#symload
append10 with list_vt_append10 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
list_vt_reverse0
{n0:i0}
(xs: ~list_vt(x0,n0)): list_vt(x0,n0)
fun
<x0:vt>
list_vt_reverse1
{n0:i0}
(xs: !list_vt(x0,n0)): list_vt(x0,n0)
//
#symload
reverse0 with list_vt_reverse0 of 1000
#symload
reverse1 with list_vt_reverse1 of 1000
//
(* ****** ****** *)
//
fun
<x0:vt>
list_vt_rappend0
{n1,n2:i0}
( xs
: ~list_vt(x0,n1)
, ys
: ~list_vt(x0,n2)): list_vt(x0,n1+n2)
fun
<x0:vt>
list_vt_rappend00
{n1,n2:i0}
( xs
: ~list_vt(x0,n1)
, ys
: ~list_vt(x0,n2)): list_vt(x0,n1+n2)
fun
<x0:vt>
list_vt_rappend10
{n1,n2:i0}
( xs
: !list_vt(x0,n1)
, ys
: ~list_vt(x0,n2)): list_vt(x0,n1+n2)
//
#symload
rappend0 with list_vt_rappend0 of 1000
#symload
rappend00 with list_vt_rappend00 of 1000
#symload
rappend10 with list_vt_rappend10 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fcast // fun
GLSEQ_make_list_vt
{a:vt}
(xs: list_vt(a)): GLSEQ(list_vt(a), a)
#symload GLSEQ with GLSEQ_make_list_vt of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-09-04:
Thu Sep  4 12:15:50 AM EDT 2025
*)
fun
<a:vt>
list_vt_mergesort0
{n:i0}(xs: ~list_vt(a, n)): list_vt(a, n)
//
#symload
mergesort0 with list_vt_mergesort0 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-15:
Mon Dec 15 09:27:02 PM EST 2025
*)
//
fun
<x0:vt>
list_vt_make_lstrm
(xs: strm_vt(x0)): list_vt(x0)
fun
<x0:vt>
list_vt_make_lstrq
{n0:i0}
(xs: strq_vt(x0,n0)): list_vt(x0,n0)
//
#symload
list_vt_make with list_vt_make_lstrm
#symload
list_vt_make with list_vt_make_lstrq
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-15:
Mon Dec 15 09:30:34 PM EST 2025
*)
//
fun
<x0:vt>
list_vt_llist$concat0
(xz: list_vt(list_vt(x0))): list_vt(x0)
//
#symload concat0 with list_vt_llist$concat0 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_VT_list000_vt.sats] *)
(***********************************************************************)
`,
  "SATS/VT/list001_vt.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon 08 Jul 2024 04:08:25 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
list_vt_forall0
(xs: ~list_vt(x0)): bool
fun
<x0:vt>
list_vt_forall1
(xs: !list_vt(x0)): bool
//
fun
<x0:vt>
list_vt_rforall0
(xs: ~list_vt(x0)): bool
fun
<x0:vt>
list_vt_rforall1
(xs: !list_vt(x0)): bool
//
fun
<x0:vt>
list_vt_iforall0
(xs: ~list_vt(x0)): bool
fun
<x0:vt>
list_vt_iforall1
(xs: !list_vt(x0)): bool
//
fun
<x0:vt>
list_vt_irforall0
(xs: ~list_vt(x0)): bool
fun
<x0:vt>
list_vt_irforall1
(xs: !list_vt(x0)): bool
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-10-15:
Wed Oct 15 03:05:07 AM EDT 2025
*)
fun
<x0:vt>
list_vt_exists0
(xs: ~list_vt(x0)): bool
fun
<x0:vt>
list_vt_exists1
(xs: !list_vt(x0)): bool
//
fun
<x0:vt>
list_vt_rexists0
(xs: ~list_vt(x0)): bool
fun
<x0:vt>
list_vt_rexists1
(xs: !list_vt(x0)): bool
//
fun
<x0:vt>
list_vt_iexists0
(xs: ~list_vt(x0)): bool
fun
<x0:vt>
list_vt_iexists1
(xs: !list_vt(x0)): bool
//
fun
<x0:vt>
list_vt_irexists0
(xs: ~list_vt(x0)): bool
fun
<x0:vt>
list_vt_irexists1
(xs: !list_vt(x0)): bool
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
list_vt_foritm0
(xs: ~list_vt(x0)): void
fun
<x0:vt>
list_vt_foritm1
(xs: !list_vt(x0)): void
//
fun
<x0:vt>
list_vt_rforitm0
(xs: ~list_vt(x0)): void
fun
<x0:vt>
list_vt_rforitm1
(xs: !list_vt(x0)): void
//
fun
<x0:vt>
list_vt_iforitm0
(xs: ~list_vt(x0)): void
fun
<x0:vt>
list_vt_iforitm1
(xs: !list_vt(x0)): void
fun
<x0:vt>
list_vt_irforitm0
(xs: ~list_vt(x0)): void
fun
<x0:vt>
list_vt_irforitm1
(xs: !list_vt(x0)): void
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
<r0:vt>
list_vt_folditm0
(xs: list_vt(x0), r0: r0): (r0)
fun
<x0:vt>
<r0:vt>
list_vt_rfolditm0
(xs: list_vt(x0), r0: r0): (r0)
fun
<x0:vt>
<r0:vt>
list_vt_ifolditm0
(xs: list_vt(x0), r0: r0): (r0)
fun
<x0:vt>
<r0:vt>
list_vt_irfolditm0
(xs: list_vt(x0), r0: r0): (r0)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
<r0:vt>
list_vt_foldall0
(xs: ~list_vt(x0), r0: r0): (r0)
fun
<x0:vt>
<r0:vt>
list_vt_rfoldall0
(xs: ~list_vt(x0), r0: r0): (r0)
fun
<x0:vt>
<r0:vt>
list_vt_ifoldall0
(xs: ~list_vt(x0), r0: r0): (r0)
fun
<x0:vt>
<r0:vt>
list_vt_irfoldall0
(xs: ~list_vt(x0), r0: r0): (r0)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-04:
Wed 04 Sep 2024 06:29:48 AM EDT
*)
//
fun
<x0:vt>
list_vt_strmize0
(xs: ~list_vt(x0)): strm_vt(x0)
fun
<x0:vt>
list_vt_strqize0
{ln:i0}
(xs: ~list_vt(x0, ln)): strq_vt(x0, ln)
//
#symload
strmize0 with list_vt_strmize0 of 1000
#symload
strqize0 with list_vt_strqize0 of 1000
//
fun
<x0:vt>
list_vt_rstrmize0
(xs: ~list_vt(x0)): strm_vt(x0)
fun
<x0:vt>
list_vt_rstrqize0
{ln:i0}
(xs: ~list_vt(x0, ln)): strq_vt(x0, ln)
//
#symload
rstrmize0 with list_vt_rstrmize0 of 1000
#symload
rstrqize0 with list_vt_rstrqize0 of 1000
//
(* ****** ****** *)
//
fun
<x0:vt>
list_vt_listize0
{ln:i0}
(xs: ~list_vt(x0, ln)): list_vt(x0, ln)
fun
<x0:vt>
list_vt_rlistize0
{ln:i0}
(xs: ~list_vt(x0, ln)): list_vt(x0, ln)
//
#symload
listize0 with list_vt_listize0 of 1000
#symload
rlistize0 with list_vt_rlistize0 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-31:
Wed 31 Jul 2024 03:16:49 AM EDT
*)
fun
<x0:vt>
list_vt_c2hoose0_lstrm
(xs: ~list_vt(x0)): strm_vt@(x0, x0)
fun
<x0:vt>
list_vt_c3hoose0_lstrm
(xs: ~list_vt(x0)): strm_vt@(x0, x0, x0)
//
fun
<x0:vt>
list_vt_nchoose0_lstrm$llist
{ln:i0}
( xs:
~ list_vt(x0)
, n0: sint(ln)): strm_vt(list_vt(x0, ln))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-14:
Sat 14 Sep 2024 03:34:58 PM EDT
*)
//
fun
<x0:vt>
<y0:vt>
list_vt_map0
{ln:i0}
(xs: ~list_vt(x0, ln)): list_vt(y0, ln)
fun
<x0:vt>
<y0:vt>
list_vt_map1
{ln:i0}
(xs: !list_vt(x0, ln)): list_vt(y0, ln)
//
#symload map0 with list_vt_map0 of 1000
#symload map1 with list_vt_map1 of 1000
//
fun
<x0:vt>
<y0:vt>
list_vt_map0$f1un
{ln:i0}
(xs:
~list_vt(x0, ln)
,fopr: (  ~x0  ) -> y0): list_vt(y0, ln)
fun
<x0:vt>
<y0:vt>
list_vt_map1$f1un
{ln:i0}
(xs:
!list_vt(x0, ln)
,fopr: (  !x0  ) -> y0): list_vt(y0, ln)
//
#symload map0$fun with list_vt_map0$f1un of 1000
#symload map1$fun with list_vt_map1$f1un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-14:
Sat 14 Sep 2024 03:34:58 PM EDT
*)
//
fun
<x0:vt>
<y0:vt>
list_vt_maprev0
{ln:i0}
(xs: ~list_vt(x0, ln)): list_vt(y0, ln)
fun
<x0:vt>
<y0:vt>
list_vt_maprev1
{ln:i0}
(xs: !list_vt(x0, ln)): list_vt(y0, ln)
//
#symload maprev0 with list_vt_maprev0 of 1000
#symload maprev1 with list_vt_maprev1 of 1000
//
fun
<x0:vt>
<y0:vt>
list_vt_maprev0$f1un
{ln:i0}
(xs:
~list_vt(x0, ln)
,fopr: (  ~x0  ) -> y0): list_vt(y0, ln)
fun
<x0:vt>
<y0:vt>
list_vt_maprev1$f1un
{ln:i0}
(xs:
!list_vt(x0, ln)
,fopr: (  !x0  ) -> y0): list_vt(y0, ln)
//
#symload maprev0$fun with list_vt_maprev0$f1un of 1000
#symload maprev1$fun with list_vt_maprev1$f1un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-06-01
Sun Jun  1 05:40:20 PM EDT 2025
*)
//
fun
<x0:vt>
<y0:vt>
<e1:vt>
list_vt_map$e1nv0
{ln:i0}
( xs:
~ list_vt(x0, ln), e1: !e1): list_vt(y0, ln)
fun
<x0:vt>
<y0:vt>
<e1:vt>
list_vt_map$e1nv1
{ln:i0}
( xs:
! list_vt(x0, ln), e1: !e1): list_vt(y0, ln)
//
fun
<x0:vt>
<y0:vt>
<e1:vt>
list_vt_map$e1nv0$f2un
{ln:i0}
( xs:
~ list_vt(x0, ln)
, e1: !e1, fopr: (~x0, !e1)->y0): list_vt(y0, ln)
fun
<x0:vt>
<y0:vt>
<e1:vt>
list_vt_map$e1nv1$f2un
{ln:i0}
( xs:
! list_vt(x0, ln)
, e1: !e1, fopr: (!x0, !e1)->y0): list_vt(y0, ln)
//
(* ****** ****** *)
//
#symload map$e1nv0 with list_vt_map$e1nv0 of 1000
#symload map$e1nv1 with list_vt_map$e1nv1 of 1000
#symload map$e1nv0 with list_vt_map$e1nv0$f2un of 1000
#symload map$e1nv1 with list_vt_map$e1nv1$f2un of 1000
(*
HX-2025-09-08:
Mon Sep  8 02:35:01 AM EDT 2025
This conflicts with
list_vt_map0$f2un and list_vt_map1$f2un:
#symload list_vt_map0 with list_vt_map$e1nv0 of 1000
#symload list_vt_map1 with list_vt_map$e1nv1 of 1000
#symload list_vt_map0 with list_vt_map$e1nv0$f2un of 1000
#symload list_vt_map1 with list_vt_map$e1nv1$f2un of 1000
*)
#symload list_vt_map$e1nv0 with list_vt_map$e1nv0$f2un of 1000
#symload list_vt_map$e1nv1 with list_vt_map$e1nv1$f2un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_VT_list001_vt.sats] *)
(***********************************************************************)
`,
  "SATS/VT/lsrt000_vt.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Thu Dec 25 10:09:49 AM EST 2025
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-25:
For sorted linear lists
*)
//
abstbox
lsrt_vt_i0_vx
( a:vt,n:i0 ) == list_vt(a)
(* ****** ****** *)
(* ****** ****** *)
//
fcast
lsrt_vt_decd
{a:vt}
(lsrt_vt(a,n)): list_vt(a,n)
//
fcast
UN_lsrt_vt_encd
{a:vt}
(list_vt(a,n)): lsrt_vt(a,n)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
lsrt_vt_nil
{a:vt}((*nil*)): lsrt_vt(a,0)
//
(* ****** ****** *)
//
fun<>
lsrt_vt_nilq1
{a:vt}{n:i0}
(xs: !lsrt_vt(a,n)): bool(n=0)
fun<>
lsrt_vt_consq1
{a:vt}{n:i0}
(xs: !lsrt_vt(a,n)): bool(n>0)
//
#symload
nilq1 with lsrt_vt_nilq1 of 1000
consq1 with lsrt_vt_consq1 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:vt>
lsrt_vt_head0
{n:i0|n>0}
(xs: ~lsrt_vt(a,n)): (  a  )
fun
<a:vt>
lsrt_vt_head1
{n:i0|n>0}
(xs: !lsrt_vt(a,n)): (  a  )
fun
<a:vt>
lsrt_vt_tail0
{n:i0|n>0}
(xs:
~lsrt_vt(a,n)): lsrt_vt(a,n-1)
fun
<a:vt>
lsrt_vt_tail1
{n:i0|n>0}
(xs:
!lsrt_vt(a,n)): lsrt_vt(a,n-1)
//
#symload
head0 with lsrt_vt_head0 of 1000
#symload
head1 with lsrt_vt_head1 of 1000
#symload
tail0 with lsrt_vt_tail0 of 1000
#symload
tail1 with lsrt_vt_tail1 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:vt>
lsrt_vt_make_1val
(x1: a): lsrt_vt(a,1)
fun
<a:vt>
lsrt_vt_make_2val
(x1: a, x2: a): lsrt_vt(a,2)
fun
<a:vt>
lsrt_vt_make_3val
(x1: a
,x2: a, x3: a): lsrt_vt(a,3)
//
(* ****** ****** *)
//
#symload
lsrt_vt_sing
with lsrt_vt_make_1val//of 1000
#symload
lsrt_vt_pair
with lsrt_vt_make_2val//of 1000
//
#symload
lsrt_vt_1val
with lsrt_vt_make_1val//of 1000
#symload
lsrt_vt_2val
with lsrt_vt_make_2val//of 1000
#symload
lsrt_vt_3val
with lsrt_vt_make_3val//of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:vt>
lsrt_vt_length0
{n:i0}
(xs: ~lsrt_vt(a, n)): sint(n)
fun
<a:vt>
lsrt_vt_length1
{n:i0}
(xs: !lsrt_vt(a, n)): sint(n)
//
#symload
length0 with lsrt_vt_length0 of 1000
#symload
length1 with lsrt_vt_length1 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_VT_lsrt000_vt.sats] *)
(***********************************************************************)
`,
  "SATS/VT/optn000_vt.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon 02 Sep 2024 02:43:08 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
optn_vt_nil_
{a:vt}
((*0*)): optn_vt(a,ff)
//
fun
<a:vt>
optn_vt_cons_
( x: a ): optn_vt(a,tt)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
optn_vt_nilq0
{b0:b0}
( xs :
~ optn_vt(x0,b0)): bool(~b0)
fun<>
optn_vt_nilq1
{x0:vt}
{b0:b0}
( xs :
! optn_vt(x0,b0)): bool(~b0)
//
#symload nilq0 with optn_vt_nilq0 of 1000
#symload nilq1 with optn_vt_nilq1 of 1000
//
(* ****** ****** *)
//
fun
<x0:vt>
optn_vt_consq0
{b0:b0}
( xs:
~ optn_vt(x0,b0)): bool( b0 )
fun<>
optn_vt_consq1
{x0:vt}
{b0:b0}
( xs:
! optn_vt(x0,b0)): bool( b0 )
//
#symload consq0 with optn_vt_consq0 of 1000
#symload consq1 with optn_vt_consq1 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
optn_vt_head0
(xs: ~optn_vt(x0, tt)): (x0)
(*
fun
<x0:vt>
optn_vt_uncons0
(xs: optn_vt(x0, tt)): (x0)
*)
//
#symload head0 with optn_vt_head0 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
optn_vt_length0
{b0:b0}
(xs:
~optn_vt(x0,b0)): sint(b2i(b0))
//
(*
HX-2024-09-07:
This one can be polymorphic:
fun
optn_vt_length1
{x0:vt}
{b0:b0}
(xs:
!optn_vt(x0,b0)): sint(b2i(b0))
*)
fun
<x0:vt>
optn_vt_length1
{b0:b0}
(xs:
!optn_vt(x0,b0)): sint(b2i(b0))
//
#symload length0 with optn_vt_length0 of 1000
#symload length1 with optn_vt_length1 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-22:
Mon Dec 22 12:13:25 PM EST 2025
*)
//
fun
<x0:vt>
optn_vt_free
 {b0:b0}
(xs: ~optn_vt(x0,b0)): void
//
#symload free with optn_vt_free of 1000
//
(* ****** ****** *)
//
fun
<x0:vt>
optn_vt_copy
 {b0:b0}
( xs
: !optn_vt(x0,b0)): optn_vt(x0,b0)
//
#symload copy with optn_vt_copy of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_VT_optn000_vt.sats] *)
(***********************************************************************)
`,
  "SATS/VT/optn001_vt.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Fri 06 Sep 2024 11:55:56 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
optn_vt_forall0
(xs: ~optn_vt(x0)): bool
//
fun
<x0:vt>
optn_vt_rforall0
(xs: ~optn_vt(x0)): bool
//
fun
<x0:vt>
optn_vt_iforall0
(xs: ~optn_vt(x0)): bool
//
fun
<x0:vt>
optn_vt_irforall0
(xs: ~optn_vt(x0)): bool
//
(* ****** ****** *)
(* ****** ****** *)
//
//
(*
HX-2024-09-14:
Sat 14 Sep 2024 03:34:58 PM EDT
*)
//
fun
<x0:vt>
<y0:vt>
optn_vt_map0
{ln:b0}
(xs: ~optn_vt(x0, ln)): optn_vt(y0, ln)
fun
<x0:vt>
<y0:vt>
optn_vt_map1
{ln:b0}
(xs: !optn_vt(x0, ln)): optn_vt(y0, ln)
//
#symload map0 with optn_vt_map0 of 1000
#symload map1 with optn_vt_map1 of 1000
//
fun
<x0:vt>
<y0:vt>
optn_vt_map0$f1un
{ln:b0}
(xs:
~optn_vt(x0, ln)
,fopr: (  ~x0  ) -> y0): optn_vt(y0, ln)
fun
<x0:vt>
<y0:vt>
optn_vt_map1$f1un
{ln:b0}
(xs:
!optn_vt(x0, ln)
,fopr: (  !x0  ) -> y0): optn_vt(y0, ln)
//
#symload map0$fun with optn_vt_map0$f1un of 1000
#symload map1$fun with optn_vt_map1$f1un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-06-01
Sun Jun  1 06:34:00 PM EDT 2025
*)
//
fun
<x0:vt>
<y0:vt>
<e1:vt>
optn_vt_map$e1nv0
{ln:b0}
( xs:
~ optn_vt(x0, ln), e1: !e1): optn_vt(y0, ln)
fun
<x0:vt>
<y0:vt>
<e1:vt>
optn_vt_map$e1nv1
{ln:b0}
( xs:
! optn_vt(x0, ln), e1: !e1): optn_vt(y0, ln)
//
fun
<x0:vt>
<y0:vt>
<e1:vt>
optn_vt_map$e1nv0$f2un
{ln:b0}
( xs:
~ optn_vt(x0, ln)
, e1: !e1, fopr: (~x0, !e1)->y0): optn_vt(y0, ln)
fun
<x0:vt>
<y0:vt>
<e1:vt>
optn_vt_map$e1nv1$f2un
{ln:b0}
( xs:
! optn_vt(x0, ln)
, e1: !e1, fopr: (!x0, !e1)->y0): optn_vt(y0, ln)
//
(* ****** ****** *)
//
#symload map$e1nv0 with optn_vt_map$e1nv0 of 1000
#symload map$e1nv1 with optn_vt_map$e1nv1 of 1000
#symload map$e1nv0 with optn_vt_map$e1nv0$f2un of 1000
#symload map$e1nv1 with optn_vt_map$e1nv1$f2un of 1000
(*
HX-2025-09-08:
Mon Sep  8 02:35:01 AM EDT 2025
This conflicts with
optn_vt_map0$f2un and optn_vt_map1$f2un:
#symload optn_vt_map0 with optn_vt_map$e1nv0 of 1000
#symload optn_vt_map1 with optn_vt_map$e1nv1 of 1000
#symload optn_vt_map0 with optn_vt_map$e1nv0$f2un of 1000
#symload optn_vt_map1 with optn_vt_map$e1nv1$f2un of 1000
*)
#symload optn_vt_map$e1nv0 with optn_vt_map$e1nv0$f2un of 1000
#symload optn_vt_map$e1nv1 with optn_vt_map$e1nv1$f2un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_VT_optn001_vt.sats] *)
(***********************************************************************)
`,
  "SATS/VT/strm000_vt.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon 08 Jul 2024 12:09:13 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
strm_vt_nil
{a:vt}(): strm_vt(a)
fun<>
strq_vt_nil
{a:vt}(): strq_vt(a,0)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:vt>
strm_vt_sing
( x0: (a) ): strm_vt(a)
fun
<a:vt>
strq_vt_sing
( x0: (a) ): strq_vt(a, 1)
//
fun
<x0:vt>
strmcon_vt_sing
(x0: x0): strmcon_vt(x0)
fun
<x0:vt>
strqcon_vt_sing
(x0: x0): strqcon_vt(x0, 1)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:vt>
strm_vt_cons
(
x0: (a),
xs: strm_vt(a)): strm_vt(a)
fun
<a:vt>
strq_vt_cons
{n:i0}
(
x0: (a),
xs: strq_vt(a,n)): strq_vt(a,n+1)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:vt>
strm_vt_free
(~strm_vt(a)): ( void )
fun
<a:vt>
strq_vt_free
(~strq_vt(a)): ( void )
//
fun
<a:vt>
strm_vt_eval
(~strm_vt(a)): strmcon_vt(a)
fun
<a:vt>
strq_vt_eval
(~strm_vt(a)): strqcon_vt(a)
//
#symload
free with strm_vt_free of 1000
#symload
free with strq_vt_free of 1000
#symload
eval with strm_vt_eval of 1000
#symload
eval with strq_vt_eval of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-08:
Thu Jan  8 12:13:02 PM EST 2026
*)
//
fun
<a:vt>
strm_vt_make(): strm_vt(a)
fun<>
strm_vt_make'len((*0*)): nint
(*
g_make<strm_vt(a)>=strm_vt_make<a>
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
strm_vt_head0
(xs: strm_vt(x0)): (x0)
fun
<x0:vt>
strm_vt_tail0
(xs: strm_vt(x0)): strm_vt(x0)
//
#symload
head0 with strm_vt_head0 of 1000
#symload
tail0 with strm_vt_tail0 of 1000
//
(* ****** ****** *)
//
fun
<x0:vt>
strm_vt_head$opt0
(xs: strm_vt(x0)): optn_vt(x0)
fun
<x0:vt>
strm_vt_tail$opt0
(xs: strm_vt(x0)): optn_vt(strm_vt(x0))
//
#symload
head$opt0 with strm_vt_head$opt0 of 1000
#symload
tail$opt0 with strm_vt_tail$opt0 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
strm_vt_length0
(xs: strm_vt(x0)): (nint)
fun
<x0:vt>
strq_vt_length0
{n0:i0}
(xs: strq_vt(x0,n0)): sint(n0)
//
#symload
length0 with strm_vt_length0 of 1000
#symload
length0 with strq_vt_length0 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
strm_vt_append0
( xs: strm_vt(x0)
, ys: strm_vt(x0)): strm_vt(x0)
fun
<x0:vt>
strm_vt_append00
( xs: strm_vt(x0)
, ys: strm_vt(x0)): strm_vt(x0)
//
fun
<x0:vt>
strq_vt_append00
{n1,n2:i0}
( xs: strq_vt(x0,n1)
, ys: strq_vt(x0,n2)): strq_vt(x0,n1+n2)
//
(* ****** ****** *)
//
#symload
append00 with strm_vt_append00 of 1000
#symload
append00 with strq_vt_append00 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
strm_vt_prepend00
( xs: strm_vt(x0)
, ys: strm_vt(x0)): strm_vt(x0)
fun
<x0:vt>
strq_vt_prepend00
{n1,n2:i0}
( xs: strq_vt(x0,n1)
, ys: strq_vt(x0,n2)): strq_vt(x0,n2+n1)
//
#symload
prepend00 with strm_vt_prepend00 of 1000
#symload
prepend00 with strq_vt_prepend00 of 1000
//
(* ****** ****** *)
//
(*
(*
HX-2026-01-08:
This is the new naming style
Thu Jan  8 09:48:03 AM EST 2026
*)
fun
<x0:vt>
strm_vt_llist0$prepend0
( xs: strm_vt(x0)
, ys: list_vt(x0)): strm_vt(x0)
fun
<x0:vt>
strm_vt_lstrq0$prepend0
( xs: strm_vt(x0)
, ys: strq_vt(x0)): strm_vt(x0)
*)
//
fun
<x0:vt>
strm_vt_prepend0__llist0
( xs: strm_vt(x0)
, ys: list_vt(x0)): strm_vt(x0)
fun
<x0:vt>
strm_vt_prepend0__lstrq0
( xs: strm_vt(x0)
, ys: strq_vt(x0)): strm_vt(x0)
//
(*
#symload
prepend00 with strm_vt_llist0$prepend0
#symload
prepend00 with strm_vt_lstrq0$prepend0
*)
#symload
prepend00 with strm_vt_prepend0__llist0
#symload
prepend00 with strm_vt_prepend0__lstrq0
//
(* ****** ****** *)
//
(*
(*
HX-2026-01-08:
This is the new naming style
Thu Jan  8 09:48:03 AM EST 2026
*)
fun
<x0:vt>
strq_vt_llist0$prepend0
{n1,n2:i0}
( xs
: strq_vt(x0,n1)
, ys
: list_vt(x0,n2)): strq_vt(x0,n2+n1)
#symload
prepend00 with strq_vt_llist0$prepend0
*)
fun
<x0:vt>
strq_vt_prepend0__llist0
{n1,n2:i0}
(
xs: strq_vt(x0,n1),
ys: list_vt(x0,n2)): strq_vt(x0,n2+n1)
#symload
prepend00 with strq_vt_prepend0__llist0
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-24:
Wed 24 Jul 2024 08:52:25 PM EDT
*)
//
fun
<x0:vt>
<ys:vt>
g_make_lstrq(strq_vt(x0)): (ys)
fun
<x0:vt>
<ys:vt>
g_make_lstrm(strm_vt(x0)): (ys)
//
(*
fun
<x0:vt>
<ys:vt>
<y0:vt>
gseq_make_lstrm(strm_vt(x0)): (ys)
fun
<x0:vt>
<ys:vt>
<y0:vt>
gseq_make_lstrq(strq_vt(x0)): (ys)
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-13:
concat0 -> lstrm$concat0
Sat Dec 13 11:42:48 PM EST 2025
*)
//
fun
<x0:vt>
strm_vt_lstrm$concat0
( xss
: ~strm_vt(strm_vt(x0))): strm_vt(x0)
//
#symload
concat0 with strm_vt_lstrm$concat0 of 1000
#symload
lstrm$concat0 with strm_vt_lstrm$concat0 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-15:
These one are in
[prelude/list000.sats]!
Mon Dec 15 04:42:34 PM EST 2025
fun
<x0:t0>
list_make_lstrm
(xs: strm_vt(x0)): list(x0)
fun
<x0:t0>
list_make_lstrq
{ln:i0}
(xs: strq_vt(x0, ln)): list(x0, ln)
//
#symload list with list_make_lstrm of 1000
#symload list with list_make_lstrq of 1000
*)
//
(*
HX-2025-12-15:
These ones are in
[prelude/list000_vt.sats]!
Mon Dec 15 04:42:34 PM EST 2025
fun
<x0:vt>
list_vt_make_lstrm
(xs: strm_vt(x0)): list_vt(x0)
fun
<x0:vt>
list_vt_make_lstrq
{ln:i0}
(xs: strq_vt(x0, ln)): list_vt(x0, ln)
//
#symload list_vt with list_vt_make_lstrm of 1000
#symload list_vt with list_vt_make_lstrq of 1000
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-21:
Sun Dec 21 07:15:47 PM EST 2025
*)
fun<>
strm_vt_beg(): strn
fun<>
strm_vt_end(): strn
fun<>
strm_vt_sep(): strn
fun<>
strm_vt_rst(): strn
//
fun
<x0:vt>
strm_vt_print0(xs: strm_vt(x0)): void
//
fun
<x0:vt>
strm_vt_all$print0(xs: strm_vt(x0)): void
//
fun<>
strm_vt_print$len(): sint
fun<>
strm_vt_print'len(): sint
fun
<x0:vt>
strm_vt_len$print0(xs: strm_vt(x0), ln: sint): void
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-26:
Fri Dec 26 05:13:01 PM EST 2025
*)
//
fun
<x0:vt>
strm_vt_ndrop
( xs
: strm_vt(x0), n0: nint): strm_vt(x0)
fun
<x0:vt>
strm_vt_ntake
( xs
: strm_vt(x0), n0: nint): strm_vt(x0)
//
#symload ndrop with strm_vt_ndrop of 1000
#symload ntake with strm_vt_ntake of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_VT_strn000_vt.sats] *)
(***********************************************************************)
`,
  "SATS/VT/strm001_vt.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Wed 10 Jul 2024 07:53:15 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#typedef ni = nint
#typedef si = sint
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
strm_vt_forall0
(xs: strm_vt(x0)): bool
fun
<x0:vt>
strm_vt_iforall0
(xs: strm_vt(x0)): bool
//
#symload
forall0 with strm_vt_forall0 of 1000
#symload
iforall0 with strm_vt_iforall0 of 1000
//
fun
<x0:vt>
strm_vt_forall0$f1un
( xs: strm_vt(x0)
, test: (~x0) -> bool): bool
//
#symload
forall0 with strm_vt_forall0$f1un of 1000
#symload
forall0$fun with strm_vt_forall0$f1un of 1000
#symload
strm_vt_forall0 with strm_vt_forall0$f1un of 1000
//
fun
<x0:vt>
strm_vt_iforall0$f2un
( xs: strm_vt(x0)
, test: (ni,~x0) -> bool): bool
//
#symload
iforall0 with strm_vt_iforall0$f2un of 1000
#symload
iforall0$fun with strm_vt_iforall0$f2un of 1000
#symload
strm_vt_iforall0 with strm_vt_iforall0$f2un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
strm_vt_foritm0
(xs: strm_vt(x0)): void
fun
<x0:vt>
strm_vt_iforitm0
(xs: strm_vt(x0)): void
//
#symload
foritm0 with strm_vt_foritm0 of 1000
#symload
iforitm0 with strm_vt_iforitm0 of 1000
//
fun
<x0:vt>
strm_vt_foritm0$f1un
( xs: strm_vt(x0)
, work: (~x0) -> void): void
//
#symload
foritm0 with strm_vt_foritm0$f1un of 1000
#symload
foritm0$fun with strm_vt_foritm0$f1un of 1000
#symload
strm_vt_foritm0 with strm_vt_foritm0$f1un of 1000
//
fun
<x0:vt>
strm_vt_iforitm0$f2un
( xs: strm_vt(x0)
, work: (ni,~x0) -> void): void
//
#symload
iforitm0 with strm_vt_iforitm0$f2un of 1000
#symload
iforitm0$fun with strm_vt_iforitm0$f2un of 1000
#symload
strm_vt_iforitm0 with strm_vt_iforitm0$f2un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
<r0:vt>
strm_vt_folditm0
(xs: strm_vt(x0), r0: r0): (r0)
fun
<x0:vt>
<r0:vt>
strm_vt_ifolditm0
(xs: strm_vt(x0), r0: r0): (r0)
//
#symload
folditm0 with strm_vt_folditm0 of 1000
#symload
ifolditm0 with strm_vt_ifolditm0 of 1000
//
fun
<x0:vt>
<r0:vt>
strm_vt_folditm0$f2un
( xs
: strm_vt(x0), r0: r0
, fopr: (r0, ~x0) -> (r0)): (r0)
//
#symload
folditm0 with strm_vt_folditm0$f2un of 1000
#symload
folditm0$fun with strm_vt_folditm0$f2un of 1000
#symload
strm_vt_folditm0 with strm_vt_folditm0$f2un of 1000
//
fun
<x0:vt>
<r0:vt>
strm_vt_ifolditm0$f3un
( xs
: strm_vt(x0), r0: r0
, fopr: (r0, ni, ~x0) -> (r0)): (r0)
//
#symload
ifolditm0 with strm_vt_ifolditm0$f3un of 1000
#symload
ifolditm0$fun with strm_vt_ifolditm0$f3un of 1000
#symload
strm_vt_ifolditm0 with strm_vt_ifolditm0$f3un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
<r0:vt>
strm_vt_foldall0
(xs: strm_vt(x0), r0: r0): (r0)
fun
<x0:vt>
<r0:vt>
strm_vt_ifoldall0
(xs: strm_vt(x0), r0: r0): (r0)
//
fun
<x0:vt>
<r0:vt>
strm_vt_foldall0$f2un
( xs
: strm_vt(x0), r0: r0
, fopr: (r0, ~x0) -> (bool,r0)): (r0)
//
#symload
foldall0 with strm_vt_foldall0$f2un of 1000
#symload
foldall0$fun with strm_vt_foldall0$f2un of 1000
#symload
strm_vt_foldall0 with strm_vt_foldall0$f2un of 1000
//
fun
<x0:vt>
<r0:vt>
strm_vt_ifoldall0$f3un
( xs
: strm_vt(x0), r0: r0
, fopr: (ni, r0, ~x0) -> (bool,r0)): (r0)
//
#symload
ifoldall0 with strm_vt_ifoldall0$f3un of 1000
#symload
ifoldall0$fun with strm_vt_ifoldall0$f3un of 1000
#symload
strm_vt_ifoldall0 with strm_vt_ifoldall0$f3un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
<y0:vt>
strm_vt_map0
(xs: strm_vt(x0)): strm_vt(y0)
fun
<x0:vt>
<y0:vt>
strq_vt_map0
{ln:i0}
(xs: strq_vt(x0,ln)): strq_vt(y0,ln)
//
(* ****** ****** *)
//
fun
<x0:vt>
<y0:vt>
strm_vt_imap0
(xs: strm_vt(x0)): strm_vt(y0)
fun
<x0:vt>
<y0:vt>
strq_vt_imap0
{ln:i0}
(xs: strq_vt(x0,ln)): strq_vt(y0,ln)
//
#symload map0 with strm_vt_map0 of 1000
#symload map0 with strq_vt_map0 of 1000
#symload imap0 with strm_vt_imap0 of 1000
#symload imap0 with strq_vt_imap0 of 1000
//
(* ****** ****** *)
//
fun
<x0:vt>
<y0:vt>
strm_vt_map0$f1un
( xs: strm_vt(x0)
, fopr: (x0) -> (y0)): strm_vt(y0)
fun
<x0:vt>
<y0:vt>
strq_vt_map0$f1un
{ln:i0}
( xs: strq_vt(x0,ln)
, fopr: (x0) -> (y0)): strq_vt(y0,ln)
//
fun
<x0:vt>
<y0:vt>
strm_vt_imap0$f1un
( xs: strm_vt(x0)
, fopr: (ni, x0) -> (y0)): strm_vt(y0)
fun
<x0:vt>
<y0:vt>
strq_vt_imap0$f1un
{ln:i0}
( xs: strq_vt(x0,ln)
, fopr: (ni, x0) -> (y0)): strq_vt(y0,ln)
//
#symload map0 with strm_vt_map0$f1un of 1000
#symload map0 with strq_vt_map0$f1un of 1000
#symload map0$fun with strm_vt_map0$f1un of 1000
#symload map0$fun with strq_vt_map0$f1un of 1000
#symload strm_vt_map0 with strm_vt_map0$f1un of 1000
#symload strm_vt_map0 with strq_vt_map0$f1un of 1000
//
#symload imap0 with strm_vt_imap0$f1un of 1000
#symload imap0 with strq_vt_imap0$f1un of 1000
#symload imap0$fun with strm_vt_imap0$f1un of 1000
#symload imap0$fun with strq_vt_imap0$f1un of 1000
#symload strm_vt_imap0 with strm_vt_imap0$f1un of 1000
#symload strm_vt_imap0 with strq_vt_imap0$f1un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
strm_vt_filter0
(xs: strm_vt(x0)): strm_vt(x0)
fun
<x0:vt>
strq_vt_filter0
{ln:i0}
(xs: strq_vt(x0,ln)): strqlte_vt(x0,ln)
//
fun
<x0:vt>
strm_vt_ifilter0
(xs: strm_vt(x0)): strm_vt(x0)
fun
<x0:vt>
strq_vt_ifilter0
{ln:i0}
(xs: strq_vt(x0,ln)): strqlte_vt(x0,ln)
//
#symload filter0 with strm_vt_filter0 of 1000
#symload filter0 with strq_vt_filter0 of 1000
#symload ifilter0 with strm_vt_ifilter0 of 1000
#symload ifilter0 with strq_vt_ifilter0 of 1000
//
(* ****** ****** *)
//
fun
<x0:vt>
strm_vt_filter0$f1un
( xs: strm_vt(x0)
, test: (!x0) -> bool): strm_vt(x0)
#symload filter0 with strm_vt_filter0$f1un of 1000
#symload filter0$fun with strm_vt_filter0$f1un of 1000
#symload strm_vt_filter0 with strm_vt_filter0$f1un of 1000
//
fun
<x0:vt>
strm_vt_ifilter0$f2un
( xs: strm_vt(x0)
, test: (ni,!x0) -> bool): strm_vt(x0)
#symload ifilter0 with strm_vt_ifilter0$f2un of 1000
#symload ifilter0$fun with strm_vt_ifilter0$f2un of 1000
#symload strm_vt_ifilter0 with strm_vt_ifilter0$f2un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
<y0:vt>
strm_vt_mapoptn0
(xs: ~strm_vt(x0)): strm_vt(y0)
fun
<x0:vt>
<y0:vt>
strq_vt_mapoptn0
(xs: ~strq_vt(x0)): strq_vt(y0)
//
#symload mapoptn0 with strm_vt_mapoptn0 of 1000
#symload mapoptn0 with strq_vt_mapoptn0 of 1000
//
fun
<x0:vt>
<y0:vt>
strm_vt_maplist0
(xs: ~strm_vt(x0)): strm_vt(y0)
fun
<x0:vt>
<y0:vt>
strq_vt_maplist0
(xs: ~strq_vt(x0)): strq_vt(y0)
//
#symload maplist0 with strm_vt_maplist0 of 1000
#symload maplist0 with strq_vt_maplist0 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-24:
Wed 24 Jul 2024 07:35:00 PM EDT
*)
fun
<x0:vt>
<r0:vt>
strm_vt_scanitm0
(xs: ~strm_vt(x0), r0: r0): strm_vt(r0)
fun
<x0:vt>
<r0:vt>
strq_vt_scanitm0
{n0:i0}
(xs:
~strq_vt(x0,n0), r0: r0): strq_vt(r0,n0+1)
//
#symload scanitm0 with strm_vt_scanitm0 of 1000
#symload scanitm0 with strq_vt_scanitm0 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-28:
Sun 28 Jul 2024 01:52:55 PM EDT
*)
//
(* ****** ****** *)
//
(*
fun
<x0:vt>
strm_vt_strqize0
(xs: strm_vt(x0)): strq_vt(x0)
#symload strqize0 with strm_vt_strqize0 of 1000
*)
//
(* ****** ****** *)
//
fun
<x0:vt>
strm_vt_listize0
(xs: strm_vt(x0)): list_vt(x0)
fun
<x0:vt>
strq_vt_listize0
{n0:i0}
(xs: strq_vt(x0,n0)): list_vt(x0,n0)
//
fun
<x0:vt>
strm_vt_rlistize0
(xs: strm_vt(x0)): list_vt(x0)
fun
<x0:vt>
strq_vt_rlistize0
{n0:i0}
(xs: strq_vt(x0,n0)): list_vt(x0,n0)
//
#symload listize0 with strm_vt_listize0 of 1000
#symload listize0 with strq_vt_listize0 of 1000
#symload rlistize0 with strm_vt_rlistize0 of 1000
#symload rlistize0 with strq_vt_rlistize0 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
strm_vt_a1rfize0
(xs: strm_vt(x0)): a1rf_vt(x0)
fun
<x0:vt>
strq_vt_a1rfize0
{n0:i0}
(xs: strq_vt(x0,n0)): a1rf_vt(x0,n0)
//
#symload a1rfize0 with strm_vt_a1rfize0 of 1000
#symload a1rfize0 with strq_vt_a1rfize0 of 1000
//
(* ****** ****** *)
//
fun
<x0:vt>
strm_vt_a1szize0
(xs: strm_vt(x0)): a1sz_vt(x0)
fun
<x0:vt>
strq_vt_a1szize0
{n0:i0}
(xs: strq_vt(x0,n0)): a1sz_vt(x0,n0)
//
#symload a1szize0 with strm_vt_a1szize0 of 1000
#symload a1szize0 with strq_vt_a1szize0 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-05-31:
Sat May 31 08:56:05 PM EDT 2025
*)
//
fun
<x0:vt>
<y0:vt>
<e1:vt>
strm_vt_map$e0nv0
(xs: strm_vt(x0), e1: ~e1): strm_vt(y0)
fun
<x0:vt>
<y0:vt>
<e1:vt>
strm_vt_map$e1nv0
(xs: strm_vt(x0), e1: !e1): strm_vt(y0)
//
fun
<x0:vt>
<y0:vt>
<e1:vt>
strq_vt_map$e0nv0
{ln:i0}
(xs: strq_vt(x0,ln), e1: ~e1): strq_vt(y0,ln)
fun
<x0:vt>
<y0:vt>
<e1:vt>
strq_vt_map$e1nv0
{ln:i0}
(xs: strq_vt(x0,ln), e1: !e1): strq_vt(y0,ln)
//
#symload map$e0nv0 with strm_vt_map$e0nv0 of 1000
#symload map$e1nv0 with strm_vt_map$e1nv0 of 1000
#symload map$e0nv0 with strq_vt_map$e0nv0 of 1000
#symload map$e1nv0 with strq_vt_map$e1nv0 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-26:
Fri Dec 26 12:28:51 PM EST 2025
*)
//
fun
<x0:vt>
strm_vt_ord$exists0(xs: strm_vt(x0)): bool
fun
<x0:vt>
strm_vt_ord$iexists0(xs: strm_vt(x0)): bool
//
#symload ord$exists0 with strm_vt_ord$exists0 of 1000
#symload ord$iexists0 with strm_vt_ord$iexists0 of 1000
//
fun
<x0:vt>
strm_vt_ord$exists0$f1un
(xs: strm_vt(x0), tcmp: (~x0) -> sint): bool
//
#symload
ord$exists0 with strm_vt_ord$exists0$f1un of 1000
#symload
ord$exists0$fun with strm_vt_ord$exists0$f1un of 1000
#symload
strm_vt_ord$exists0 with strm_vt_ord$exists0$f1un of 1000
//
fun
<x0:vt>
strm_vt_ord$iexists0$f2un
(xs: strm_vt(x0), tcmp: (ni, ~x0) -> sint): bool
//
#symload
ord$iexists0 with strm_vt_ord$iexists0$f2un of 1000
#symload
ord$iexists0$fun with strm_vt_ord$iexists0$f2un of 1000
#symload
strm_vt_ord$iexists0 with strm_vt_ord$iexists0$f2un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_VT_strm001_vt.sats] *)
(***********************************************************************)
`,
  "SATS/VT/strm002_vt.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Tue 23 Jul 2024 05:28:07 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
<y0:vt>
strm_vt_z2forall0
( xs: ~strm_vt(x0)
, ys: ~strm_vt(y0)): bool//end-of-[fun]
//
fun
<x0:vt>
<y0:vt>
strm_vt_z2iforall0
( xs: ~strm_vt(x0)
, ys: ~strm_vt(y0)): bool//end-of-[fun]
//
#symload
z2forall0 with strm_vt_z2forall0 of 1000
#symload
z2iforall0 with strm_vt_z2iforall0 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
<y0:vt>
strm_vt_z2forcmp0
( xs: ~strm_vt(x0)
, ys: ~strm_vt(y0)): sint//end-of-[fun]
//
fun
<x0:vt>
<y0:vt>
strm_vt_z2iforcmp0
( xs: ~strm_vt(x0)
, ys: ~strm_vt(y0)): sint//end-of-[fun]
//
#symload
z2forcmp0 with strm_vt_z2forcmp0 of 1000
#symload
z2iforcmp0 with strm_vt_z2iforcmp0 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
<y0:vt>
strm_vt_z2foritm0
( xs: ~strm_vt(x0)
, ys: ~strm_vt(y0)): void//end-of-[fun]
//
fun
<x0:vt>
<y0:vt>
strm_vt_z2iforitm0
( xs: ~strm_vt(x0)
, ys: ~strm_vt(y0)): void//end-of-[fun]
//
#symload
z2foritm0 with strm_vt_z2foritm0 of 1000
#symload
z2iforitm0 with strm_vt_z2iforitm0 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
<y0:vt>
<r0:vt>
strm_vt_z2folditm0
(~strm_vt(x0), ~strm_vt(y0), r0): (r0)
fun
<x0:vt>
<y0:vt>
<r0:vt>
strm_vt_z2ifolditm0
(~strm_vt(x0), ~strm_vt(y0), r0): (r0)
//
#symload
z2folditm0 with strm_vt_z2folditm0 of 1000
#symload
z2ifolditm0 with strm_vt_z2ifolditm0 of 1000
//
(* ****** ****** *)
//
fun
<x0:vt>
<y0:vt>
<r0:vt>
strm_vt_z2foldall0
(~strm_vt(x0), ~strm_vt(y0), r0): (r0)
fun
<x0:vt>
<y0:vt>
<r0:vt>
strm_vt_z2ifoldall0
(~strm_vt(x0), ~strm_vt(y0), r0): (r0)
//
#symload
z2foldall0 with strm_vt_z2foldall0 of 1000
#symload
z2ifoldall0 with strm_vt_z2ifoldall0 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
<y0:vt>
<z0:vt>
strm_vt_z2map0
( xs: ~strm_vt(x0)
, ys: ~strm_vt(y0)): strm_vt(z0)//endfun
fun
<x0:vt>
<y0:vt>
<z0:vt>
strm_vt_z2imap0
( xs: ~strm_vt(x0)
, ys: ~strm_vt(y0)): strm_vt(z0)//endfun
//
#symload z2map0 with strm_vt_z2map0 of 1000
#symload z2imap0 with strm_vt_z2imap0 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-24:
Wed 24 Jul 2024 08:25:27 PM EDT
*)
//
fun
<x0:vt>
<y0:vt>
<r0:vt>
strm_vt_z2scanitm0
( xs: ~strm_vt(x0)
, ys: ~strm_vt(y0), r0: r0): strm_vt(r0)
fun
<x0:vt>
<y0:vt>
<r0:vt>
strm_vt_z2iscanitm0
( xs: ~strm_vt(x0)
, ys: ~strm_vt(y0), r0: r0): strm_vt(r0)
//
#symload
z2scanitm0 with strm_vt_z2scanitm0 of 1000
#symload
z2iscanitm0 with strm_vt_z2iscanitm0 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-05:
Mon 05 Aug 2024 07:50:06 PM EDT
*)
//
fun
<x0:vt>
<y0:vt>
strm_vt_z2strmize0
( xs: strm_vt(x0)
, ys: strm_vt(y0)): strm_vt@(x0, y0)
//
fun
<x0:vt>
<y0:vt>
strm_vt_z2listize0
(xs: strm_vt(x0), ys: strm_vt(y0)): list_vt@(x0, y0)
fun
<x0:vt>
<y0:vt>
strm_vt_z2rlistize0
(xs: strm_vt(x0), ys: strm_vt(y0)): list_vt@(x0, y0)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_VT_strm002_vt.sats] *)
(***********************************************************************)
`,
  "SATS/VT/strn000_vt.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon 08 Jul 2024 09:15:20 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#vwtpdef
lstrnllst = list_vt(strn_vt)
#vwtpdef
lstrnlopt = optn_vt(strn_vt)
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
strn_vt_length0
{n0:i0}
(cs: ~strn_vt(n0)): sint(n0)
fun<>
strn_vt_length1
{n0:i0}
(cs: !strn_vt(n0)): sint(n0)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-11:
The 'g' in 'gmake' means
that the argument, which is
the subject, is polymorphic.
*)
fun
<a:t0>
strn_vt_gmake(x: (~a)): strn_vt
fun
<a:vt>
strn_vt_gmake1(x: (!a)): strn_vt
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
strn_vt_make_list
{n0:i0}
(cs: list(cgtz,n0)): strn_vt(n0)
//
fun<>
strn_vt_make_llist
{n0:i0}
( cs
: ~list_vt(cgtz,n0)): strn_vt(n0)
//
fun<>
strn_vt_make_lstrm
{n0:i0}
(
cs: ~strm_vt(cgtz)): strn_vt(*sz*)
fun<>
strn_vt_make_lstrq
{n0:i0}
(
cs: ~strq_vt(cgtz,n0)): strn_vt(n0)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
strn_vt_make1_llist
{n0:i0}
(
cs: !list_vt(cgtz, n0)): strn_vt(n0)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
strn_vt_strmize0
(cs: ~strn_vt): strm_vt(cgtz)
fun<>
strn_vt_strqize0
{n0:i0}
(cs: ~strn_vt(n0)): strq_vt(cgtz, n0)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_VT_strn000_vt.sats] *)
(***********************************************************************)
`,
  "SATS/VT/strx000_vt.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Wed May  7 08:03:12 AM EDT 2025
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:vt>
strx_vt_cons
(
x0: (a),
xs: strx_vt(a)): strx_vt(a)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
strx_vt_free
(xs: strx_vt(x0)): ( void )
fun
<x0:vt>
strx_vt_eval
(xs: strx_vt(x0)): strxcon_vt(x0)
//
#symload free with strx_vt_free of 1000
#symload eval with strx_vt_eval of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
strx_vt_head0
(xs: strx_vt(x0)): (x0)
fun
<x0:vt>
strx_vt_tail0
(xs: strx_vt(x0)): strx_vt(x0)
//
#symload head0 with strx_vt_head0
#symload tail0 with strx_vt_tail0
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
strx_vt_prepend0__llist0
( xs: strx_vt(x0)
, ys: list_vt(x0)): strx_vt(x0)
fun
<x0:vt>
strx_vt_prepend0__lstrm0
( xs: strx_vt(x0)
, ys: strm_vt(x0)): strx_vt(x0)
fun
<x0:vt>
strx_vt_prepend0__lstrq0
( xs: strx_vt(x0)
, ys: strq_vt(x0)): strx_vt(x0)
//
(* ****** ****** *)
(* ****** ****** *)
//
#symload prepend00 with strx_vt_prepend0__llist0
#symload prepend00 with strx_vt_prepend0__lstrm0
#symload prepend00 with strx_vt_prepend0__lstrq0
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-13:
Tue Jan 13 02:42:01 AM EST 2026
*)
fun<>
strx_vt_beg(): strn
fun<>
strx_vt_end(): strn
fun<>
strx_vt_sep(): strn
fun<>
strx_vt_rst(): strn
//
fun
<x0:vt>
strx_vt_print0(xs: strx_vt(x0)): void
//
fun
<x0:vt>
strx_vt_all$print0(xs: strx_vt(x0)): void
//
(*
fun<>
strx_vt_print$len(): sint
*)
fun<>
strx_vt_print'len(): sint
fun
<x0:vt>
strx_vt_len$print0(xs: strx_vt(x0), ln: sint): void
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_VT_strn000_vt.sats] *)
(***********************************************************************)
`,
  "SATS/VT/strx001_vt.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Wed May  7 08:40:39 AM EDT 2025
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#typedef ni = nint
#typedef si = sint
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
strx_vt_strmize0
(
xs: strx_vt(x0)): strm_vt(x0)
//
#symload
strmize0
with strx_vt_strmize0 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
strx_vt_forall0
(xs: strx_vt(x0)): bool
fun
<x0:vt>
strx_vt_iforall0
(xs: strx_vt(x0)): bool
//
#symload
forall0 with strx_vt_forall0 of 1000
#symload
iforall0 with strx_vt_iforall0 of 1000
//
fun
<x0:vt>
strx_vt_forall0$f1un
( xs: strx_vt(x0)
, test: (~x0) -> bool): bool
//
#symload
forall0 with strx_vt_forall0$f1un of 1000
#symload
forall0$fun with strx_vt_forall0$f1un of 1000
#symload
strx_vt_forall0 with strx_vt_forall0$f1un of 1000
//
fun
<x0:vt>
strx_vt_iforall0$f2un
( xs: strx_vt(x0)
, test: (ni,~x0) -> bool): bool
//
#symload
iforall0 with strx_vt_iforall0$f2un of 1000
#symload
iforall0$fun with strx_vt_iforall0$f2un of 1000
#symload
strx_vt_iforall0 with strx_vt_iforall0$f2un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
<y0:vt>
strx_vt_map0
(xs: strx_vt(x0)): strx_vt(y0)
//
fun
<x0:vt>
<y0:vt>
strx_vt_imap0
(xs: strx_vt(x0)): strx_vt(y0)
//
#symload
map0 with strx_vt_map0 of 1000
#symload
imap0 with strx_vt_imap0 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
<y0:vt>
strx_vt_map0$f1un
( xs: strx_vt(x0)
, fopr: (~x0) -> y0): strx_vt(y0)
#symload
map0 with strx_vt_map0$f1un of 1000
#symload
map0$fun with strx_vt_map0$f1un of 1000
#symload
strx_vt_map0 with strx_vt_map0$f1un of 1000
//
fun
<x0:vt>
<y0:vt>
strx_vt_imap0$f1un
( xs: strx_vt(x0)
, fopr: (ni,~x0) -> y0): strx_vt(y0)
#symload
imap0 with strx_vt_imap0$f1un of 1000
#symload
imap0$fun with strx_vt_imap0$f1un of 1000
#symload
strx_vt_imap0 with strx_vt_imap0$f1un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
strx_vt_filter0
(xs: strx_vt(x0)): strx_vt(x0)
fun
<x0:vt>
strx_vt_ifilter0
(xs: strx_vt(x0)): strx_vt(x0)
//
#symload
filter0 with strx_vt_filter0 of 1000
#symload
ifilter0 with strx_vt_ifilter0 of 1000
//
(* ****** ****** *)
//
fun
<x0:vt>
strx_vt_filter0$f1un
( xs: strx_vt(x0)
, test: (!x0) -> bool): strx_vt(x0)
#symload
filter0 with strx_vt_filter0$f1un of 1000
#symload
filter0$fun with strx_vt_filter0$f1un of 1000
#symload
strx_vt_filter0 with strx_vt_filter0$f1un of 1000
//
fun
<x0:vt>
strx_vt_ifilter0$f2un
( xs: strx_vt(x0)
, test: (ni,!x0) -> bool): strx_vt(x0)
#symload
ifilter0 with strx_vt_ifilter0$f2un of 1000
#symload
ifilter0$fun with strx_vt_ifilter0$f2un of 1000
#symload
strx_vt_ifilter0 with strx_vt_ifilter0$f2un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
<y0:vt>
strx_vt_mapoptn0
(xs: ~strx_vt(x0)): strx_vt(y0)
fun
<x0:vt>
<y0:vt>
strx_vt_maplist0
(xs: ~strx_vt(x0)): strx_vt(y0)
#symload
mapoptn0 with strx_vt_mapoptn0 of 1000
#symload
maplist0 with strx_vt_maplist0 of 1000
//
(* ****** ****** *)
//
fun
<x0:vt>
<y0:vt>
strx_vt_mapoptn0$f1un
( xs: ~strx_vt(x0)
, fopr: (~x0) -> optn_vt(y0)): strx_vt(y0)
#symload
mapoptn0 with strx_vt_mapoptn0$f1un of 1000
#symload
mapoptn0$fun with strx_vt_mapoptn0$f1un of 1000
#symload
strx_vt_mapoptn0 with strx_vt_mapoptn0$f1un of 1000
//
fun
<x0:vt>
<y0:vt>
strx_vt_maplist0$f1un
( xs: ~strx_vt(x0)
, fopr: (~x0) -> list_vt(y0)): strx_vt(y0)
#symload
maplist0 with strx_vt_maplist0$f1un of 1000
#symload
maplist0$fun with strx_vt_maplist0$f1un of 1000
#symload
strx_vt_maplist0 with strx_vt_maplist0$f1un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
<r0:vt>
strx_vt_scanitm0
( xs
: ~strx_vt(x0), r0: r0): strx_vt(r0)
#symload
scanitm0 with strx_vt_scanitm0 of 1000
//
fun
<x0:vt>
<r0:vt>
strx_vt_scanitm0$f2un
( xs: ~strx_vt(x0)
, r0: r0, scan: (!r0, x0) -> r0): strx_vt(r0)
#symload
scanitm0 with strx_vt_scanitm0$f2un of 1000
#symload
scanitm0$fun with strx_vt_scanitm0$f2un of 1000
#symload
strx_vt_scanitm0 with strx_vt_scanitm0$f2un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-02-14:
Either something is found or
this one should loop forever!
Wed Jan 14 09:22:25 AM EST 2026
*)
fun
<x0:vt>
strx_vt_search0(xs: ~strx_vt(x0)): (x0)
#symload search0 with strx_vt_search0 of 1000
//
fun
<x0:vt>
strx_vt_search0$f1un
(xs: ~strx_vt(x0), test: (!x0) -> bool): (x0)
#symload search0 with strx_vt_search0$f1un of 1000
#symload search0$fun with strx_vt_search0$f1un of 1000
#symload strx_vt_search0 with strx_vt_search0$f1un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_VT_strx001_vt.sats] *)
(***********************************************************************)
`,
  "SATS/VT/tupl000_vt.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
(*
** for flat tuples
** for boxd tuples
*)
(* ****** ****** *)
(* ****** ****** *)
(*
HX-2023-08-06:
@(...): flat tuple
#(...): boxd tuple
$tup(...): boxd tuple
(Change: $(...) -> #(...))
Sun Aug  6 19:45:40 EDT 2023
*)
(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(Around some time in 2022)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-10:
Sat 10 Aug 2024 09:14:56 PM EDT
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_VT_tupl000_vt.sats] *)
(***********************************************************************)
`,
  "SATS/VT/unsfx00_vt.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon 08 Jul 2024 02:15:16 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
(*
HX-2024-07-25:
This one is already
included by [./../unsfx00.sats]
Thu 25 Jul 2024 10:28:59 AM EDT
*)
(* ****** ****** *)
(* ****** ****** *)
//
fcast
optn_vt2t
{a:t0}{b:b0}
(xs: !optn_vt(a, b)): optn(a, b)
fcast
list_vt2t
{a:t0}{n:i0}
(xs: !list_vt(a, n)): list(a, n)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:t0>
p2tr_set_list_vt_nil
(p0: p2tr(list_vt(a))): void
fun
<a:vt>
p2tr_set_list_vt_cons
(p0: p2tr(list_vt(a)), x0: a): void
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
strn_vt_get$at1
(cs: !strn_vt, i0: sint): cgtz
fun<>
strn_vt_set$at1
(cs: !strn_vt, i0: sint, c0: cgtz): void
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-22:
Mon 22 Jul 2024 08:20:12 AM EDT
*)
//
fcast
strm2q_vt
{a:vt}{n:nat}
(xs: strm_vt(a)): strq_vt(a, n)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:vt>
<x0:vt>
gasq_get$at$raw1
(xs: !xs, i0: ni): (x0)
fun
<xs:vt>
<x0:vt>
gasq_set$at$raw1
(xs: !xs, i0: ni, x0: x0): void
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_VT_unsfx00_vt.sats] *)
(***********************************************************************)
`,
  "SATS/asrt000.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon Dec 29 09:01:30 AM EST 2025
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#typedef igtz = sintgt(0)
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-25:
It is for sorted [a1sz]
*)
//
#abstbox
asrt_vt_i0_tx
( a:vt,n:i0 ) <= a1sz(a)
//
#sexpdef
asrt = asrt_vt_i0_tx
#typedef
asrt(a:vt) = [n:i0] asrt(a,n)
//
(* ****** ****** *)
(* ****** ****** *)
//
fcast
asrt_decd
{a:vt}
(asrt(a, n)): a1sz(a, n)
//
fcast
UN_asrt_encd
{a:vt}
(a1sz(a, n)): asrt(a, n)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:vt>
asrt_length
{n:i0}
(xs: asrt(a, n)): sint(n)
//
#symload
length with asrt_length of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-29:
Array-based binary search:
asrt_exists:
This one uses [exists$tcmp1]
asrt_search:
This one uses [search$tcmp1]
Mon Dec 29 12:30:42 PM EST 2025
*)
fun
<x0:vt>
asrt_exists
(xs: asrt(x0)): ( bool )
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-29:
[asrt_search$idx(xs)]
returns the least [i0]
satisfying (search(xs[i0])<0)
Note that xs[ln] is infinity.
Mon Dec 29 02:53:44 PM EST 2025
*)
fun
<x0:vt>
asrt_search$idx
{ln:i0}
(xs: asrt(x0, ln)): nintlte(ln)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-06:
Tue Jan  6 01:11:19 AM EST 2026
*)
fun
<x0:vt>
asrt_memberq
(xs: asrt(x0), x0: !x0): (bool)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_asrt000.sats] *)
(***********************************************************************)
`,
  "SATS/axrf000.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Sun 11 Aug 2024 12:59:19 PM EDT
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX: 0-dimensional
*)
//
#abstbox // ref
a0rf_vt_tx(a:vt)//0-dim
#absvtbx // ref
a0rf_vt_vx(a:vt)//0-dim
//
(*
HX-2026-01-05:
Traditionally, [ref]
is the name for [a0rf]
*)
#typedef
ref(x0:vt) = a0rf_vt_tx(x0)
//
#typedef
a0rf(x0:vt) = a0rf_vt_tx(x0)
#vwtpdef
a0rf_vt(x0:vt) = a0rf_vt_vx(x0)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX: 1-dimensional
*)
//
#abstbox // array
a1rf_vt_i0_tx(a:vt,n:i0)
#absvtbx // array
a1rf_vt_i0_vx(a:vt,n:i0)
//
#typedef
a1rf(a:vt,n:i0) = a1rf_vt_i0_tx(a,n)
#vwtpdef
a1rf_vt(a:vt,n:i0) = a1rf_vt_i0_vx(a,n)
//
#typedef
a1rf(x0:vt) = [ln:i0] a1rf(x0,ln)
#vwtpdef
a1rf_vt(x0:vt) = [ln:i0] a1rf_vt(x0,ln)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX: 2-dimensional
*)
#abstbox // matrix
a2rf_vt_i0_i0_tx(a:vt,m:i0,n:i0)
#absvtbx // matrix
a2rf_vt_i0_i0_vx(a:vt,m:i0,n:i0)
//
#typedef
a2rf//matrix
(a:vt,m:i0,n:i0) = a2rf_vt_i0_i0_tx(a,m,n)
#vwtpdef
a2rf_vt//matrix
(a:vt,m:i0,n:i0) = a2rf_vt_i0_i0_vx(a,m,n)
//
#typedef
a2rf(x0:vt) = [n1:i0;n2:i0] a2rf(x0,n1,n2)
#vwtpdef
a2rf_vt(x0:vt) = [n1:i0;n2:i0] a2rf_vt(x0,n1,n2)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:vt>
a0rf_make_1val(x0: a): a0rf(a)
//
(*
HX-2026-01-05:
Traditionally, [ref]
is the name for [a0rf]
*)
#symload
ref with a0rf_make_1val of 1000
//
#symload
a0rf with a0rf_make_1val of 1000
#symload
a0rf_1val with a0rf_make_1val of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:t0>
a0rf_get(A: a0rf(a)): (a)
fun
<a:t0>
a0rf_set(A: a0rf(a), x: a): void
//
#symload [] with a0rf_get of 1000
#symload [] with a0rf_set of 1000
#symload get with a0rf_get of 1000
#symload set with a0rf_set of 1000
//
(* ****** ****** *)
//
fun
<a:vt>
a0rf_cget(A: a0rf(a)): (a)
fun
<a:vt>
a0rf_setf(A: a0rf(a), x: a): void
//
#symload cget with a0rf_cget of 1000
#symload setf with a0rf_setf of 1000
//
(* ****** ****** *)
//
fun
<a:vt>
a0rf_lget
(A:a0rf(a)): (owed(a) | a)
fun
<a:vt>
a0rf_lset
(f:owed(a) | A:a0rf(a), x:a): void
//
#symload lget with a0rf_lget of 1000
#symload lset with a0rf_lset of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:t0>
a1rf_make_list
 {n:i0}
(xs: list(a, n)): a1rf(a, n)
//
#symload a1rf with a1rf_make_list of 1000
//
(* ****** ****** *)
//
fun
<a:t0>
a1rf_make_ncpy
 {n:i0|n>0}
( n:sint(n), x:a ): a1rf(a, n)
//
fun
<a:vt>
a1rf_make_nfun
 {n:i0|n>0}
( n0: sint(n)
, f0: nint(n) -> a): a1rf(a, n)
//
#symload a1rf with a1rf_make_ncpy of 1000
#symload a1rf with a1rf_make_nfun of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:t0>
a1rf_get$at
{n:nat}
(A:a1rf(a,n), i:nintlt(n)): a
fun
<a:t0>
a1rf_set$at
{n:nat}
(A:a1rf(a,n), i:nintlt(n), x:a): void
//
#symload [] with a1rf_get$at of 1000
#symload [] with a1rf_set$at of 1000
#symload get$at with a1rf_get$at of 1000
#symload set$at with a1rf_set$at of 1000
//
(* ****** ****** *)
//
fun
<a:vt>
a1rf_cget$at
{n:nat}
(A:a1rf(a,n), i:nintlt(n)): a
fun
<a:vt>
a1rf_setf$at
{n:nat}
(A:a1rf(a,n), i:nintlt(n), x:a): void
//
#symload cget$at with a1rf_cget$at of 1000
#symload setf$at with a1rf_setf$at of 1000
//
(* ****** ****** *)
//
fun
<a:vt>
a1rf_lget$at
{n:nat}
( A: a1rf(a,n)
, i: nintlt(n)): (owed(a) | a)
fun
<a:vt>
a1rf_lset$at
{n:nat}
(f: owed(a)
|A: a1rf(a,n), i:nintlt(n), x:a): void
//
#symload lget$at with a1rf_lget$at of 1000
#symload lset$at with a1rf_lset$at of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fcast // fun
GSEQ_make_a1rf
{a:t0}
(A:a1rf(a)): GSEQ(a1rf(a), a)
#symload GSEQ with GSEQ_make_a1rf of 1000
fcast // fun
GASQ_make_a1rf
{a:vt}
(A:a1rf(a)): GASQ(a1rf(a), a)
#symload GASQ with GASQ_make_a1rf of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_axrf000.sats] *)
(***********************************************************************)
`,
  "SATS/axrf001.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Mon 12 Aug 2024 09:37:16 PM EDT
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:vt>
a1rf_strmize
  (A: a1rf(a)): strm_vt(a)
//
#symload strmize with a1rf_strmize of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:vt>
a1rf_forall$size
{n:nat}
(A:a1rf(a,n), n:sint(n)): bool
fun
<a:vt>
a1rf_forall$size$f1un
{n:nat}
( A
: a1rf(a,n)
, n:sint(n), test:(!a) -> bool): bool
//
#symload forall with a1rf_forall$size of 1000
#symload forall with a1rf_forall$size$f1un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_axrf001.sats] *)
(***********************************************************************)
`,
  "SATS/axsz000.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Sun 11 Aug 2024 12:59:19 PM EDT
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#abstbox
a1sz_vt_i0_tx(a:vt,n:i0)
#absvtbx
a1sz_vt_i0_vx(a:vt,n:i0)
//
#typedef
a1sz
(a:vt,n:i0) = a1sz_vt_i0_tx(a,n)
#vwtpdef
a1sz_vt
(a:vt,n:i0) = a1sz_vt_i0_vx(a,n)
//
#typedef
a1sz(x0:vt) = [n:i0] a1sz(x0,n)
#vwtpdef
a1sz_vt(x0:vt) = [n:i0] a1sz_vt(x0,n)
//
(* ****** ****** *)
(* ****** ****** *)
//
#abstbox
a2sz_vt_i0_i0_tx(a:vt,m:i0,n:i0)
#abstbox
a2sz_vt_i0_i0_vx(a:vt,m:i0,n:i0)
//
#typedef
a2sz
(a:vt
,m:i0,n:i0) = a2sz_vt_i0_i0_tx(a,m,n)
#vwtpdef
a2sz_vt
(a:vt
,m:i0,n:i0) = a2sz_vt_i0_i0_vx(a,m,n)
//
#typedef
a2sz(x0:vt) = [m:i0;n:i0] a2sz(x0,m,n)
#vwtpdef
a2sz_vt(x0:vt) = [m:i0;n:i0] a2sz_vt(x0,m,n)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:t0>
a1sz_make_none
 {n:i0}
(n0: nint(n)): a1sz(?a, n)
//
(* ****** ****** *)
//
fun
<a:t0>
a1sz_make_list
 {n:i0}
(xs: list(a, n)): a1sz(a, n)
//
#symload
a1sz with a1sz_make_list//of 1000
//
(* ****** ****** *)
//
fun
<a:t0>
a1sz_make_ncpy
 {n:i0|n>0}
(n: sint(n), x:a): a1sz(a, n)
//
fun
<a:vt>
a1sz_make_nfun
 {n:i0|n>0}
( n: sint(n)
, f: nint(n) -> a): a1sz(a, n)
//
#symload
a1sz with a1sz_make_ncpy//of 1000
#symload
a1sz with a1sz_make_nfun//of 1000
#symload
arrsz with a1sz_make_ncpy//of 1000
#symload
arrsz with a1sz_make_nfun//of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:vt>
a1sz_make_llist
 {n:i0}
(xs: list_vt(a, n)): a1sz(a, n)
#symload
a1sz with a1sz_make_llist//of 1000
//
(* ****** ****** *)
//
fun
<a:vt>
a1sz_make_lstrm
 {n:i0}
(xs: strm_vt(a)): a1sz(a)
fun
<a:vt>
a1sz_make_lstrq
 {n:i0}
(xs:strq_vt(a, n)): a1sz(a, n)
//
#symload
a1sz with a1sz_make_lstrm//of 1000
#symload
a1sz with a1sz_make_lstrq//of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:vt>
a1sz_length
{n:i0}
(asz: a1sz(a, n)): sint(n)
#symload length with a1sz_length of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:t0>
a1sz_get$at
{n:i0}
(a1sz(a, n), nint(n)): ( a )
fun
<a:t0>
a1sz_set$at
{n:i0}
(a1sz(a, n), nint(n), a): void
//
#symload [] with a1sz_get$at of 1000
#symload [] with a1sz_set$at of 1000
#symload get$at with a1sz_get$at of 1000
#symload set$at with a1sz_set$at of 1000
//
(* ****** ****** *)
//
fun
<a:vt>
a1sz_cget$at
{n:i0}
(A:a1sz(a,n), i:nintlt(n)): (a)
fun
<a:vt>
a1sz_setf$at
{n:i0}
(A:a1sz(a,n), i:nintlt(n), x:a): void
//
#symload cget$at with a1sz_cget$at of 1000
#symload setf$at with a1sz_setf$at of 1000
//
(* ****** ****** *)
//
fun
<a:vt>
a1sz_lget$at
{n:i0}
( A: a1sz(a,n)
, i: nintlt(n)): (owed(a) | a)
fun
<a:vt>
a1sz_lset$at
{n:i0}
(f: owed(a)
|A: a1sz(a,n), i:nintlt(n), x:a): void
//
#symload lget$at with a1sz_lget$at of 1000
#symload lset$at with a1sz_lset$at of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:vt>
a2sz_d1size
{m:i0;n:i0}(a2sz(a, m, n)): sint(m)
#symload d1size with a2sz_d1size of 1000
#symload rowlen with a2sz_d1size of 1000
//
fun
<a:vt>
a2sz_d2size
{m:i0;n:i0}(a2sz(a, m, n)): sint(n)
#symload d2size with a2sz_d2size of 1000
#symload collen with a2sz_d2size of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fcast // fun
GSEQ_make_a1sz
{a:t0}
(A:a1sz(a)): GSEQ(a1sz(a), a)
#symload GSEQ with GSEQ_make_a1sz of 1000
fcast // fun
GASQ_make_a1sz
{a:vt}
(A:a1sz(a)): GASQ(a1sz(a), a)
#symload GASQ with GASQ_make_a1sz of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-18:
Sun 18 Aug 2024 09:19:36 AM EDT
*)
fun
<x0:vt>
a1sz_rvrsref(A: a1sz(x0)): void
#symload rvrsref with a1sz_rvrsref of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
a1sz_sortref(A: a1sz(x0)): void
#symload sortref with a1sz_sortref of 1000
fun
<x0:vt>
a1sz_qsortref(A: a1sz(x0)): void
#symload qsortref with a1sz_qsortref of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_axsz000.sats] *)
(***********************************************************************)
`,
  "SATS/axsz001.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
Mon 12 Aug 2024 09:34:49 PM EDT
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#typedef ni = nint
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:vt>
a1sz_strmize
  (A: a1sz(a)): strm_vt(a)
//
#symload strmize with a1sz_strmize of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:vt>
a1sz_forall(A: a1sz(a)): bool
fun
<a:vt>
a1sz_forall$f1un
(A: a1sz(a), test: (!a) -> bool): bool
//
#symload forall with a1sz_forall of 1000
#symload forall with a1sz_forall$f1un of 1000
//
(* ****** ****** *)
//
fun
<a:vt>
a1sz_rforall(A: a1sz(a)): bool
fun
<a:vt>
a1sz_rforall$f1un
(A: a1sz(a), test: (!a) -> bool): bool
//
#symload rforall with a1sz_rforall of 1000
#symload rforall with a1sz_rforall$f1un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-17:
Sat 17 Aug 2024 07:25:27 PM EDT
*)
//
(*
fun
<x0:vt>
a1sz_fmake((*void*)): a1sz(x0)
*)
fun
<x0:vt>
a1sz_fmake_fwork
(
fwork:
((~x0)->void)->void): a1sz(x0)//HX:3rd-order!
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-18:
Sun 18 Aug 2024 08:55:31 AM EDT
*)
//
fun
<x0:vt>
a1sz_mapref(A: a1sz(x0)): void
fun
<x0:vt>
a1sz_mapref$c1bv
(A: a1sz(x0), fopr: (~x0)->(x0)): void
(*
fun
<x0:vt>
a1sz_mapref$c1br
(A: a1sz(x0), fopr: (&x0)->void): void
*)
//
#symload mapref with a1sz_mapref of 1000
#symload mapref with a1sz_mapref$c1bv of 1000
(*
#symload mapref with a1sz_mapref$c1br of 1000
*)
//
fun
<x0:vt>
a1sz_imapref(A: a1sz(x0)): void
fun
<x0:vt>
a1sz_imapref$c2bv
(A: a1sz(x0), fopr: (ni,~x0)->(x0)): void
(*
fun
<x0:vt>
a1sz_imapref$c2br
(A: a1sz(x0), fopr: (ni,&x0)->void): void
*)
#symload imapref with a1sz_imapref of 1000
#symload imapref with a1sz_imapref$c2bv of 1000
(*
#symload imapref with ia1sz_mapref$c2br of 1000
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-17:
Sat 17 Aug 2024 11:43:41 PM EDT
*)
//
fun
<xs:t0>
<x0:vt>
<y0:vt>
gasq_map_a1sz(xs: xs): a1sz(y0)
fun
<xs:t0>
<x0:vt>
<y0:vt>
gasq_map_la1sz(xs: xs): a1sz_vt(y0)
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:vt>
<y0:vt>
gasq_map$f1un_a1sz
(xs: xs, fopr: (!x0)->(y0)): a1sz(y0)
#symload map_a1sz with gasq_map$f1un_a1sz of 0100
(*
HX-2024-08-18:
This is another way to name the function:
#symload map_a1sz with gasq_f1un$map_a1sz of 0100
*)
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:vt>
<y0:vt>
gasq_map$f1un_la1sz
(xs: xs, fopr: (!x0)->(y0)): a1sz_vt(y0)
#symload map_la1sz with gasq_map$f1un_la1sz of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_axsz001.sats] *)
(***********************************************************************)
`,
  "SATS/bool000.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2020 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// For booleans
//
(* ****** ****** *)
//
// Author: Hongwei Xi
// Start Time: March, 2020
// Authoremail: gmhwxiATgmailDOTcom
//
(* ****** ****** *)
(*
#typedef strn = string
*)
(* ****** ****** *)
//
val
the_bool_true: bool(tt)
val
the_bool_false: bool(ff)
//
(* ****** ****** *)
//
(*
#symload
tru with the_bool_true//of 1000
#symload
fls with the_bool_false//of 1000
#symload true with the_bool_true
#symload false with the_bool_false
*)
//
(* ****** ****** *)
//
fun<>
bool_neg
{b:bool}
(x0: bool(b)): bool( ~b )
//
#symload ~ with bool_neg of 1000
#symload neg with bool_neg of 1000
#symload not with bool_neg of 1000
//
(* ****** ****** *)
//
fun<>
bool_add
{b1,b2:bool}
(x1: bool(b1)
,y2: bool(b2)): bool(b1+b2)
fun<>
bool_mul
{b1,b2:bool}
(x1: bool(b1)
,y2: bool(b2)): bool(b1*b2)
//
#symload + with bool_add of 1000
#symload * with bool_mul of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
bool2sint
{b:bool}
(x0: bool(b)): sint(b2i(b))
//
#symload sint with bool2sint of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-29:
Note that
[bool_print] may not be
the same as g_print<bool>
*)
fun<>
bool_print(btf: bool): void
//
(* ****** ****** *)
//
fun<>
bool_parse(rep: strn): bool
//
(* ****** ****** *)
//
(*
HX: torep for parsing
*)
fun<>
bool_torep(btf: bool): strn
(*
HX: tostr for debugging
*)
fun<>
bool_tostr(btf: bool): strn
//
(* ****** ****** *)
//
(*
HX-2024-09-01:
Sun 01 Sep 2024 04:45:43 PM EDT
*)
//
fun<>
bool_lt
{i,j:b0}
(bool(i), bool(j)): bool(i<j)
fun<>
bool_gt
{i,j:b0}
(bool(i), bool(j)): bool(i>j)
fun<>
bool_eq
{i,j:b0}
(bool(i), bool(j)): bool(i=j)
//
#symload < with bool_lt of 1000
#symload > with bool_gt of 1000
#symload = with bool_eq of 1000
//
fun<>
bool_lte
{i,j:b0}
(bool(i), bool(j)): bool(i<=j)
fun<>
bool_gte
{i,j:b0}
(bool(i), bool(j)): bool(i>=j)
fun<>
bool_neq
{i,j:b0}
(bool(i), bool(j)): bool(i!=j)
//
#symload <= with bool_lte of 1000
#symload >= with bool_gte of 1000
#symload != with bool_neq of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:t0>
bool_ifval
{b:b0}
(b: bool(b), x: a, y: a): (a) // fun
//
#symload ifval with bool_ifval of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_bool000.sats] *)
(***********************************************************************)
`,
  "SATS/char000.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2020 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// For characters
// that is, sint8 and uint8
//
(* ****** ****** *)
//
// Author: Hongwei Xi
// Start Time: March, 2020
// Authoremail: gmhwxiATgmailDOTcom
//
(* ****** ****** *)
//
fun<>
char_to$code
 (chr:char): sint
//
(*
HX:
[char_to$code]=
[sint_make_char]=
[char2uint2sint]!!!
*)
fun<>
char_to$sint
 (chr:char):sint//fun<>
fun<>
sint_make_char
 (chr:char):sint//fun<>
//
#symload
ord with char_to$code of 1000
//
(*
HX-2022-06-12: deprecated
//
#symload
sint with char_to$sint of 1000
#symload
sint with sint_make_char of 1000
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
code_to$char
 (code:sint):char//fun<>
fun<>
char_make_code
 (code:sint):char//fun<>
#symload
chr with code_to$char of 1000
//
(* ****** ****** *)
//
fun<>
sint_to$char
 (code:sint):char//fun<>
fun<>
char_make_sint
 (code:sint):char//fun<>
//
fun<>
uint_to$char
 (code:uint):char//fun<>
fun<>
char_make_uint
 (code:uint):char//fun<>
//
#symload
char with sint_to$char of 1000
#symload
char with uint_to$char of 1000
//
#symload
char with char_make_sint of 1000
#symload
char with char_make_uint of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-29:
Note that
[char_print] may not be
the same as g_print<char>
*)
//
fun<>
char_print(c0: char): void
//
(* ****** ****** *)
//
(*
HX-2025-05-08:
[char_tostr] should be
the same as g_tostr<char>
fun<>
char_tostr(c0: char): strn
Thu May  8 11:26:55 AM EDT 2025
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
char_eqz
{c:c0}(c0: char(c)): bool(c=0)
fun<>
char_neqz
{c:c0}(c0: char(c)): bool(c>0)
//
#symload eqz with char_eqz of 1000
#symload neqz with char_neqz of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
char_equal
{c1,c2:c0}
( c1: char(c1)
, c2: char(c2)): bool(c1 = c2)
fun<>
char_noteq
{c1,c2:c0}
( c1: char(c1)
, c2: char(c2)): bool(c1 != c2)
//
#symload equal with char_equal of 1000
#symload noteq with char_noteq of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
char_lt
{c1,c2:c0}
( c1: char(c1)
, c2: char(c2)): bool(c1 < c2)
fun<>
char_gt
{c1,c2:c0}
( c1: char(c1)
, c2: char(c2)): bool(c1 > c2)
fun<>
char_eq
{c1,c2:c0}
( c1: char(c1)
, c2: char(c2)): bool(c1 = c2)
fun<>
char_lte
{c1,c2:c0}
( c1: char(c1)
, c2: char(c2)): bool(c1 <= c2)
fun<>
char_gte
{c1,c2:c0}
( c1: char(c1)
, c2: char(c2)): bool(c1 >= c2)
fun<>
char_neq
{c1,c2:c0}
( c1: char(c1)
, c2: char(c2)): bool(c1 != c2)
//
#symload < with char_lt of 1000
#symload > with char_gt of 1000
#symload = with char_eq of 1000
#symload <= with char_lte of 1000
#symload >= with char_gte of 1000
#symload != with char_neq of 1000
//
(* ****** ****** *)
//
fun<>
char_cmp
{c1,c2:c0}
( c1: char(c1)
, c2: char(c2)): sint(sgn(c1-c2))
//
#symload cmp with char_cmp of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
char_lower
(c0: char): char(*0*)
fun<>
char_upper
(c0: char): char(*0*)
//
#symload lower with char_lower of 1000
#symload upper with char_upper of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
char_add$sint
{c1:c0
;i2:i0}
( c1: char(c1)
, i2: sint(i2)): char(*0*)
//
fun<>
char_sub$char
{c1
,c2:c0}
( c1: char(c1)
, c2: char(c2)): sint(c1-c2)
//
#symload + with char_add$sint of 1000
#symload - with char_sub$char of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
char_isalpha(c0: char): bool
fun<>
sint_isalpha(c0: sint): bool
#symload isalpha with char_isalpha of 1000
#symload isalpha with sint_isalpha of 1000
//
fun<>
char_isalnum(c0: char): bool
fun<>
sint_isalnum(c0: sint): bool
#symload isalnum with char_isalnum of 1000
#symload isalnum with sint_isalnum of 1000
//
fun<>
char_isascii(c0: char): bool
fun<>
sint_isascii(c0: sint): bool
#symload isascii with char_isascii of 1000
#symload isascii with sint_isascii of 1000
//
fun<>
char_isblank(c0: char): bool
fun<>
sint_isblank(c0: sint): bool
#symload isblank with char_isblank of 1000
#symload isblank with sint_isblank of 1000
//
fun<>
char_isspace(c0: char): bool
fun<>
sint_isspace(c0: sint): bool
#symload isspace with char_isspace of 1000
#symload isspace with sint_isspace of 1000
//
fun<>
char_iscntrl(c0: char): bool
fun<>
sint_iscntrl(c0: sint): bool
#symload iscntrl with char_iscntrl of 1000
#symload iscntrl with sint_iscntrl of 1000
//
fun<>
char_isdigit(c0: char): bool
fun<>
sint_isdigit(c0: sint): bool
#symload isdigit with char_isdigit of 1000
#symload isdigit with sint_isdigit of 1000
//
fun<>
char_isxdigit(c0: char): bool
fun<>
sint_isxdigit(c0: sint): bool
#symload isxdigit with char_isxdigit of 1000
#symload isxdigit with sint_isxdigit of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_char000.sats] *)
(***********************************************************************)
`,
  "SATS/gamp000.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
AMP: array-based map
Wed Dec 24 04:22:13 PM EST 2025
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-24:
For gamp_print
For print0/1 as well
*)
fun
<amp:vt>
<key:vt>
<itm:vt>
gamp_beg((*void*)): strn
fun
<amp:vt>
<key:vt>
<itm:vt>
gamp_end((*void*)): strn
fun
<amp:vt>
<key:vt>
<itm:vt>
gamp_sep((*void*)): strn
//
(* ****** ****** *)
//
fun
<amp:t0>
<key:t0>
<itm:vt>
gamp_print(kxs: amp): void
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<amp:t0>
<key:t0>
<itm:vt>
gamp_keyq
(kxs: amp, key: key): bool
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<amp:t0>
<key:t0>
<itm:vt>
gamp_cget$at
(kxs: amp, key: key): itm
fun
<amp:t0>
<key:t0>
<itm:vt>
gamp_cget$at$opt
// HX: nil if !keyq(key)
// HX: cons(old) if keyq(key)
(kxs: amp, key: key): optn_vt(itm)
//
(* ****** ****** *)
//
(*
HX-2025-12-24:
These are for imperative maps!
Wed Dec 24 01:07:13 PM EST 2025
*)
fun
<amp:t0>
<key:t0>
<itm:vt>
gamp_setf$at
(kxs: amp
,key: key, itm: itm): void
fun
<amp:t0>
<key:t0>
<itm:vt>
gamp_setf$at$opt
// HX: nil if !keyq(key)
// HX: cons(old) if keyq(key)
(kxs: amp
,key: key, itm: itm): optn_vt(itm)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-24:
The semantics is involved
for a mutable map (hashmap)!
Wed Dec 24 01:07:13 PM EST 2025
*)
fun
<amp:t0>
<key:t0>
<itm:vt>
gamp_strmize
(kxs: amp): strm_vt@(key, itm)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<amp:t0>
<key:t0>
<itm:vt>
gamp_search$tst
(kxs: amp, key: key): bool
fun
<amp:t0>
<key:t0>
<itm:vt>
gamp_search$cpy
(kxs: amp, key: key): optn_vt(itm)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-24:
These are for imperative maps!
Wed Dec 24 01:08:59 PM EST 2025
*)
//
(*
HX-2025-12-24:
Using [getout$old] if [key]
is known in the given map [map]
*)
(*
fun
<amp:t0>
<key:t0>
<itm:vt>
gamp_getout$any
(kxs: amp, key: key): itm
*)
fun
<amp:t0>
<key:t0>
<itm:vt>
gamp_getout$old
(kxs: amp, key: key): itm
fun
<amp:t0>
<key:t0>
<itm:vt>
gamp_getout$opt
(kxs: amp, key: key): optn_vt(itm)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-24:
These are for imperative maps!
Wed Dec 24 01:10:05 PM EST 2025
*)
(*
HX-2025-12-24:
Using [insert$new] if [key] is
known not in the given map [map]
*)
(*
fun
<amp:t0>
<key:t0>
<itm:vt>
gamp_insert$any
(kxs: amp
,key: key, itm: itm): void
*)
fun
<amp:t0>
<key:t0>
<itm:vt>
gamp_insert$new
(kxs: amp
,key: key, itm: itm): void
fun
<amp:t0>
<key:t0>
<itm:vt>
gamp_insert$opt
(kxs: amp
,key: key, itm: itm): optn_vt(itm)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_gamp000.sats] *)
(***********************************************************************)
`,
  "SATS/gamp001.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
AMP: array-based map!
Wed Dec 24 05:05:14 PM EST 2025
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-25:
The semantics is involved
for a mutable map (hashmap)!
It really depends on the actual
implementation of these functions.
*)
//
fun
<amp:t0>
<key:t0>
<itm:vt>
gamp_key$strmize(amp): strm_vt(key)
fun
<amp:t0>
<key:t0>
<itm:vt>
gamp_val$strmize(amp): strm_vt(itm)
fun
<amp:t0>
<key:t0>
<itm:vt>
gamp_keyval$strmize(amp): strm_vt@(key, itm)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_gamp001.sats] *)
(***********************************************************************)
`,
  "SATS/gasq000.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sun 21 Jul 2024 02:16:49 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#typedef ni = nint
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:vt>
gasq_length(xs: xs): nint
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
gasq_get$at
(xs: xs, i0: ni): (x0)
fun
<xs:t0>
<x0:t0>
gasq_set$at
(xs: xs, i0: ni, x0: x0): void
//
#typedef
gasq_get$at
(xs:t0, x0:t0) = (xs, ni) -> (x0)
#typedef
gasq_set$at
(xs:t0, x0:t0) = (xs, ni, x0) -> void
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-31:
The 'l' here means 'linear'
Wed Dec 31 11:21:54 AM EST 2025
*)
//
fun
<xs:t0>
<x0:vt>
gasq_lget$at
(xs: xs
,i0: ni): (owed(x0) | x0)
fun
<xs:t0>
<x0:vt>
gasq_lset$at
(pf: owed(x0)
|xs: xs, i0: ni, x0: x0): void
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-31:
The 'c' in 'cget' means 'copy'
The 'f' in 'setf' means 'free'
For reference, the 'f' in 'fset'
means 'functional'.
Wed Dec 31 11:21:54 AM EST 2025
*)
//
fun
<xs:t0>
<x0:vt>
gasq_cget$at
(xs: xs, i0: ni): (x0)
fun
<xs:t0>
<x0:vt>
gasq_setf$at
(xs: xs, i0: ni, x0: x0): void
//
(* ****** ****** *)
//
(*
HX-2024-09-20:
nil() is returned
if [i0] is out of bounds
*)
fun
<xs:t0>
<x0:vt>
gasq_cget$at$opt
(xs: xs, i0: ni): optn_vt(x0)
(*
HX-2024-09-20:
cons(x0) is returned
if [i0] is out of bounds
*)
fun
<xs:t0>
<x0:vt>
gasq_setf$at$opt
(xs: xs, i0: ni, x0: x0): optn_vt(x0)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_gasq000.sats] *)
(***********************************************************************)
`,
  "SATS/gasq001.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sun 21 Jul 2024 02:22:12 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#typedef ni = nint
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:vt>
gasq_listize
 ( xs: xs ): list_vt(x0)
fun
<xs:t0>
<x0:vt>
gasq_rlistize
 ( xs: xs ): list_vt(x0)
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:vt>
gasq_strmize
 ( xs: xs ): strm_vt(x0)
fun
<xs:t0>
<x0:vt>
gasq_rstrmize
 ( xs: xs ): strm_vt(x0)
//
fun
<xs:t0>
<x0:vt>
gasq_strqize
 ( xs: xs ): strq_vt(x0)
fun
<xs:t0>
<x0:vt>
gasq_rstrqize
 ( xs: xs ): strq_vt(x0)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:vt>
gasq_forall(xs: xs): bool
fun
<xs:t0>
<x0:vt>
gasq_exists(xs: xs): bool
fun
<xs:t0>
<x0:vt>
gasq_rforall(xs: xs): bool
fun
<xs:t0>
<x0:vt>
gasq_rexists(xs: xs): bool
//
fun
<xs:t0>
<x0:vt>
gasq_iforall(xs: xs): bool
fun
<xs:t0>
<x0:vt>
gasq_irforall(xs: xs): bool
//
(*
#symload forall with gasq_forall of 0100
#symload exists with gasq_exists of 0100
#symload rforall with gasq_rforall of 0100
#symload rexists with gasq_rexists of 0100
*)
//
fun
<xs:t0>
<x0:vt>
gasq_forall$f1un
(xs: xs, test: (!x0)->bool): bool
fun
<xs:t0>
<x0:vt>
gasq_exists$f1un
(xs: xs, test: (!x0)->bool): bool
//
fun
<xs:t0>
<x0:vt>
gasq_rforall$f1un
(xs: xs, test: (!x0)->bool): bool
fun
<xs:t0>
<x0:vt>
gasq_rexists$f1un
(xs: xs, test: (!x0)->bool): bool
//
fun
<xs:t0>
<x0:vt>
gasq_iforall$f2un
(xs: xs, test: (ni, !x0)->bool): bool
fun
<xs:t0>
<x0:vt>
gasq_irforall$f2un
(xs: xs, test: (ni, !x0)->bool): bool
//
(* ****** ****** *)
//
#symload
gasq_forall with gasq_forall$f1un of 0100
#symload
gasq_exists with gasq_exists$f1un of 0100
//
#symload
gasq_rforall with gasq_rforall$f1un of 0100
#symload
gasq_rexists with gasq_rexists$f1un of 0100
//
#symload
gasq_iforall with gasq_iforall$f2un of 0100
#symload
gasq_irforall with gasq_irforall$f2un of 0100
//
(* ****** ****** *)
//
(*
HX-2026-01-12:
Mon Jan 12 08:10:11 PM EST 2026
*)
fun
<xs:t0>
<x0:vt>
gasq_foritm(xs: xs): void
fun
<xs:t0>
<x0:vt>
gasq_rforitm(xs: xs): void
fun
<xs:t0>
<x0:vt>
gasq_iforitm(xs: xs): void
fun
<xs:t0>
<x0:vt>
gasq_irforitm(xs: xs): void
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:vt>
gasq_foritm$f1un
(xs: xs, test: (!x0)->void): void
fun
<xs:t0>
<x0:vt>
gasq_rforitm$f1un
(xs: xs, test: (!x0)->void): void
fun
<xs:t0>
<x0:vt>
gasq_iforitm$f2un
(xs: xs, test: (ni, !x0)->void): void
fun
<xs:t0>
<x0:vt>
gasq_irforitm$f2un
(xs: xs, test: (ni, !x0)->void): void
//
(* ****** ****** *)
//
#symload
gasq_foritm with gasq_foritm$f1un of 0100
#symload
gasq_rforitm with gasq_rforitm$f1un of 0100
#symload
gasq_iforitm with gasq_iforitm$f2un of 0100
#symload
gasq_irforitm with gasq_irforitm$f2un of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-25:
Thu 25 Jul 2024 01:47:26 PM EDT
HX-2025-09-08:
There seems to be overlapping between
[mapref] and [foritm1x]
Let us keep [mapref] as a special combinator for now.
*)
//
fun
<x0:vt>
mapref$fopr0
( itm: ~x0 ): ( x0 )
fun
<x0:vt>
mapref$fopr1x
( ref: &x0 >> x0 ): void
//
(*
fun
<x0:vt>
mapref$fopr0x
( ref: &x0 >> ?x0 ): void
fun
<x0:vt>
mapref$fopr01x
( ref: &(?x0) >> (x0) ): void
fun
<x0:vt>
mapref$fopr10x
( ref: &(?x0) << (x0) ): void
*)
//
fun
<xs:t0>
<x0:vt>
gasq_mapref(xs: xs): void
fun
<xs:t0>
<x0:vt>
gasq_mapref$c1bv
(xs: xs, fopr: (~x0)->(x0)): void
//
(*
#symload mapref with gasq_mapref$c1bv of 0100
#symload mapref$cbv with gasq_mapref$c1bv of 0100
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
rmapref$fopr0
( x0: ~x0 ): ( x0 )
fun
<x0:vt>
rmapref$fopr1x
( ref: &x0 >> x0 ): void
//
fun
<xs:t0>
<x0:vt>
gasq_rmapref(xs: xs): void
fun
<xs:t0>
<x0:vt>
gasq_rmapref$c1bv
(xs: xs, fopr: (~x0)->(x0)): void
//
(*
#symload rmapref with gasq_rmapref$c1bv of 0100
#symload rmapref$cbv with gasq_rmapref$c1bv of 0100
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
imapref$fopr0
(i0: ni, x0: ~x0): (x0)
fun
<x0:vt>
imapref$fopr1x
(i0: ni, ref: &x0 >> x0): void
//
//
fun
<xs:t0>
<x0:vt>
gasq_imapref(xs: xs): void
fun
<xs:t0>
<x0:vt>
gasq_imapref$c2bv
(xs: xs, fopr: (ni, ~x0)->(x0)): void
//
(*
#symload imapref with gasq_imapref$c2bv of 0100
#symload imapref$cbv with gasq_imapref$c2bv of 0100
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
irmapref$fopr0
(i0: ni, x0: ~x0): (x0)
fun
<x0:vt>
irmapref$fopr1x
(i0: ni, ref: &x0 >> x0): void
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:vt>
gasq_irmapref(xs: xs): void
fun
<xs:t0>
<x0:vt>
gasq_irmapref$c2bv
(xs: xs, fopr: (ni, ~x0)->(x0)): void
//
(*
#symload irmapref with gasq_irmapref$c2bv of 0100
#symload irmapref$cbv with gasq_irmapref$c2bv of 0100
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-05:
Mon Jan  5 06:44:09 PM EST 2026
*)
fun
<xs:t0>
<x0:t0>
gasq_sortedq(xs: xs): bool
fun
<xs:t0>
<x0:t0>
gasq_sortedq$f2un
(xs: xs, lteq: (x0, x0) -> bool): bool
#symload gasq_sortedq with gasq_sortedq$f2un of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_gasq001.sats] *)
(***********************************************************************)
`,
  "SATS/gasq002.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Thu 08 Aug 2024 04:33:32 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#typedef ni = nint
#typedef si = sint
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:vt>
<ys:t0>
<y0:vt>
gasq_z2listize
(xs: xs, ys: ys): list_vt@(x0, y0)
fun
<xs:t0>
<x0:vt>
<ys:t0>
<y0:vt>
gasq_z2rlistize
(xs: xs, ys: ys): list_vt@(x0, y0)
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:vt>
<ys:t0>
<y0:vt>
gasq_z2strmize
(xs: xs, ys: ys): strm_vt@(x0, y0)
fun
<xs:t0>
<x0:vt>
<ys:t0>
<y0:vt>
gasq_z2rstrmize
(xs: xs, ys: ys): strm_vt@(x0, y0)
//
fun
<xs:t0>
<x0:vt>
<ys:t0>
<y0:vt>
gasq_z2strqize
(xs: xs, ys: ys): strq_vt@(x0, y0)
fun
<xs:t0>
<x0:vt>
<ys:t0>
<y0:vt>
gasq_z2rstrqize
(xs: xs, ys: ys): strq_vt@(x0, y0)
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:vt>
<ys:t0>
<y0:vt>
gasq_z2forall(xs: xs, ys: ys): bool
fun
<xs:t0>
<x0:vt>
<ys:t0>
<y0:vt>
gasq_z2forcmp(xs: xs, ys: ys): sint
//
fun
<xs:t0>
<x0:vt>
<ys:t0>
<y0:vt>
gasq_z2rforall(xs: xs, ys: ys): bool
fun
<xs:t0>
<x0:vt>
<ys:t0>
<y0:vt>
gasq_z2rforcmp(xs: xs, ys: ys): sint
//
fun
<xs:t0>
<x0:vt>
<ys:t0>
<y0:vt>
gasq_z2iforall(xs: xs, ys: ys): bool
fun
<xs:t0>
<x0:vt>
<ys:t0>
<y0:vt>
gasq_z2iforcmp(xs: xs, ys: ys): sint
//
fun
<xs:t0>
<x0:vt>
<ys:t0>
<y0:vt>
gasq_z2irforall(xs: xs, ys: ys): bool
fun
<xs:t0>
<x0:vt>
<ys:t0>
<y0:vt>
gasq_z2irforcmp(xs: xs, ys: ys): sint
//
(*
#symload z2forall with gasq_z2forall of 0100
#symload z2forcmp with gasq_z2forcmp of 0100
#symload z2rforall with gasq_z2rforall of 0100
#symload z2rforcmp with gasq_z2rforcmp of 0100
#symload z2iforall with gasq_z2iforall of 0100
#symload z2iforcmp with gasq_z2iforcmp of 0100
#symload z2irforall with gasq_z2irforall of 0100
#symload z2irforcmp with gasq_z2irforcmp of 0100
*)
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:vt>
<ys:t0>
<y0:vt>
gasq_z2forall$f2un
(xs: xs, ys: ys, test: (!x0, !y0)->bool): bool
//
(*
#symload z2forall with gasq_z2forall$f2un of 0100
#symload z2forall$fun with gasq_z2forall$f2un of 0100
*)
#symload gasq_z2forall with gasq_z2forall$f2un of 0100
//
(* ****** ****** *)
(* ****** ****** *)
(*
HX-2024-08-04:
Sun 04 Aug 2024 07:17:13 AM EDT
For multiplicative combination of
two given lists: x is short for cross
*)
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:vt>
<ys:t0>
<y0:vt>
gasq_x2listize
(xs: xs, ys: ys): list_vt@(x0, y0)
fun
<xs:t0>
<x0:vt>
<ys:t0>
<y0:vt>
gasq_x2rlistize
(xs: xs, ys: ys): list_vt@(x0, y0)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:vt>
<ys:t0>
<y0:vt>
gasq_x2strmize
(xs: xs, ys: ys): strm_vt@(x0, y0)
//
fun
<xs:t0>
<x0:vt>
<ys:t0>
<y0:vt>
gasq_x2strqize
(xs: xs, ys: ys): strq_vt@(x0, y0)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:vt>
<ys:t0>
<y0:vt>
gasq_x2forall(xs: xs, ys: ys): bool
//
fun
<xs:t0>
<x0:vt>
<ys:t0>
<y0:vt>
gasq_ix2forall(xs: xs, ys: ys): bool
//
(*
#symload x2forall with gasq_x2forall of 0100
#symload ix2forall with gasq_ix2forall of 0100
*)
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:vt>
<ys:t0>
<y0:vt>
gasq_x2forall$f2un
(xs: xs, ys: ys, test: (!x0, !y0)->bool): bool
//
(*
#symload x2forall with gasq_x2forall$f2un of 0100
#symload x2forall$fun with gasq_x2forall$f2un of 0100
*)
#symload gasq_x2forall$fun with gasq_x2forall$f2un of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
#typedef
gz2asq
( xs: t0, x0: vt
, ys: t0, y0: vt) =
(
  z2tup(GASQ(xs, x0), GASQ(ys, y0)))
//
#typedef
gx2asq
( xs: t0, x0: vt
, ys: t0, y0: vt) =
(
  x2tup(GASQ(xs, x0), GASQ(ys, y0)))
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:vt>
<ys:t0>
<y0:vt>
GASQ_z2make
( xs: GASQ(xs, x0)
, ys: GASQ(ys, y0)): GASQ(gz2asq(xs,x0,ys,y0), (x0,y0))
//
fun
<xs:t0>
<x0:vt>
<ys:t0>
<y0:vt>
GASQ_x2make
( xs: GASQ(xs, x0)
, ys: GASQ(ys, y0)): GASQ(gx2asq(xs,x0,ys,y0), (x0,y0))
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_gasq002.sats] *)
(***********************************************************************)
`,
  "SATS/gbas000.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon 08 Jul 2024 08:46:41 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#typedef ni = nint
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:t0>
g_void( a ): void
fun
<a:vt>
g_self( a ): ( a )
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:vt>
g_free( ~a ): void
fun
<a:vt>
g_copy( !a ): ( a )
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-08:
Thu Jan 8 EST
10:02:30 AM 2026
*)
fun
<a:vt>
g_make((**)): ( a )
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:t0>
g_work(x : a): void
fun
<a:t0>
g_test(x : a): bool
//
fun
<a0:t0>
g_iwork
(i0:ni,x0:a0): void
fun
<a0:t0>
g_itest
(i0:ni,x0:a0): bool
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:t0>
g_equal(a, a): bool
fun
<a:t0>
g_noteq(a, a): bool
//
(* ****** ****** *)
//
fun
<a:t0>
g_eqref(a, a): bool
fun
<a:t0>
g_neqrf(a, a): bool
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
(*
HX-2025-04-26:
Is this a good idea?
*)
fun
<a:vt>
g_input
((*void*)): (  a  )
fun
<a:vt>
g_input$exn
((*void*)): (  a  )
fun
<a:vt>
g_input$opt
((*void*)): optn_vt(a)
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-04-26:
Is this a good idea?
BTW, naming convention:
'parse' is like 'strn$make'
*)
fun
<a:vt>
g_parse
(rep: strn): (  a  )
fun
<a:vt>
g_parse$exn
(rep: strn): (  a  )
fun
<a:vt>
g_parse$opt
(rep: strn): optn_vt(a)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:t0>
g_torep(obj: a): strn
fun
<a:t0>
g_tostr(obj: a): strn
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:t0>
g_print(obj: x0): void
//
(* ****** ****** *)
(* ****** ****** *)
//
#symload void with g_void of 0100
#symload self with g_self of 0100
//
(* ****** ****** *)
//
#symload torep with g_torep of 0100
#symload tostr with g_tostr of 0100
//
(* ****** ****** *)
//
#symload print with g_print of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_gbas000.sats] *)
(***********************************************************************)
`,
  "SATS/gbas001.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Wed 10 Jul 2024 09:08:28 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#typedef ni = nint
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-15
*)
//
fun
<x0:t0>
max$nil((*nil*)): (x0)
fun
<x0:t0>
min$nil((*nil*)): (x0)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-15
*)
//
fun
<xs:t0>
<x0:vt>
get$at$exn
(xs: xs, i0: ni): (x0)
fun
<xs:t0>
<x0:vt>
set$at$exn
(xs:xs,i0:ni,x0:x0): void
fun
<xs:t0>
<x0:t0>
fset$at$exn
(xs:xs,i0:ni,x0:x0): (xs)
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:vt>
cget$at$exn
(xs: xs, i0: ni): (x0)
fun
<xs:t0>
<x0:vt>
setf$at$exn
(xs:xs,i0:ni,x0:x0): void
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:t0>
forall$test(x0: x0): bool
fun
<x0:t0>
rforall$test(x0: x0): bool
fun
<x0:t0>
iforall$test(ni, x0): bool
fun
<x0:t0>
irforall$test(ni, x0): bool
//
(*
HX-2025-09-07:
[ri] traverses
(x0, x1, x2) as:
(2, x2), (1, x1), (0, x0)
[ir] readily replaces [ri]!
//
fun
<x0:t0>
riforall$test(ni, x0): bool
//
*)
//
(* ****** ****** *)
//
fun
<x0:t0>
foritm$work(x0: x0): void
fun
<x0:t0>
rforitm$work(x0: x0): void
fun
<x0:t0>
iforitm$work(ni, x0): void
fun
<x0:t0>
irforitm$work(ni, x0): void
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:t0>
<r0:vt>
folditm$fopr(r0, x0): (r0)
fun
<x0:t0>
<r0:vt>
rfolditm$fopr(x0, r0): (r0)
//
fun
<x0:t0>
<r0:vt>
ifolditm$fopr
(res: r0, pos: ni, itm: x0): (r0)
fun
<x0:t0>
<r0:vt>
irfolditm$fopr
(pos: ni, itm: x0, res: r0): (r0)
//
(* ****** ****** *)
//
fun
<x0:t0>
<r0:vt>
foldall$fopr(r0, x0): (bool, r0)
fun
<x0:t0>
<r0:vt>
rfoldall$fopr(x0, r0): (bool, r0)
//
fun
<x0:t0>
<r0:vt>
ifoldall$fopr
(res: r0, pos: ni, itm: x0): (bool, r0)
fun
<x0:t0>
<r0:vt>
irfoldall$fopr
(pos: ni, itm: x0, res: r0): (bool, r0)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:t0>
search$test(itm: x0): bool
fun
<x0:t0>
search$tcmp(itm: x0): sint
//
fun
<x0:t0>
rsearch$test(itm: x0): bool
fun
<x0:t0>
rsearch$tcmp(itm: x0): sint
//
fun
<x0:t0>
isearch$test(pos: ni, itm: x0): bool
fun
<x0:t0>
isearch$tcmp(pos: ni, itm: x0): sint
//
fun
<x0:t0>
irsearch$test(pos: ni, itm: x0): bool
fun
<x0:t0>
irsearch$tcmp(pos: ni, itm: x0): sint
//
(* ****** ****** *)
//
fun
<x0:t0>
filter$test(itm: x0): bool
fun
<x0:t0>
rfilter$test(itm: x0): bool
fun
<x0:t0>
ifilter$test(pos: ni, itm: x0): bool
fun
<x0:t0>
irfilter$test(pos: ni, itm: x0): bool
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:t0>
<y0:vt>
map$fopr(itm: x0): (y0)
fun
<x0:t0>
<y0:vt>
rmap$fopr(itm: x0): (y0)
fun
<x0:t0>
<y0:vt>
imap$fopr(pos: ni, itm: x0): (y0)
fun
<x0:t0>
<y0:vt>
irmap$fopr(pos: ni, itm: x0): (y0)
//
(* ****** ****** *)
//
fun
<x0:t0>
<y0:vt>
mapoptn$fopr(itm: x0): optn_vt(y0)
fun
<x0:t0>
<y0:vt>
rmapoptn$fopr(itm: x0): optn_vt(y0)
fun
<x0:t0>
<y0:vt>
imapoptn$fopr(pos: ni, itm: x0): optn_vt(y0)
fun
<x0:t0>
<y0:vt>
irmapoptn$fopr(pos: ni, itm: x0): optn_vt(y0)
//
(* ****** ****** *)
//
fun
<x0:t0>
<y0:vt>
maplist$fopr(itm: x0): list_vt(y0)
fun
<x0:t0>
<y0:vt>
rmaplist$fopr(itm: x0): list_vt(y0)
fun
<x0:t0>
<y0:vt>
imaplist$fopr(pos: ni, itm: x0): list_vt(y0)
fun
<x0:t0>
<y0:vt>
irmaplist$fopr(pos: ni, itm: x0): list_vt(y0)
//
(* ****** ****** *)
//
fun
<x0:t0>
<y0:vt>
mapstrm$fopr(itm: x0): strm_vt(y0)
fun
<x0:t0>
<y0:vt>
rmapstrm$fopr(itm: x0): strm_vt(y0)
fun
<x0:t0>
<y0:vt>
imapstrm$fopr(pos: ni, itm: x0): strm_vt(y0)
fun
<x0:t0>
<y0:vt>
irmapstrm$fopr(pos: ni, itm: x0): strm_vt(y0)
//
(* ****** ****** *)
//
fun
<x0:t0>
<y0:vt>
mapstrq$fopr(itm: x0): strq_vt(y0)
fun
<x0:t0>
<y0:vt>
rmapstrq$fopr(itm: x0): strq_vt(y0)
fun
<x0:t0>
<y0:vt>
imapstrq$fopr(pos: ni, itm: x0): strq_vt(y0)
fun
<x0:t0>
<y0:vt>
irmapstrq$fopr(pos: ni, itm: x0): strq_vt(y0)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-16:
Tue 16 Jul 2024 10:43:39 AM EDT
*)
fun
<x0:t0>
exists$test(x0: x0): bool
fun
<x0:t0>
exists$tcmp(itm: x0): sint
//
fun
<x0:t0>
rexists$test(x0: x0): bool
fun
<x0:t0>
rexists$tcmp(x0: x0): sint
//
fun
<x0:t0>
iexists$test(ni, x0): bool
fun
<x0:t0>
iexists$tcmp(ni, x0): sint
//
fun
<x0:t0>
irexists$test(ni, x0): bool
fun
<x0:t0>
irexists$tcmp(ni, x0): sint
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt> // HX: vt!
fmake$fwork((*void*)): void
fun
<x0:t0>
fmake$fwork$work(x0: x0): void
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:t0>
c2hoose$forall$test(x0, x0): bool
fun
<x0:t0>
c3hoose$forall$test(x0, x0, x0): bool
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-05-31:
Sat May 31 07:04:48 PM EDT 2025
*)
//
fun
<x0:t0>
<y0:vt>
<e1:vt>
map$e1nv$fopr(itm: x0, env: !e1): (y0)
fun
<x0:t0>
<y0:vt>
<e1:vt>
rmap$e1nv$fopr(itm: x0, env: !e1): (y0)
fun
<x0:t0>
<y0:vt>
<e1:vt>
imap$e1nv$fopr(pos: ni, itm: x0, env: !e1): (y0)
fun
<x0:t0>
<y0:vt>
<e1:vt>
irmap$e1nv$fopr(pos: ni, itm: x0, env: !e1): (y0)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-06-01:
Sun Jun  1 11:04:55 AM EDT 2025
*)
//
fun
<x0:t0>
<e1:vt>
forall$e1nv$test(x0: x0, e1: !e1): bool
fun
<x0:t0>
<e1:vt>
rforall$e1nv$test(x0: x0, e1: !e1): bool
fun
<x0:t0>
<e1:vt>
iforall$e1nv$test(ni, x0, e1: !e1): bool
fun
<x0:t0>
<e1:vt>
irforall$e1nv$test(ni, x0, e1: !e1): bool
//
(* ****** ****** *)
//
fun
<x0:t0>
<e1:vt>
foritm$e1nv$test(x0: x0, e1: !e1): void
fun
<x0:t0>
<e1:vt>
rforitm$e1nv$test(x0: x0, e1: !e1): void
fun
<x0:t0>
<e1:vt>
iforitm$e1nv$test(ni, x0, e1: !e1): void
fun
<x0:t0>
<e1:vt>
irforitm$e1nv$test(ni, x0, e1: !e1): void
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-05:
Mon Jan  5 12:17:18 PM EST 2026
*)
//
fun
<x0:t0>
sortedq$lteq(x1: x0, x2: x0): bool
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_gbas001.sats] *)
(***********************************************************************)
`,
  "SATS/gbas002.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sat 13 Jul 2024 09:24:55 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#typedef ni = nint
(* ****** ****** *)
(* ****** ****** *)
(*
HX-2024-07-13:
We should probably
not go higher to handle z3!!!
*)
#abstype
z2tup_type
(xs:t0,ys:t0) <= (xs,ys)
#sexpdef z2tup = z2tup_type
//
fun
<xs:t0>
<ys:t0>
z2tup_make
(xs:xs, ys:ys): z2tup(xs, ys)
fun
<xs:t0>
<ys:t0>
z2tup_unmk
( ztup
: z2tup(xs, ys)): @( xs, ys )
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x1:t0>
<x2:t0>
z2forall$test
(x1: x1, x2: x2): bool
fun
<x1:t0>
<x2:t0>
z2rforall$test
(x1: x1, x2: x2): bool
fun
<x1:t0>
<x2:t0>
z2iforall$test
(i0: ni, x1: x1, x2: x2): bool
fun
<x1:t0>
<x2:t0>
z2irforall$test
(i0: ni, x1: x1, x2: x2): bool
//
(* ****** ****** *)
//
fun
<x1:t0>
<x2:t0>
z2forcmp$test
(x1: x1, x2: x2): sint
fun
<x1:t0>
<x2:t0>
z2iforcmp$test
(i0: ni, x1: x1, x2: x2): sint
//
(* ****** ****** *)
//
fun
<x1:t0>
<x2:t0>
z2foritm$work
(x1: x1, x2: x2): void
fun
<x1:t0>
<x2:t0>
z2rforitm$work
(x1: x1, x2: x2): void
fun
<x1:t0>
<x2:t0>
z2iforitm$work
(i0: ni, x1: x1, x2: x2): void
fun
<x1:t0>
<x2:t0>
z2irforitm$work
(i0: ni, x1: x1, x2: x2): void
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x1:t0>
<x2:t0>
<r0:vt>
z2folditm$fopr
(x1: x1, x2: x2, r0: r0): (r0)
fun
<x1:t0>
<x2:t0>
<r0:vt>
z2rfolditm$fopr
(x1: x1, x2: x2, r0: r0): (r0)
fun
<x1:t0>
<x2:t0>
<r0:vt>
z2ifolditm$fopr
(i0: ni
,x1: x1, x2: x2, r0: r0): (r0)
fun
<x1:t0>
<x2:t0>
<r0:vt>
z2irfolditm$fopr
(i0: ni
,x1: x1, x2: x2, r0: r0): (r0)
//
fun
<x1:t0>
<x2:t0>
<r0:vt>
z2foldall$fopr
(x1: x1, x2: x2, r0: r0): (bool, r0)
fun
<x1:t0>
<x2:t0>
<r0:vt>
z2rfoldall$fopr
(x1: x1, x2: x2, r0: r0): (bool, r0)
fun
<x1:t0>
<x2:t0>
<r0:vt>
z2ifoldall$fopr
(i0: ni
,x1: x1, x2: x2, r0: r0): (bool, r0)
fun
<x1:t0>
<x2:t0>
<r0:vt>
z2irfoldall$fopr
(i0: ni
,x1: x1, x2: x2, r0: r0): (bool, r0)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x1:t0>
<x2:t0>
<y0:vt>
z2map$fopr(x1: x1, x2: x2): (y0)
fun
<x1:t0>
<x2:t0>
<y0:vt>
z2rmap$fopr(x1: x1, x2: x2): (y0)
fun
<x1:t0>
<x2:t0>
<y0:vt>
z2imap$fopr
  (i0: ni, x1: x1, x2: x2): (y0)
fun
<x1:t0>
<x2:t0>
<y0:vt>
z2irmap$fopr
  (i0: ni, x1: x1, x2: x2): (y0)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x1:t0>
<x2:t0>
<y0:vt>
z2mapoptn$fopr(x1, x2): optn_vt(y0)
fun
<x1:t0>
<x2:t0>
<y0:vt>
z2maplist$fopr(x1, x2): list_vt(y0)
fun
<x1:t0>
<x2:t0>
<y0:vt>
z2mapstrm$fopr(x1, x2): strm_vt(y0)
fun
<x1:t0>
<x2:t0>
<y0:vt>
z2mapstrq$fopr(x1, x2): strq_vt(y0)
//
(* ****** ****** *)
//
fun
<x1:t0>
<x2:t0>
<y0:vt>
z2rmapoptn$fopr(x1, x2): optn_vt(y0)
fun
<x1:t0>
<x2:t0>
<y0:vt>
z2rmaplist$fopr(x1, x2): list_vt(y0)
fun
<x1:t0>
<x2:t0>
<y0:vt>
z2rmapstrm$fopr(x1, x2): strm_vt(y0)
fun
<x1:t0>
<x2:t0>
<y0:vt>
z2rmapstrq$fopr(x1, x2): strq_vt(y0)
//
(* ****** ****** *)
//
fun
<x1:t0>
<x2:t0>
<y0:vt>
z2imapoptn$fopr
(i0: ni, x1: x1, x2: x2): optn_vt(y0)
fun
<x1:t0>
<x2:t0>
<y0:vt>
z2imaplist$fopr
(i0: ni, x1: x1, x2: x2): list_vt(y0)
fun
<x1:t0>
<x2:t0>
<y0:vt>
z2imapstrm$fopr
(i0: ni, x1: x1, x2: x2): strm_vt(y0)
fun
<x1:t0>
<x2:t0>
<y0:vt>
z2imapstrq$fopr
(i0: ni, x1: x1, x2: x2): strq_vt(y0)
//
(* ****** ****** *)
//
fun
<x1:t0>
<x2:t0>
<y0:vt>
z2irmapoptn$fopr
(i0: ni, x1: x1, x2: x2): optn_vt(y0)
fun
<x1:t0>
<x2:t0>
<y0:vt>
z2irmaplist$fopr
(i0: ni, x1: x1, x2: x2): list_vt(y0)
fun
<x1:t0>
<x2:t0>
<y0:vt>
z2irmapstrm$fopr
(i0: ni, x1: x1, x2: x2): strm_vt(y0)
fun
<x1:t0>
<x2:t0>
<y0:vt>
z2irmapstrq$fopr
(i0: ni, x1: x1, x2: x2): strq_vt(y0)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-04:
We should probably
not go higher to handle x3!!!
Sun 04 Aug 2024 08:10:45 AM EDT
*)
#abstype
x2tup_type
(xs:t0,ys:t0) <= (xs,ys)
#sexpdef x2tup = x2tup_type
//
fun
<xs:t0>
<ys:t0>
x2tup_make
(xs:xs, ys:ys): x2tup(xs, ys)
fun
<xs:t0>
<ys:t0>
x2tup_unmk
( xtup
: x2tup(xs, ys)): @( xs, ys )
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x1:t0>
<x2:t0>
x2forall$test
(x1: x1, x2: x2): bool
fun
<x1:t0>
<x2:t0>
ix2forall$test
(i1: ni, x1: x1, i2: ni, x2: x2): bool
//
fun
<x1:t0>
<x2:t0>
x2foritm$work
(x1: x1, x2: x2): void
fun
<x1:t0>
<x2:t0>
ix2foritm$work
(i1: ni, x1: x1, i2: ni, x2: x2): void
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x1:t0>
<x2:t0>
<r0:vt>
x2folditm$fopr
(x1: x1, x2: x2, r0: r0): (r0)
fun
<x1:t0>
<x2:t0>
<r0:vt>
ix2folditm$fopr
(i1: ni, x1: x1
,i2: ni, x2: x2, r0: r0): (r0)
//
fun
<x1:t0>
<x2:t0>
<r0:vt>
x2foldall$fopr
(x1: x1, x2: x2, r0: r0): (bool, r0)
fun
<x1:t0>
<x2:t0>
<r0:vt>
ix2foldall$fopr
(i1: ni, x1: x1
,i2: ni, x2: x2, r0: r0): (bool, r0)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x1:t0>
<x2:t0>
<y0:vt>
x2map$fopr(x1: x1, x2: x2): (y0)
fun
<x1:t0>
<x2:t0>
<y0:vt>
ix2map$fopr
(i1: ni, x1: x1, i2: ni, x2: x2): (y0)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x1:t0>
<x2:t0>
<y0:vt>
x2mapoptn$fopr(x1, x2): optn_vt(y0)
fun
<x1:t0>
<x2:t0>
<y0:vt>
x2maplist$fopr(x1, x2): list_vt(y0)
fun
<x1:t0>
<x2:t0>
<y0:vt>
x2mapstrm$fopr(x1, x2): strm_vt(y0)
fun
<x1:t0>
<x2:t0>
<y0:vt>
x2mapstrq$fopr(x1, x2): strq_vt(y0)
//
(* ****** ****** *)
//
fun
<x1:t0>
<x2:t0>
<y0:vt>
ix2mapoptn$fopr
(i1: ni, x1: x1, i2: ni, x2: x2): optn_vt(y0)
fun
<x1:t0>
<x2:t0>
<y0:vt>
ix2maplist$fopr
(i1: ni, x1: x1, i2: ni, x2: x2): list_vt(y0)
fun
<x1:t0>
<x2:t0>
<y0:vt>
ix2mapstrm$fopr
(i1: ni, x1: x1, i2: ni, x2: x2): strm_vt(y0)
fun
<x1:t0>
<x2:t0>
<y0:vt>
ix2mapstrq$fopr
(i1: ni, x1: x1, i2: ni, x2: x2): strq_vt(y0)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_gbas002.sats] *)
(***********************************************************************)
`,
  "SATS/gcls000.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon 29 Jul 2024 06:15:29 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
(*
HX-2026-01-12:
Mon Jan 12 11:55:56 PM EST 2026
This is 100% boilerplate stuff!
It should be automated eventually.
*)
(* ****** ****** *)
(* ****** ****** *)
#typedef ni = nint
#typedef si = sint
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX:
For functional lists
*)
#abstype
GSEQ_type
(xs: t0, x0: t0) <= xs
#sexpdef GSEQ = GSEQ_type
//
(* ****** ****** *)
//
(*
HX:
For persistent arrays
*)
//
#abstype
GASQ_type
(xs: t0, x0: vt) <= xs
#sexpdef GASQ = GASQ_type
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-13:
These are not needed!
Tue Jan 13 09:38:19 AM EST 2026
fun
<xs:t0>
<x0:t0>
GSEQ_make
(xs: xs): GSEQ(xs, x0)
fun
<xs:t0>
<x0:vt>
GASQ_make
(xs: xs): GASQ(xs, x0)
#symload GSEQ with GSEQ_make of 0000
#symload GASQ with GASQ_make of 0000
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
GSEQ_unmk
(gseq: GSEQ(xs, x0)): (xs)
fun
<xs:t0>
<x0:vt>
GASQ_unmk
(gasq: GASQ(xs, x0)): (xs)
//
#symload unmk with GSEQ_unmk of 1000
#symload unmk with GASQ_unmk of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-11:
GASQ is a subclass of GSEQ!
Sun Jan 11 09:54:46 PM EST 2026
*)
fcast
GASQ_GSEQ$cast
{xs:t0}{x0:t0}
(gasq: GASQ(xs, x0)): GSEQ(xs, x0)
#symload GSEQ with GASQ_GSEQ$cast of 1000
//
(* ****** ****** *)
(* ****** ****** *)
(*
//
HX-2024-08-03:
//
[GSEQ] is
like a functional list (list)
[GASQ] is
like a persistent array (a1sz)
//
*)
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
GSEQ_sum
(gseq: GSEQ(xs, x0)): (x0)
fun
<xs:t0>
<x0:t0>
GSEQ_prod
(gseq: GSEQ(xs, x0)): (x0)
//
#symload sum with GSEQ_sum of 1000
#symload prod with GSEQ_prod of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
GSEQ_length
(gseq: GSEQ(xs, x0)): nint
//
#symload length with GSEQ_length of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
GSEQ_listize
(GSEQ(xs,x0)): list_vt(x0)
fun
<xs:t0>
<x0:t0>
GSEQ_rlistize
(GSEQ(xs,x0)): list_vt(x0)
//
#symload listize with GSEQ_listize of 1000
#symload rlistize with GSEQ_rlistize of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
GSEQ_strmize
(GSEQ(xs,x0)): strm_vt(x0)
fun
<xs:t0>
<x0:t0>
GSEQ_rstrmize
(GSEQ(xs,x0)): strm_vt(x0)
//
#symload strmize with GSEQ_strmize of 1000
#symload rstrmize with GSEQ_rstrmize of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
GSEQ_forall
(gseq: GSEQ(xs, x0)): bool
fun
<xs:t0>
<x0:t0>
GSEQ_exists
(gseq: GSEQ(xs, x0)): bool
fun
<xs:t0>
<x0:t0>
GSEQ_rforall
(gseq: GSEQ(xs, x0)): bool
fun
<xs:t0>
<x0:t0>
GSEQ_rexists
(gseq: GSEQ(xs, x0)): bool
fun
<xs:t0>
<x0:t0>
GSEQ_iforall
(gseq: GSEQ(xs, x0)): bool
fun
<xs:t0>
<x0:t0>
GSEQ_irforall
(gseq: GSEQ(xs, x0)): bool
//
#symload forall with GSEQ_forall of 1000
#symload exists with GSEQ_exists of 1000
#symload rforall with GSEQ_rforall of 1000
#symload rexists with GSEQ_rexists of 1000
#symload iforall with GSEQ_iforall of 1000
#symload irforall with GSEQ_irforall of 1000
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
GSEQ_forall$f1un
( gseq: GSEQ(xs, x0)
, test: ( x0 )->bool): bool
//
#symload forall with GSEQ_forall$f1un of 1000
#symload forall$fun with GSEQ_forall$f1un of 1000
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
GSEQ_exists$f1un
( gseq: GSEQ(xs, x0)
, test: ( x0 )->bool): bool
//
#symload exists with GSEQ_exists$f1un of 1000
#symload exists$fun with GSEQ_exists$f1un of 1000
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
GSEQ_rforall$f1un
( gseq: GSEQ(xs, x0)
, test: ( x0 )->bool): bool
//
#symload rforall with GSEQ_rforall$f1un of 1000
#symload rforall$fun with GSEQ_rforall$f1un of 1000
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
GSEQ_rexists$f1un
( gseq: GSEQ(xs, x0)
, test: ( x0 )->bool): bool
//
#symload rexists with GSEQ_rexists$f1un of 1000
#symload rexists$fun with GSEQ_rexists$f1un of 1000
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
GSEQ_iforall$f2un
( gseq: GSEQ(xs, x0)
, test: (ni, x0)->bool): bool
//
#symload iforall with GSEQ_iforall$f2un of 1000
#symload iforall$fun with GSEQ_iforall$f2un of 1000
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
GSEQ_irforall$f2un
( gseq: GSEQ(xs, x0)
, test: (ni, x0)->bool): bool
//
#symload irforall with GSEQ_irforall$f2un of 1000
#symload irforall$fun with GSEQ_irforall$f2un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
GSEQ_foritm
(gseq: GSEQ(xs, x0)): void
fun
<xs:t0>
<x0:t0>
GSEQ_rforitm
(gseq: GSEQ(xs, x0)): void
fun
<xs:t0>
<x0:t0>
GSEQ_iforitm
(gseq: GSEQ(xs, x0)): void
fun
<xs:t0>
<x0:t0>
GSEQ_irforitm
(gseq: GSEQ(xs, x0)): void
//
#symload foritm with GSEQ_foritm of 1000
#symload rforitm with GSEQ_rforitm of 1000
#symload iforitm with GSEQ_iforitm of 1000
#symload irforitm with GSEQ_irforitm of 1000
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
GSEQ_foritm$f1un
( gseq: GSEQ(xs, x0)
, test: ( x0 )->void): void
//
#symload foritm with GSEQ_foritm$f1un of 1000
#symload foritm$fun with GSEQ_foritm$f1un of 1000
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
GSEQ_rforitm$f1un
( gseq: GSEQ(xs, x0)
, test: ( x0 )->void): void
//
#symload rforitm with GSEQ_rforitm$f1un of 1000
#symload rforitm$fun with GSEQ_rforitm$f1un of 1000
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
GSEQ_iforitm$f2un
( gseq: GSEQ(xs, x0)
, test: (ni, x0)->void): void
//
#symload iforitm with GSEQ_iforitm$f2un of 1000
#symload iforitm$fun with GSEQ_iforitm$f2un of 1000
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
GSEQ_irforitm$f2un
( gseq: GSEQ(xs, x0)
, test: (ni, x0)->void): void
//
#symload irforitm with GSEQ_irforitm$f2un of 1000
#symload irforitm$fun with GSEQ_irforitm$f2un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<r0:vt>
GSEQ_folditm
(
gseq:
GSEQ(xs,x0), r0: r0): (r0)
fun
<xs:t0>
<x0:t0>
<r0:vt>
GSEQ_rfolditm
(
gseq:
GSEQ(xs,x0), r0: r0): (r0)
fun
<xs:t0>
<x0:t0>
<r0:vt>
GSEQ_ifolditm
(
gseq:
GSEQ(xs,x0), r0: r0): (r0)
fun
<xs:t0>
<x0:t0>
<r0:vt>
GSEQ_irfolditm
(
gseq:
GSEQ(xs,x0), r0: r0): (r0)
//
#symload folditm with GSEQ_folditm of 1000
#symload rfolditm with GSEQ_rfolditm of 1000
#symload ifolditm with GSEQ_ifolditm of 1000
#symload irfolditm with GSEQ_irfolditm of 1000
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<r0:vt>
GSEQ_folditm$f2un
( gseq
: GSEQ(xs, x0), r0: r0
, fopr: (r0, x0)->(r0)): (r0)
//
#symload folditm with GSEQ_folditm$f2un of 1000
#symload folditm$fun with GSEQ_folditm$f2un of 1000
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<r0:vt>
GSEQ_rfolditm$f2un
( gseq
: GSEQ(xs, x0), r0: r0
, fopr: (x0, r0)->(r0)): (r0)
//
#symload rfolditm with GSEQ_rfolditm$f2un of 1000
#symload rfolditm$fun with GSEQ_rfolditm$f2un of 1000
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<r0:vt>
GSEQ_ifolditm$f3un
( gseq
: GSEQ(xs, x0), r0: r0
, fopr: (r0, ni, x0)->(r0)): (r0)
//
#symload ifolditm with GSEQ_ifolditm$f3un of 1000
#symload ifolditm$fun with GSEQ_ifolditm$f3un of 1000
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<r0:vt>
GSEQ_irfolditm$f3un
( gseq
: GSEQ(xs, x0), r0: r0
, fopr: (ni, x0, r0)->(r0)): (r0)
//
#symload irfolditm with GSEQ_irfolditm$f3un of 1000
#symload irfolditm$fun with GSEQ_irfolditm$f3un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-03:
[GASQ] is for
persistent arrays with size attched
For instance, it should support ops
like binary search.
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:vt>
GASQ_length
(gasq: GASQ(xs, x0)): nint
//
#symload length with GASQ_length of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:vt>
GASQ_listize
(gasq: GASQ(xs,x0)): list_vt(x0)
fun
<xs:t0>
<x0:vt>
GASQ_rlistize
(gasq: GASQ(xs,x0)): list_vt(x0)
//
#symload listize with GASQ_listize of 1000
#symload rlistize with GASQ_rlistize of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:vt>
GASQ_strmize
(gasq: GASQ(xs,x0)): strm_vt(x0)
fun
<xs:t0>
<x0:vt>
GASQ_rstrmize
(gasq: GASQ(xs,x0)): strm_vt(x0)
//
#symload strmize with GASQ_strmize of 1000
#symload rstrmize with GASQ_rstrmize of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:vt>
GASQ_forall
(gasq: GASQ(xs, x0)): bool
fun
<xs:t0>
<x0:vt>
GASQ_exists
(gasq: GASQ(xs, x0)): bool
//
fun
<xs:t0>
<x0:vt>
GASQ_rforall
(gasq: GASQ(xs, x0)): bool
fun
<xs:t0>
<x0:vt>
GASQ_rexists
(gasq: GASQ(xs, x0)): bool
//
fun
<xs:t0>
<x0:vt>
GASQ_iforall
(gasq: GASQ(xs, x0)): bool
fun
<xs:t0>
<x0:vt>
GASQ_irforall
(gasq: GASQ(xs, x0)): bool
//
#symload forall with GASQ_forall of 1000
#symload exists with GASQ_exists of 1000
#symload rforall with GASQ_rforall of 1000
#symload rexists with GASQ_rexists of 1000
#symload iforall with GASQ_iforall of 1000
#symload irforall with GASQ_irforall of 1000
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:vt>
GASQ_forall$f1un
( gasq: GASQ(xs, x0)
, test: ( !x0 )->bool): bool
//
#symload forall with GASQ_forall$f1un of 1000
#symload forall$fun with GASQ_forall$f1un of 1000
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:vt>
GASQ_exists$f1un
( gasq: GASQ(xs, x0)
, test: ( !x0 )->bool): bool
//
#symload exists with GASQ_exists$f1un of 1000
#symload exists$fun with GASQ_exists$f1un of 1000
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:vt>
GASQ_rforall$f1un
( gasq: GASQ(xs, x0)
, test: ( !x0 )->bool): bool
//
#symload rforall with GASQ_rforall$f1un of 1000
#symload rforall$fun with GASQ_rforall$f1un of 1000
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:vt>
GASQ_rexists$f1un
( gasq: GASQ(xs, x0)
, test: ( !x0 ) -> bool): bool
//
#symload rexists with GASQ_rexists$f1un of 1000
#symload rexists$fun with GASQ_rexists$f1un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:vt>
GASQ_foritm
(gasq: GASQ(xs, x0)): void
fun
<xs:t0>
<x0:vt>
GASQ_rforitm
(gasq: GASQ(xs, x0)): void
fun
<xs:t0>
<x0:vt>
GASQ_iforitm
(gasq: GASQ(xs, x0)): void
fun
<xs:t0>
<x0:vt>
GASQ_irforitm
(gasq: GASQ(xs, x0)): void
//
#symload foritm with GASQ_foritm of 1000
#symload rforitm with GASQ_rforitm of 1000
#symload iforitm with GASQ_iforitm of 1000
#symload irforitm with GASQ_irforitm of 1000
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:vt>
GASQ_foritm$f1un
( gasq: GASQ(xs, x0)
, test: ( x0 )->void): void
//
#symload foritm with GASQ_foritm$f1un of 1000
#symload foritm$fun with GASQ_foritm$f1un of 1000
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:vt>
GASQ_rforitm$f1un
( gasq: GASQ(xs, x0)
, test: ( x0 )->void): void
//
#symload rforitm with GASQ_rforitm$f1un of 1000
#symload rforitm$fun with GASQ_rforitm$f1un of 1000
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:vt>
GASQ_iforitm$f2un
( gasq: GASQ(xs, x0)
, test: (ni, x0)->void): void
//
#symload iforitm with GASQ_iforitm$f2un of 1000
#symload iforitm$fun with GASQ_iforitm$f2un of 1000
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:vt>
GASQ_irforitm$f2un
( gasq: GASQ(xs, x0)
, test: (ni, x0)->void): void
//
#symload irforitm with GASQ_irforitm$f2un of 1000
#symload irforitm$fun with GASQ_irforitm$f2un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_gcls000.sats] *)
(***********************************************************************)
`,
  "SATS/gdbg000.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon 05 Aug 2024 10:10:05 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-05:
Mon 05 Aug 2024 10:17:21 PM EDT
ATS3 amply enables programmers to
implement debugging support from the
"outside"; the point to be stressed here
is that these programmers are not supposed
to have any direct access to the internals
of the ATS3/Xanadu implemnetation!
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#abstype
type_vw_t0(a:vw) <= unit
#sexpdef type = type_vw_t0
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
g_type
{t0:t0}(x0: t0): type(t0)
fun<>
g_vwtp
{vt:vt}(x0: !vt): type(vt)
fun<>
g_prop
{pf:pp}(x0: pf|): type(pf)
fun<>
g_view
{vw:vw}(x0: !vw|): type(vw)
//
#symload type with g_type of 0100
#symload vwtp with g_vwtp of 0100
#symload prop with g_prop of 0100
#symload view with g_view of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-06:
These are the Number~1
functions for debugging
*)
//
fun
<vt:vt>
g_debug( x0:vt ): ( vt )
//
(* ****** ****** *)
//
fun
<vw:vw>
g_psort((*void*)): ( void )
fun
<vw:vw>
g_ptype((*void*)): ( void )
(*
HX-2025-05-08:
For printing out
only the type constructor.
[g_ptcon<list(...)>()]
prints out 'list' only
while skipping the argument
type, that is, the type for
list elements.
*)
fun
<vw:vw>
g_ptcon((*void*)): ( void )
//
(* ****** ****** *)
//
fun
<vw:vw>
g_sort$strn((*void*)): ( strn )
fun
<vw:vw>
g_type$strn((*void*)): ( strn )
fun
<vw:vw>
g_tcon$strn((*void*)): ( strn )
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
#symload debug with g_debug of 0100
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
bool_assert
(cond: bool): void
fun<>
assert$errmsg
( (*void*) ): strn
fun<>
bool_assert$errmsg
(cond: bool, msg: strn): void
//
#symload
assert with bool_assert of 1000
#symload
assert with bool_assert$errmsg of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_gdbg000.sats] *)
(***********************************************************************)
`,
  "SATS/gflt000.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Fri 26 Jul 2024 09:27:30 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
sflt_print(sflt): void
fun<>
dflt_print(dflt): void
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
dflt_abs(df: dflt): dflt
#symload abs with dflt_abs of 1000
//
fun<>
dflt_neg(df: dflt): dflt
#symload - with dflt_neg of 1000
#symload neg with dflt_neg of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
dflt_suc(df: dflt): dflt
fun<>
dflt_pre(df: dflt): dflt
//
#symload suc with dflt_suc of 1000
#symload pre with dflt_pre of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
dflt_sqr(df: dflt): dflt
#symload sqr with dflt_sqr of 1000
fun<>
dflt_cbr(df: dflt): dflt
#symload cbr with dflt_cbr of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
dflt_sqrt(df: dflt): dflt
#symload sqrt with dflt_sqrt of 1000
fun<>
dflt_cbrt(df: dflt): dflt
#symload cbrt with dflt_cbrt of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
dflt_lt$dflt
(f1: dflt, f2: dflt): bool
fun<>
dflt_gt$dflt
(f1: dflt, f2: dflt): bool
fun<>
dflt_eq$dflt
(f1: dflt, f2: dflt): bool
//
#symload < with dflt_lt$dflt of 1000
#symload > with dflt_gt$dflt of 1000
#symload = with dflt_eq$dflt of 1000
//
fun<>
dflt_lte$dflt
(f1: dflt, f2: dflt): bool
fun<>
dflt_gte$dflt
(f1: dflt, f2: dflt): bool
fun<>
dflt_neq$dflt
(f1: dflt, f2: dflt): bool
//
#symload <= with dflt_lte$dflt of 1000
#symload >= with dflt_gte$dflt of 1000
#symload != with dflt_neq$dflt of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
sint_lt$dflt
(i1: sint, f2: dflt): bool
fun<>
dflt_lt$sint
(f1: dflt, i2: sint): bool
//
#symload < with sint_lt$dflt of 1000
#symload < with dflt_lt$sint of 1000
//
(* ****** ****** *)
//
fun<>
sint_gt$dflt
(i1: sint, f2: dflt): bool
fun<>
dflt_gt$sint
(f1: dflt, i2: sint): bool
//
#symload > with sint_gt$dflt of 1000
#symload > with dflt_gt$sint of 1000
//
(* ****** ****** *)
//
fun<>
sint_eq$dflt
(i1: sint, f2: dflt): bool
fun<>
dflt_eq$sint
(f1: dflt, i2: sint): bool
//
#symload = with sint_eq$dflt of 1000
#symload = with dflt_eq$sint of 1000
//
(* ****** ****** *)
//
fun<>
sint_lte$dflt
(i1: sint, f2: dflt): bool
fun<>
dflt_lte$sint
(f1: dflt, i2: sint): bool
//
#symload <= with sint_lte$dflt of 1000
#symload <= with dflt_lte$sint of 1000
//
(* ****** ****** *)
//
fun<>
sint_gte$dflt
(i1: sint, f2: dflt): bool
fun<>
dflt_gte$sint
(f1: dflt, i2: sint): bool
//
#symload >= with sint_gte$dflt of 1000
#symload >= with dflt_gte$sint of 1000
//
(* ****** ****** *)
//
fun<>
sint_neq$dflt
(i1: sint, f2: dflt): bool
fun<>
dflt_neq$sint
(f1: dflt, i2: sint): bool
//
#symload != with sint_neq$dflt of 1000
#symload != with dflt_neq$sint of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
dflt_cmp$dflt
(f1: dflt, f2: dflt): sint
//
fun<>
sint_cmp$dflt
(i1: sint, f2: dflt): sint
fun<>
dflt_cmp$sint
(f1: dflt, i2: sint): sint
//
#symload cmp with dflt_cmp$dflt of 1000
#symload cmp with dflt_cmp$dflt of 1000
#symload cmp with dflt_cmp$dflt of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
dflt_add$dflt
(f1: dflt, f2: dflt): dflt
fun<>
dflt_sub$dflt
(f1: dflt, f2: dflt): dflt
fun<>
dflt_mul$dflt
(f1: dflt, f2: dflt): dflt
fun<>
dflt_div$dflt
(f1: dflt, f2: dflt): dflt
fun<>
dflt_mod$dflt
(f1: dflt, f2: dflt): dflt
//
#symload + with dflt_add$dflt of 1000
#symload - with dflt_sub$dflt of 1000
#symload * with dflt_mul$dflt of 1000
#symload / with dflt_div$dflt of 1000
#symload % with dflt_mod$dflt of 1000
//
(* ****** ****** *)
//
fun<>
dflt_add$sint
(f1: dflt, i2: sint): dflt
fun<>
sint_add$dflt
(i1: sint, f2: dflt): dflt
//
fun<>
dflt_sub$sint
(f1: dflt, i2: sint): dflt
fun<>
sint_sub$dflt
(i1: sint, f2: dflt): dflt
//
fun<>
dflt_mul$sint
(f1: dflt, i2: sint): dflt
fun<>
sint_mul$dflt
(i1: sint, f2: dflt): dflt
//
fun<>
dflt_div$sint
(f1: dflt, i2: sint): dflt
fun<>
sint_div$dflt
(i1: sint, f2: dflt): dflt
//
fun<>
dflt_mod$sint
(f1: dflt, i2: sint): dflt
//
(* ****** ****** *)
//
#symload + with dflt_add$sint of 1000
#symload + with sint_add$dflt of 1000
//
#symload - with dflt_sub$sint of 1000
#symload - with sint_sub$dflt of 1000
//
#symload * with dflt_mul$sint of 1000
#symload * with sint_mul$dflt of 1000
//
#symload / with dflt_div$sint of 1000
#symload / with sint_div$dflt of 1000
//
#symload % with dflt_mod$sint of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-21:
Sat Sep 21 03:28:45 PM EDT 2024
*)
//
fun<>
dflt_ceil(df: dflt): dflt//fun<>
fun<>
dflt_floor(df: dflt): dflt//fun<>
fun<>
dflt_round(df: dflt): dflt//fun<>
fun<>
dflt_trunc(df: dflt): dflt//fun<>
//
#symload ceil with dflt_ceil of 1000
#symload floor with dflt_floor of 1000
#symload round with dflt_round of 1000
#symload trunc with dflt_trunc of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_gflt000.sats] *)
(***********************************************************************)
`,
  "SATS/gfun000.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Tue 06 Aug 2024 05:59:04 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
(*
HX:
For functions
(fnp,cfp,cfr,etc)
Note that 'fun' is
meant to be generic;
it is to be resolved
*after* type-checking!
*)
(* ****** ****** *)
(* ****** ****** *)
#typedef
f0un(r0:vt) = () -> r0
(* ****** ****** *)
#typedef
f1un
(a1:t0,r0:vt) = (a1)->r0
(* ****** ****** *)
#typedef
f2un
(a1:t0
,a2:t0,r0:vt) = (a1,a2)->r0
(* ****** ****** *)
#typedef
f3un
(a1:t0
,a2:t0
,a3:t0,r0:vt) = (a1,a2,a3)->r0
(* ****** ****** *)
#typedef
f4un
(a1:t0
,a2:t0
,a3:t0
,a4:t0,r0:vt) = (a1,a2,a3,a4)->r0
(* ****** ****** *)
#typedef
f5un
(a1:t0
,a2:t0
,a3:t0
,a4:t0
,a5:t0,r0:vt) = (a1,a2,a3,a4,a5)->r0
(* ****** ****** *)
#typedef
f6un
(a1:t0
,a2:t0
,a3:t0
,a4:t0
,a5:t0
,a6:t0,r0:vt) = (a1,a2,a3,a4,a5,a6)->r0
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a1:t0>
f1un_not
( f0
: f1un(a1,bool)): f1un(a1,bool)
//
#symload not with f1un_not of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
f0un_nint$repeat
( f0
: f0un(void), ni: nint): void
fun<>
nint_repeat$f0un
(times: nint, f0: f0un(void)): void
//
#symload
repeat with f0un_nint$repeat of 1000
#symload
repeat with nint_repeat$f0un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
f0un_enum$make_strx_vt
  (xs: strx_vt(x0)): f0un( x0 )
fun
<x0:vt>
f0un_enum$make_strm_vt
  (xs: strm_vt(x0)): f0un(optn_vt(x0))
//
(* ****** ****** *)
//
fun
<r0:vt>
strx_vt_iter$make
(fopr: (!r0)->r0, r0: r0): strx_vt(r0)
#symload
f1un_iter with strx_vt_iter$make of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-14:
Wed Jan 14 12:41:56 PM EST 2026
Whether [x0] is a member of [xs]?
*)
fun
<xs:t0>
<x0:t0>
f1un_gseq$srch$make(xs): f1un(x0, bool)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX: for run-time testing
Sun Aug 13 21:10:14 EDT 2023
*)
//
(*
HX: f0(x0) = r0?
*)
fun
<x0:t0>
<r0:vt>
f1un_equal$at
(f0: f1un(x0, r0), x0: x0, r0: r0): bool
//
fun
<x0:t0>
<y0:vt>
f1un_rand$equal
(f1: f1un(x0, y0), f2: f1un(x0, y0)): bool
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<r0:vt>
f0un_trace
(
f00:
f0un(r0), msg: strn): f0un(r0)
fun
<a1:t0>
<r0:vt>
f1un_trace
(
f00:
f1un(a1,r0), msg: strn): f1un(a1,r0)
fun
<a1:t0>
<a2:t0>
<r0:vt>
f2un_trace
(
f00:
f2un(a1,a2,r0), msg: strn): f2un(a1,a2,r0)
fun
<a1:t0>
<a2:t0>
<a3:t0>
<r0:vt>
f3un_trace
(
f00:
f3un(a1,a2,a3,r0), msg: strn): f3un(a1,a2,a3,r0)
//
(* ****** ****** *)
//
fun
<a1:t0>
<a2:t0>
<a3:t0>
<a4:t0>
<r0:vt>
f4un_trace
(
f00:
f4un(a1,a2,a3,a4,r0), msg: strn): f4un(a1,a2,a3,a4,r0)
//
(* ****** ****** *)
//
fun
<a1:t0>
<a2:t0>
<a3:t0>
<a4:t0>
<a5:t0>
<r0:vt>
f5un_trace
(
f00:
f5un(a1,a2,a3,a4,a5,r0), msg: strn): f5un(a1,a2,a3,a4,a5,r0)
//
(* ****** ****** *)
//
fun
<a1:t0>
<a2:t0>
<a3:t0>
<a4:t0>
<a5:t0>
<a6:t0>
<r0:vt>
f6un_trace
(
f00:
f6un(a1,a2,a3,a4,a5,a6,r0), msg: strn): f6un(a1,a2,a3,a4,a5,a6,r0)
//
(* ****** ****** *)
//
#symload trace with f0un_trace of 1000
#symload trace with f1un_trace of 1000
#symload trace with f2un_trace of 1000
#symload trace with f3un_trace of 1000
#symload trace with f4un_trace of 1000
#symload trace with f5un_trace of 1000
#symload trace with f6un_trace of 1000
//
#symload f_trace with f0un_trace of 1000
#symload f_trace with f1un_trace of 1000
#symload f_trace with f2un_trace of 1000
#symload f_trace with f3un_trace of 1000
#symload f_trace with f4un_trace of 1000
#symload f_trace with f5un_trace of 1000
#symload f_trace with f6un_trace of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-05-29:
Thu May 29 05:22:09 PM EDT 2025
*)
//
fun
<x0:t0>
<y0:t0>
f1un_map$list
(f00: (x0) -> y0): list(x0) -> list(y0)
fun
<x0:vt>
<y0:vt>
f1un_map0$llist
(f00: (~x0) -> y0): list_vt(x0) -> list_vt(y0)
fun
<x0:vt>
<y0:vt>
f1un_map1$llist
(f00: (!x0) -> y0): (!list_vt(x0)) -> list_vt(y0)
//
(* ****** ****** *)
//
#symload f_map$list with f1un_map$list of 1000
#symload f_map0$llist with f1un_map0$llist of 1000
#symload f_map1$llist with f1un_map1$llist of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:t0>
<y0:t0>
f1un_map$optn
( f00
: (x0) -> y0): optn(x0) -> optn(y0)
fun
<x0:vt>
<y0:vt>
f1un_map0$loptn
( f00
: (~x0) -> y0): optn_vt(x0) -> optn_vt(y0)
fun
<x0:vt>
<y0:vt>
f1un_map1$loptn
( f00
: (!x0) -> y0): (!optn_vt(x0)) -> optn_vt(y0)
//
(* ****** ****** *)
//
#symload f_map$optn with f1un_map$optn of 1000
#symload f_map0$loptn with f1un_map0$loptn of 1000
#symload f_map1$loptn with f1un_map1$loptn of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-06-01:
Sun Jun  1 05:25:29 PM EDT 2025
*)
//
fun
<x0:t0>
<y0:t0>
<e1:vt>
f1un_map$e1nv$list
(f00
:(x0, !e1)->(y0)): (list(x0), !e1)->list(y0)
fun
<x0:vt>
<y0:vt>
<e1:vt>
f1un_map$e1nv0$llist
(f00
:(~x0, !e1)->(y0)): (~list_vt(x0), !e1)->list_vt(y0)
fun
<x0:vt>
<y0:vt>
<e1:vt>
f1un_map$e1nv1$llist
(f00
:(!x0, !e1)->(y0)): (!list_vt(x0), !e1)->list_vt(y0)
//
(* ****** ****** *)
//
#symload f_map$list with f1un_map$e1nv$list of 1000
#symload f_map0$llist with f1un_map$e1nv0$llist of 1000
#symload f_map1$llist with f1un_map$e1nv1$llist of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:t0>
<y0:t0>
<e1:vt>
f1un_map$e1nv$optn
(f00
:(x0, !e1)->(y0)): (optn(x0), !e1)->optn(y0)
fun
<x0:vt>
<y0:vt>
<e1:vt>
f1un_map$e1nv0$loptn
(f00
:(~x0, !e1)->(y0)): (~optn_vt(x0), !e1)->optn_vt(y0)
fun
<x0:vt>
<y0:vt>
<e1:vt>
f1un_map$e1nv1$loptn
(f00
:(!x0, !e1)->(y0)): (!optn_vt(x0), !e1)->optn_vt(y0)
//
(* ****** ****** *)
//
#symload f_map$optn with f1un_map$e1nv$optn of 1000
#symload f_map0$loptn with f1un_map$e1nv0$loptn of 1000
#symload f_map1$loptn with f1un_map$e1nv1$loptn of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_gfun000.sats] *)
(***********************************************************************)
`,
  "SATS/gint000.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Fri 26 Jul 2024 09:27:30 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-01:
Note that
[sint_print] may not be
the same as g_print<sint>
*)
//
fun<>
sint_print(i0: sint): void
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
sint_neg
{i:i0}(x: sint(i)): sint(-i)
#symload - with sint_neg of 1000
#symload neg with sint_neg of 1000
//
(* ****** ****** *)
//
fun<>
sint_suc
{i:i0}(x: sint(i)): sint(i+1)
fun<>
sint_pre
{i:i0}(x: sint(i)): sint(i-1)
//
#symload suc with sint_suc of 1000
#symload pre with sint_pre of 1000
//
(* ****** ****** *)
//
fun<>
sint_abs
{i:i0}(x: sint(i)): sint(abs(i))
#symload abs with sint_abs of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
sint_lt$sint
{i,j:i0}
(x:sint(i), y:sint(j)): bool(i<j)
fun<>
sint_gt$sint
{i,j:i0}
(x:sint(i), y:sint(j)): bool(i>j)
fun<>
sint_eq$sint
{i,j:i0}
(x:sint(i), y:sint(j)): bool(i=j)
//
#symload < with sint_lt$sint of 1000
#symload > with sint_gt$sint of 1000
#symload = with sint_eq$sint of 1000
//
fun<>
sint_lte$sint
{i,j:i0}
(x:sint(i), y:sint(j)): bool(i<=j)
fun<>
sint_gte$sint
{i,j:i0}
(x:sint(i), y:sint(j)): bool(i>=j)
fun<>
sint_neq$sint
{i,j:i0}
(x:sint(i), y:sint(j)): bool(i!=j)
//
#symload <= with sint_lte$sint of 1000
#symload >= with sint_gte$sint of 1000
#symload != with sint_neq$sint of 1000
//
fun<>
sint_cmp$sint
{i,j:i0}
(x:sint(i), y:sint(j)): sint(sgn(i-j))
//
#symload cmp with sint_cmp$sint of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
sint_add$sint
{i,j:i0}
(x: sint(i), y: sint(j)): sint(i+j)
fun<>
sint_sub$sint
{i,j:i0}
(x: sint(i), y: sint(j)): sint(i-j)
fun<>
sint_mul$sint
{i,j:i0}
(x: sint(i), y: sint(j)): sint(i*j)
fun<>
sint_div$sint
{i,j:i0}
(x: sint(i), y: sint(j)): sint(i/j)
fun<>
sint_mod$sint
{i,j:i0}
(x: sint(i), y: sint(j)): sint(i%j)
//
#symload + with sint_add$sint of 1000
#symload - with sint_sub$sint of 1000
#symload * with sint_mul$sint of 1000
#symload / with sint_div$sint of 1000
#symload % with sint_mod$sint of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-04:
Is GSEQ coming of age?
Sun 04 Aug 2024 08:24:43 AM EDT
*)
//
fcast // fun
GSEQ_make_nint0
(xs: nint): GSEQ(nint, unit)
fcast // fun
GSEQ_make_nint1
(xs: nint): GSEQ(nint, nint)
#symload GSEQ with GSEQ_make_nint1 of 1000
#symload GSEQ_nint0 with GSEQ_make_nint0 of 1000
#symload GSEQ_nint1 with GSEQ_make_nint1 of 1000
//
fcast // fun
GASQ_make_nint0
(xs: nint): GASQ(nint, unit)
fcast // fun
GASQ_make_nint1
(xs: nint): GASQ(nint, nint)
#symload GASQ with GASQ_make_nint1 of 1000
#symload GASQ_nint0 with GASQ_make_nint0 of 1000
#symload GASQ_nint1 with GASQ_make_nint1 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-09-26:
For unsigned integers
Fri Sep 26 01:26:32 AM EDT 2025
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
sint_to$uint(sint): uint
fun<>
uint_to$sint(uint): sint
//
#symload iu2s
with uint_to$sint of 1000
#symload is2u
with sint_to$uint of 1000
//
(* ****** ****** *)
//
(*
HX-2025-09-26:
Note that
[uint_print] may not be
the same as g_print<uint>
*)
//
fun<>
uint_print(i0: uint): void
//
(* ****** ****** *)
//
fun<>
uint_suc
{i:i0}(x: uint(i)): uint(i+1)
fun<>
uint_pre
{i:i0|i>0}(x: uint(i)): uint(i-1)
//
(* ****** ****** *)
//
fun<>
uint_lnot(x: uint): uint
//
fun<>
uint_ladd(x: uint, y: uint): uint
fun<>
uint_lmul(x: uint, y: uint): uint
fun<>
uint_lneq(x: uint, y: uint): uint
//
#symload lorr with uint_ladd of 1000
#symload land with uint_lmul of 1000
#symload lxor with uint_lneq of 1000
//
#symload lnot with uint_lnot of 1000
//
#symload ladd with uint_ladd of 1000
#symload lmul with uint_lmul of 1000
#symload lneq with uint_lneq of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_gint000.sats] *)
(***********************************************************************)
`,
  "SATS/gint001.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Fri 12 Jul 2024 11:22:47 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#typedef ni = nint
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
nint_strmize
(xs: nint): strm_vt(ni)
fun<>
nint_strqize
{sz:i0}
(xs: nint(sz)): strq_vt(ni,sz)
//
(* ****** ****** *)
//
fun<>
nint_rstrmize
(xs: nint): strm_vt(ni)
fun<>
nint_rstrqize
{sz:i0}
(xs: nint(sz)): strq_vt(ni,sz)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
nint_forall(xs: nint): bool
fun<>
nint_rforall(xs: nint): bool
(*
fun<>
nint_iforall(xs: nint): bool
fun<>
nint_irforall(xs: nint): bool
*)
//
#symload
forall with nint_forall of 1000
#symload
rforall with nint_rforall of 1000
(*
#symload
iforall with nint_iforall of 1000
#symload
irforall with nint_irforall of 1000
*)
//
(* ****** ****** *)
//
fun<>
nint_forall$f1un
(ni: nint, test: (ni)->bool): bool
#symload
forall with nint_forall$f1un of 1000
#symload
nint_forall with nint_forall$f1un of 1000
//
fun<>
nint_rforall$f1un
(ni: nint, test: (ni)->bool): bool
#symload
rforall with nint_rforall$f1un of 1000
#symload
nint_rforall with nint_rforall$f1un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-07:
There is no need for these
special function interfaces!
Wed 07 Aug 2024 01:58:00 PM EDT
*)
(*
HX-2024-08-26:
Mon 26 Aug 2024 07:19:34 AM EDT
However, these interfaces do
help support symbol overloading!
*)
//
fun<>
nint_foritm(xs: nint): void
fun<>
nint_rforitm(xs: nint): void
(*
fun<>
nint_iforitm(xs: nint): void
fun<>
nint_irforitm(xs: nint): void
*)
//
#symload
foritm with nint_foritm of 1000
#symload
rforitm with nint_rforitm of 1000
(*
#symload
iforitm with nint_iforitm of 1000
#symload
irforitm with nint_irforitm of 1000
*)
//
(* ****** ****** *)
//
fun<>
nint_foritm$f1un
(ni: nint, work: (ni)->void): void
#symload
foritm with nint_foritm$f1un of 1000
#symload
nint_foritm with nint_foritm$f1un of 1000
//
fun<>
nint_rforitm$f1un
(ni: nint, work: (ni)->void): void
#symload
rforitm with nint_rforitm$f1un of 1000
#symload
nint_rforitm with nint_rforitm$f1un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<y0:t0>
nint_map_list
 {n0:i0}
(xs: nint(n0)): list(y0, n0)
fun
<y0:t0>
nint_map$f1un_list
 {n0:i0}
(xs: nint(n0)
,f0: nintlt(n0)->y0): list(y0, n0)
//
#symload
map_list with nint_map_list of 1000
#symload
map_list with nint_map$f1un_list of 1000
#symload
nint_map_list with nint_map$f1un_list of 1000
//
(* ****** ****** *)
//
fun
<y0:vt>
nint_map_llist
 {n0:i0}
(xs: nint(n0)): list_vt(y0, n0)
fun
<y0:vt>
nint_map$f1un_llist
 {n0:i0}
(xs: nint(n0)
,f0: nintlt(n0)->y0): list_vt(y0, n0)
//
#symload
map_llist with nint_map_llist of 1000
#symload
map_llist with nint_map$f1un_llist of 1000
#symload
nint_map_llist with nint_map$f1un_llist of 1000
//
(* ****** ****** *)
//
fun
<y0:vt>
nint_rmap_llist
 {n0:i0}
(xs: nint(n0)): list_vt(y0, n0)
fun
<y0:vt>
nint_rmap$f1un_llist
 {n0:i0}
(xs: nint(n0)
,f0: nintlt(n0)->y0): list_vt(y0, n0)
//
#symload
rmap_llist with nint_rmap_llist of 1000
#symload
rmap_llist with nint_rmap$f1un_llist of 1000
#symload
nint_rmap_llist with nint_rmap$f1un_llist of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-22:
Mon 22 Jul 2024 11:48:37 AM EDT
*)
//
fun
<y0:vt>
nint_map_lstrm(xs: nint): strm_vt(y0)
//
#symload
map_lstrm with nint_map_lstrm of 1000
//
fun
<y0:vt>
nint_map$f1un_lstrm
( xs: nint
, fopr: ( nint )->(y0)): strm_vt(y0)
//
#symload
map_lstrm with nint_map$f1un_lstrm of 1000
#symload
nint_map_lstrm with nint_map$f1un_lstrm of 1000
//
(* ****** ****** *)
//
fun
<y0:vt>
nint_rmap_lstrm(xs: nint): strm_vt(y0)
//
#symload
rmap_lstrm with nint_rmap_lstrm of 1000
//
fun
<y0:vt>
nint_rmap$f1un_lstrm
( xs: nint
, fopr: ( nint )->(y0)): strm_vt(y0)
//
#symload
rmap_lstrm with nint_rmap$f1un_lstrm of 1000
#symload
nint_rmap_lstrm with nint_rmap$f1un_lstrm of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-31:
Wed 31 Jul 2024 09:05:27 AM EDT
HX-2026-01-11:
This has been moved to pre2026!
Sun Jan 11 10:38:10 PM EST 2026
//
fun<>
nint_digitize
 (n0: nint): strm_vt(nintlt(10))
fun<>
nint_base$digitize
{base:i0|base >= 2}
(nint, sint(base)): strm_vt(nintlt(base))
//
#symload digitize with nint_digitize of 1000
#symload digitize with nint_base$digitize of 1000
//
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-01-10:
Sun Jan 12 09:44:35 AM EST 2025
*)
//
fun
<r0:vt>
nint_folditm
(xs: nint, r0: r0): (r0)
fun
<r0:vt>
nint_rfolditm
(xs: nint, r0: r0): (r0)
//
#symload
folditm with nint_folditm of 1000
#symload
rfolditm with nint_rfolditm of 1000
//
(* ****** ****** *)
//
fun
<r0:vt>
nint_folditm$f2un
(xs: nint
,r0: r0, fopr: (r0, ni)-> r0): (r0)
fun
<r0:vt>
nint_rfolditm$f2un
(xs: nint
,r0: r0, fopr: (ni, r0)-> r0): (r0)
//
#symload
folditm with nint_folditm$f2un of 1000
#symload
rfolditm with nint_rfolditm$f2un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-27:
Sat Dec 27 12:37:56 PM EST 2025
*)
fun<>
nint_listize
{sz:i0}(xs: nint(sz)): list_vt(ni,sz)
fun<>
nint_rlistize
{sz:i0}(xs: nint(sz)): list_vt(ni,sz)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_gint001.sats] *)
(***********************************************************************)
`,
  "SATS/gmap000.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
MAP: functional map
Sun 08 Sep 2024 10:45:33 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<map:vt>
<key:vt>
<itm:vt>
gmap_nil((*0*)): map
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<map:t0>
<key:t0>
<itm:t0>
gmap_size(kxs: map): nint
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-08:
For gmap_print
For print0/1 as well
*)
fun
<map:vt>
<key:vt>
<itm:vt>
gmap_beg((*void*)): strn
fun
<map:vt>
<key:vt>
<itm:vt>
gmap_end((*void*)): strn
fun
<map:vt>
<key:vt>
<itm:vt>
gmap_sep((*void*)): strn
//
(* ****** ****** *)
//
fun
<map:t0>
<key:t0>
<itm:t0>
gmap_print(kxs: map): void
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<map:t0>
<key:t0>
<itm:t0>
gmap_keyq
(kxs: map, key: key): bool
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<map:t0>
<key:t0>
<itm:t0>
gmap_get$at
(kxs: map, key: key): itm
fun
<map:t0>
<key:t0>
<itm:t0>
gmap_get$at$exn
(kxs: map, key: key): itm
fun
<map:t0>
<key:t0>
<itm:t0>
gmap_get$at$opt
// HX: nil if !keyq(key)
// HX: cons(old) if keyq(key)
(kxs: map, key: key): optn_vt(itm)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-05-02:
The semantics is involved
for a mutable map (hashmap)!
*)
fun
<amp:t0>
<key:t0>
<itm:t0>
gmap_strmize
(kxs: amp): strm_vt@(key, itm)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<map:t0>
<key:t0>
<itm:t0>
gmap_search$tst
(kxs: map, key: key): bool
fun
<map:t0>
<key:t0>
<itm:t0>
gmap_search$opt
(kxs: map, key: key): optn_vt(itm)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-08
These are for functional maps!
*)
//
(*
HX-2025-12-24:
Using [getout$old] if [key]
is known in the given map [map]
*)
(*
fun
<map:t0>
<key:t0>
<itm:t0>
gmap_getout$any
( kxs
: map, key: key): (map, itm)
*)
fun
<map:t0>
<key:t0>
<itm:t0>
gmap_getout$old
( kxs
: map, key: key): (map, itm)
fun
<map:t0>
<key:t0>
<itm:t0>
gmap_getout$opt
( kxs: map
, key: key): (map, optn_vt(itm))
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-24:
These are for functional maps!
Wed Dec 24 01:10:05 PM EST 2025
*)
(*
HX-2025-12-24:
Using [insert$new] if [key] is
known not in the given map [map]
*)
(*
fun
<map:t0>
<key:t0>
<itm:t0>
gmap_insert$any
(kxs: map
,key: key, itm: itm): map
*)
fun
<map:t0>
<key:t0>
<itm:t0>
gmap_insert$new
(kxs: map
,key: key, itm: itm): map
fun
<map:t0>
<key:t0>
<itm:t0>
gmap_insert$opt
( kxs: map
, key: key
, itm: itm): (map, optn_vt(itm))
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_gmap000.sats] *)
(***********************************************************************)
`,
  "SATS/gmap001.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sun 08 Sep 2024 01:55:00 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<map:t0>
<key:t0>
<itm:t0>
gmap_key$strmize(map): strm_vt(key)
fun
<map:t0>
<key:t0>
<itm:t0>
gmap_val$strmize(map): strm_vt(itm)
fun
<map:t0>
<key:t0>
<itm:t0>
gmap_keyval$strmize(map): strm_vt@(key, itm)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_gmap001.sats] *)
(***********************************************************************)
`,
  "SATS/gnum000.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Fri 12 Jul 2024 06:59:23 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:vt>
g_0((*void*)): (a)
fun
<a:vt>
g_1((*void*)): (a)
fun
<a:vt>
g_2((*void*)): (a)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:vt>
g_si(i0: sint): (a)
fun
<a:vt>
g_ui(u0: uint): (a)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:vt>
g_sf(f0: sflt): (a)
fun
<a:vt>
g_df(f0: dflt): (a)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:t0>
g_neg(x0: x0): (x0)
fun
<x0:t0>
g_abs(x0: x0): (x0)
//
fun
<x0:t0>
g_suc(x0: x0): (x0)
fun
<x0:t0>
g_pre(x0: x0): (x0)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:t0>
g_add( x0, x0 ): (x0)
fun
<x0:t0>
g_sub( x0, x0 ): (x0)
fun
<x0:t0>
g_mul( x0, x0 ): (x0)
fun
<x0:t0>
g_div( x0, x0 ): (x0)
fun
<x0:t0>
g_mod( x0, x0 ): (x0)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:t0>
g_sqr( x0 ): (x0)
fun
<x0:t0>
g_cbe( x0 ): (x0)
fun
<x0:t0>
g_pow(x0, nint): (x0)
//
(* ****** ****** *)
//
(*
HX-2024-08-17:
This may not be
a good place for g_ncpy!
Sat 17 Aug 2024 09:20:01 PM EDT
*)
fun
<x0:t0>
g_ncpy(x0, nint): (x0)
#symload ncpy with g_ncpy of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_gnum000.sats] *)
(***********************************************************************)
`,
  "SATS/gord000.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sat 10 Aug 2024 03:05:09 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
//
fun
<a:t0>
g_lt(a, a): bool
fun
<a:t0>
g_gt(a, a): bool
fun
<a:t0>
g_eq(a, a): bool
//
fun
<a:t0>
g_lte(a, a): bool
fun
<a:t0>
g_gte(a, a): bool
fun
<a:t0>
g_neq(a, a): bool
//
(* ****** ****** *)
//
fun
<a:t0>
g_cmp(a, a): sint
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:t0>
g_max( x0, x0 ): (x0)
fun
<x0:t0>
g_min( x0, x0 ): (x0)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-04-25:
generic zero-comparisons
*)
//
fun
<x0:t0>
g_ltz( x0: x0 ): (bool)
fun
<x0:t0>
g_gtz( x0: x0 ): (bool)
fun
<x0:t0>
g_eqz( x0: x0 ): (bool)
//
fun
<x0:t0>
g_ltez( x0: x0 ): (bool)
fun
<x0:t0>
g_gtez( x0: x0 ): (bool)
fun
<x0:t0>
g_neqz( x0: x0 ): (bool)
//
(* ****** ****** *)
//
#symload ltz with g_ltz of 0100
#symload gtz with g_gtz of 0100
#symload eqz with g_eqz of 0100
//
#symload ltez with g_ltez of 0100
#symload gtez with g_gtez of 0100
#symload neqz with g_neqz of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_gord000.sats] *)
(***********************************************************************)
`,
  "SATS/gseq000.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon 08 Jul 2024 02:15:16 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
gseq_nil
( (*void*) ): (xs)
//
fun
<xs:t0>
<x0:t0>
gseq_cons
(x0: x0, xs: xs): (xs)
fun
<xs:t0>
<x0:t0>
gseq_snoc
(xs: xs, x0: x0): (xs)
//
fun
<xs:t0>
<x0:t0>
gseq_sing(x0:x0): (xs)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
gseq_nilq(xs:xs): bool
fun
<xs:t0>
<x0:t0>
gseq_consq(xs:xs): bool
//
fun
<xs:t0>
<x0:t0>
gseq_singq(xs:xs): bool
fun
<xs:t0>
<x0:t0>
gseq_pairq(xs:xs): bool
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
gseq_max(xs: xs): (x0)
fun
<xs:t0>
<x0:t0>
gseq_min(xs: xs): (x0)
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
gseq_sum(xs: xs): (x0)
fun
<xs:t0>
<x0:t0>
gseq_prod(xs: xs): (x0)
//
(*
#symload sum with gseq_sum of 0100
#symload prod with gseq_prod of 0100
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-17:
For print0/1 as well
HX-2025-05-08:
For torep0/1 as well
For tostr0/1 as well
*)
(*
HX-2024-07-17:
Wed 17 Jul 2024 09:37:48 PM EDT
*)
//
fun
<xs:vt>
<x0:vt>
gseq_beg((*0*)): strn
fun
<xs:vt>
<x0:vt>
gseq'beg((*0*)): strn
//
fun
<xs:vt>
<x0:vt>
gseq_end((*0*)): strn
fun
<xs:vt>
<x0:vt>
gseq'end((*0*)): strn
//
fun
<xs:vt>
<x0:vt>
gseq_sep((*0*)): strn
fun
<xs:vt>
<x0:vt>
gseq'sep((*0*)): strn
//
fun
<xs:vt>
<x0:vt>
gseq_omit((*0*)): strn
fun
<xs:vt>
<x0:vt>
gseq'omit((*0*)): strn
//
fun
<xs:vt>
<x0:vt>
gseq_prlen((*0*)): sint
fun
<xs:vt>
<x0:vt>
gseq'prlen((*0*)): sint
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-08:
Thu Jan  8 EST
12:22:52 PM 2026
fun
<xs:vt>
<x0:vt>
gseq_make((*00*)): (xs)
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
gseq_torep(xs: xs): strn
//
fun
<xs:t0>
<x0:t0>
gseq_tostr(xs: xs): strn
//
fun
<xs:t0>
<x0:t0>
gseq_print(xs: xs): void
//
(*
#symload print with gseq_print of 0100
*)
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
gseq_head(xs: xs): (x0)
fun
<xs:t0>
<x0:t0>
gseq_tail(xs: xs): (xs)
//
fun
<xs:t0>
<x0:t0>
gseq_head$opt
  (xs: xs): optn_vt(x0)
fun
<xs:t0>
<x0:t0>
gseq_tail$opt
  (xs: xs): optn_vt(xs)
//
(*
#symload head with gseq_head of 0100
#symload tail with gseq_tail of 0100
#symload head$opt with gseq_head$opt of 0100
#symload tail$opt with gseq_tail$opt of 0100
*)
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
gseq_length(xs: xs): nint // >= 0
//
(*
#symload length with gseq_length of 0100
*)
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-15:
Mon 15 Jul 2024 03:44:51 PM EDT
*)
//
fun
<xs:t0>
<x0:t0>
gseq_get$at
(xs: xs, i0: ni): (x0)
fun
<xs:t0>
<x0:t0>
gseq_get$at$opt
(xs: xs, i0: ni): optn_vt(x0)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-7-31:
Wed 31 Jul 2024 07:58:53 PM EDT
*)
//
fun
<xs:t0>
g_append(y1: xs, y2: xs): (xs)
(*
#symload append with g_append of 0100
*)
//
fun
<xs:t0>
g_prepend(y1: xs, y2: xs): (xs)
(*
#symload prepend with g_prepend of 0100
*)
//
(* ****** ****** *)
//
(*
HX-2024-07-17:
Wed 17 Jul 2024 12:48:59 PM EDT
*)
//
fun
<xs:t0>
<x0:t0>
<ys:vt>
gseq_append(xs: xs, ys: ~ys): xs
//
(*
#symload append with gseq_append of 0100
*)
//
(* ****** ****** *)
//
(*
HX-2024-07-17:
Wed 17 Jul 2024 12:48:59 PM EDT
*)
//
fun
<xs:t0>
<x0:t0>
<ys:vt>
gseq_prepend(xs: xs, ys: ~ys): xs
//
(*
#symload prepend with gseq_prepend of 0100
*)
//
(* ****** ****** *)
//
(*
HX-2024-07-17:
Wed 17 Jul 2024 04:11:09 PM EDT
*)
//
fun
<xs:t0>
<x0:t0>
gseq_reverse(xs: xs): (xs)
//
fun
<xs:t0>
<x0:t0>
<ys:vt>
gseq_rappend(xs: xs, ys: ~ys): xs
//
(*
#symload rappend with gseq_rappend of 0100
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-14:
Sun Dec 14 05:12:02 PM EST 2025
*)
fun
<xz:t0>
<xs:t0>
<x0:t0>
gseq_concat_lstrm(xz: xz): strm_vt(x0)
//
(*
#symload concat with gseq_concat_lstrm of 0100
*)
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_gseq000.sats] *)
(***********************************************************************)
`,
  "SATS/gseq001.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sat 13 Jul 2024 09:24:55 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#typedef ni = nint
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX: for [gs_forall]
HX: for [gs_exists]
HX: for [gs_iforall]
HX: for [gs_iexists]
*)
fun
<xs:t0>
g_forall(xs: xs): bool
fun
<xs:t0>
g_exists(xs: xs): bool
fun
<xs:t0>
g_rforall(xs: xs): bool
fun
<xs:t0>
g_rexists(xs: xs): bool
fun
<xs:t0>
g_iforall(xs: xs): bool
fun
<xs:t0>
g_iexists(xs: xs): bool
//
(* ****** ****** *)
//
#typedef
g_forall(xs:t0) = (xs) -> bool
#typedef
g_exists(xs:t0) = (xs) -> bool
//
#typedef
g_rforall(xs:t0) = (xs) -> bool
#typedef
g_rexists(xs:t0) = (xs) -> bool
//
#typedef
g_iforall(xs:t0) = (xs) -> bool
#typedef
g_iexists(xs:t0) = (xs) -> bool
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX: for [gs_foritm]
*)
fun
<xs:t0>
g_foritm(xs: xs): void
fun
<xs:t0>
g_rforitm(xs: xs): void
fun
<xs:t0>
g_iforitm(xs: xs): void
//
(* ****** ****** *)
//
#typedef
g_foritm(xs:t0) = (xs) -> void
#typedef
g_rforitm(xs:t0) = (xs) -> void
#typedef
g_iforitm(xs:t0) = (xs) -> void
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
gseq_listize
  (xs: xs): list_vt(x0)
fun
<xs:t0>
<x0:t0>
gseq_strmize
  (xs: xs): strm_vt(x0)
fun
<xs:t0>
<x0:t0>
gseq_strqize
  (xs: xs): strq_vt(x0)
//
(* ****** ****** *)
//
#typedef
gseq_listize
(xs:t0, x0:t0) = (xs) -> list_vt(x0)
#typedef
gseq_strmize
(xs:t0, x0:t0) = (xs) -> strm_vt(x0)
#typedef
gseq_strqize
(xs:t0, x0:t0) = (xs) -> strq_vt(x0)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
gseq_rlistize
  (xs: xs): list_vt(x0)
fun
<xs:t0>
<x0:t0>
gseq_rstrmize
  (xs: xs): strm_vt(x0)
fun
<xs:t0>
<x0:t0>
gseq_rstrqize
  (xs: xs): strq_vt(x0)
//
(* ****** ****** *)
//
#typedef
gseq_rlistize
(xs:t0, x0:t0) = (xs) -> list_vt(x0)
#typedef
gseq_rstrmize
(xs:t0, x0:t0) = (xs) -> strm_vt(x0)
#typedef
gseq_rstrqize
(xs:t0, x0:t0) = (xs) -> strq_vt(x0)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
gseq_ilistize
  (xs: xs): ilist_vt(x0)
fun
<xs:t0>
<x0:t0>
gseq_istrmize
  (xs: xs): istrm_vt(x0)
fun
<xs:t0>
<x0:t0>
gseq_istrqize
  (xs: xs): istrq_vt(x0)
//
(* ****** ****** *)
//
#typedef
gseq_ilistize
(xs:t0, x0:t0) = (xs) -> list_vt(x0)
#typedef
gseq_istrmize
(xs:t0, x0:t0) = (xs) -> strm_vt(x0)
#typedef
gseq_istrqize
(xs:t0, x0:t0) = (xs) -> strq_vt(x0)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
gseq_forall(xs: xs): bool
fun
<xs:t0>
<x0:t0>
gseq_exists(xs: xs): bool
fun
<xs:t0>
<x0:t0>
gseq_rforall(xs: xs): bool
fun
<xs:t0>
<x0:t0>
gseq_rexists(xs: xs): bool
fun
<xs:t0>
<x0:t0>
gseq_iforall(xs: xs): bool
fun
<xs:t0>
<x0:t0>
gseq_iexists(xs: xs): bool
fun
<xs:t0>
<x0:t0>
gseq_irforall(xs: xs): bool
fun
<xs:t0>
<x0:t0>
gseq_irexists(xs: xs): bool
//
(* ****** ****** *)
//
#typedef
gseq_forall
(xs:t0, x0:t0) = (xs) -> bool
#typedef
gseq_exists
(xs:t0, x0:t0) = (xs) -> bool
//
#typedef
gseq_rforall
(xs:t0, x0:t0) = (xs) -> bool
#typedef
gseq_rexists
(xs:t0, x0:t0) = (xs) -> bool
//
#typedef
gseq_iforall
(xs:t0, x0:t0) = (xs) -> bool
#typedef
gseq_iexists
(xs:t0, x0:t0) = (xs) -> bool
//
#typedef
gseq_irforall
(xs:t0, x0:t0) = (xs) -> bool
#typedef
gseq_irexists
(xs:t0, x0:t0) = (xs) -> bool
//
(* ****** ****** *)
//
(*
#symload forall with gseq_forall of 0100
#symload exists with gseq_exists of 0100
#symload rforall with gseq_rforall of 0100
#symload rexists with gseq_rexists of 0100
#symload iforall with gseq_iforall of 0100
#symload iexists with gseq_iexists of 0100
#symload irforall with gseq_irforall of 0100
#symload irexists with gseq_irexists of 0100
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
gseq_forall$f1un
(xs: xs, test: (x0)->bool): bool
//
(*
#symload forall with gseq_forall$f1un of 0100
#symload forall$fun with gseq_forall$f1un of 0100
*)
#symload gseq_forall with gseq_forall$f1un of 0100
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
gseq_exists$f1un
(xs: xs, test: (x0)->bool): bool
//
(*
#symload exists with gseq_exists$f1un of 0100
#symload exists$fun with gseq_exists$f1un of 0100
*)
#symload gseq_exists with gseq_exists$f1un of 0100
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
gseq_rforall$f1un
(xs: xs, test: (x0)->bool): bool
//
(*
#symload rforall with gseq_rforall$f1un of 0100
#symload rforall$fun with gseq_rforall$f1un of 0100
*)
#symload gseq_rforall with gseq_rforall$f1un of 0100
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
gseq_rexists$f1un
(xs: xs, test: (x0)->bool): bool
//
(*
#symload rexists with gseq_rexists$f1un of 0100
#symload rexists$fun with gseq_rexists$f1un of 0100
*)
#symload gseq_rexists with gseq_rexists$f1un of 0100
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
gseq_iforall$f2un
(xs: xs, test: (ni, x0)->bool): bool
//
(*
#symload iforall with gseq_iforall$f2un of 0100
#symload iforall$fun with gseq_iforall$f2un of 0100
*)
#symload gseq_iforall with gseq_iforall$f2un of 0100
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
gseq_iexists$f2un
(xs: xs, test: (ni, x0)->bool): bool
//
(*
#symload iexists with gseq_iexists$f2un of 0100
#symload iexists$fun with gseq_iexists$f2un of 0100
*)
#symload gseq_iexists with gseq_iexists$f2un of 0100
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
gseq_irforall$f2un
(xs: xs, test: (ni, x0)->bool): bool
//
(*
#symload irforall with gseq_irforall$f2un of 0100
#symload irforall$fun with gseq_irforall$f2un of 0100
*)
#symload gseq_irforall with gseq_irforall$f2un of 0100
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
gseq_irexists$f2un
(xs: xs, test: (ni, x0)->bool): bool
//
(*
#symload irexists with gseq_irexists$f2un of 0100
#symload irexists$fun with gseq_irexists$f2un of 0100
*)
#symload gseq_irexists with gseq_irexists$f2un of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
gseq_foritm(xs: xs): void
fun
<xs:t0>
<x0:t0>
gseq_rforitm(xs: xs): void
fun
<xs:t0>
<x0:t0>
gseq_iforitm(xs: xs): void
fun
<xs:t0>
<x0:t0>
gseq_irforitm(xs: xs): void
//
(*
#symload foritm with gseq_foritm of 0100
#symload rforitm with gseq_rforitm of 0100
#symload iforitm with gseq_iforitm of 0100
#symload irforitm with gseq_irforitm of 0100
*)
//
fun
<xs:t0>
<x0:t0>
gseq_foritm$f1un
(xs: xs, work: (x0)->void): void
//
(*
#symload foritm with gseq_foritm$f1un of 0100
#symload foritm$fun with gseq_foritm$f1un of 0100
*)
#symload gseq_foritm with gseq_foritm$f1un of 0100
//
fun
<xs:t0>
<x0:t0>
gseq_rforitm$f1un
(xs: xs, work: (x0)->void): void
//
(*
#symload rforitm with gseq_rforitm$f1un of 0100
#symload rforitm$fun with gseq_rforitm$f1un of 0100
*)
#symload gseq_rforitm with gseq_rforitm$f1un of 0100
//
fun
<xs:t0>
<x0:t0>
gseq_iforitm$f2un
(xs: xs, work: (ni, x0)->void): void
//
(*
#symload iforitm with gseq_iforitm$f2un of 0100
#symload iforitm$fun with gseq_iforitm$f2un of 0100
*)
#symload gseq_iforitm with gseq_iforitm$f2un of 0100
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
gseq_irforitm$f2un
(xs: xs, work: (ni, x0)->void): void
//
(*
#symload irforitm with gseq_irforitm$f2un of 0100
#symload irforitm$fun with gseq_irforitm$f2un of 0100
*)
#symload gseq_irforitm with gseq_irforitm$f2un of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<r0:vt>
gseq_folditm(xs, r0): ( r0 )
fun
<xs:t0>
<x0:t0>
<r0:vt>
gseq_rfolditm(xs, r0): ( r0 )
fun
<xs:t0>
<x0:t0>
<r0:vt>
gseq_ifolditm(xs, r0): ( r0 )
fun
<xs:t0>
<x0:t0>
<r0:vt>
gseq_irfolditm(xs, r0): ( r0 )
//
(*
#symload folditm with gseq_folditm of 0100
#symload rfolditm with gseq_rfolditm of 0100
#symload ifolditm with gseq_ifolditm of 0100
#symload irfolditm with gseq_irfolditm of 0100
*)
//
fun
<xs:t0>
<x0:t0>
<r0:vt>
gseq_folditm$f2un
( xs: xs
, r0: r0, fopr: (r0, x0)->(r0)): (r0)
//
(*
#symload folditm with gseq_folditm$f2un of 0100
#symload folditm$fun with gseq_folditm$f2un of 0100
*)
#symload gseq_folditm with gseq_folditm$f2un of 0100
//
fun
<xs:t0>
<x0:t0>
<r0:vt>
gseq_rfolditm$f2un
( xs: xs
, r0: r0, fopr: (x0, r0)->(r0)): (r0)
//
(*
#symload rfolditm with gseq_rfolditm$f2un of 0100
#symload rfolditm$fun with gseq_rfolditm$f2un of 0100
*)
#symload gseq_rfolditm with gseq_rfolditm$f2un of 0100
//
fun
<xs:t0>
<x0:t0>
<r0:vt>
gseq_ifolditm$f3un
( xs: xs
, r0: r0, fopr: (r0,ni,x0)->(r0)): (r0)
//
(*
#symload ifolditm with gseq_ifolditm$f3un of 0100
#symload ifolditm$fun with gseq_ifolditm$f3un of 0100
*)
#symload gseq_ifolditm with gseq_ifolditm$f3un of 0100
//
fun
<xs:t0>
<x0:t0>
<r0:vt>
gseq_irfolditm$f3un
( xs: xs
, r0: r0, fopr: (ni,x0,r0)->(r0)): (r0)
//
(*
#symload irfolditm with gseq_irfolditm$f3un of 0100
#symload irfolditm$fun with gseq_irfolditm$f3un of 0100
*)
#symload gseq_irfolditm with gseq_irfolditm$f3un of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<r0:vt>
gseq_foldall(xs, r0): ( r0 )
fun
<xs:t0>
<x0:t0>
<r0:vt>
gseq_rfoldall(xs, r0): ( r0 )
fun
<xs:t0>
<x0:t0>
<r0:vt>
gseq_ifoldall(xs, r0): ( r0 )
fun
<xs:t0>
<x0:t0>
<r0:vt>
gseq_irfoldall(xs, r0): ( r0 )
//
(*
#symload foldall with gseq_foldall of 0100
#symload rfoldall with gseq_rfoldall of 0100
#symload ifoldall with gseq_ifoldall of 0100
#symload irfoldall with gseq_irfoldall of 0100
*)
//
fun
<xs:t0>
<x0:t0>
<r0:vt>
gseq_foldall$f2un
( xs: xs
, r0: r0
, fopr: (r0, x0)->(bool, r0)): ( r0 )
//
(*
#symload foldall with gseq_foldall$f2un of 0100
#symload foldall$fun with gseq_foldall$f2un of 0100
*)
#symload gseq_foldall with gseq_foldall$f2un of 0100
//
fun
<xs:t0>
<x0:t0>
<r0:vt>
gseq_rfoldall$f2un
( xs: xs
, r0: r0
, fopr: (x0, r0)->(bool, r0)): ( r0 )
//
(*
#symload rfoldall with gseq_rfoldall$f2un of 0100
#symload rfoldall$fun with gseq_rfoldall$f2un of 0100
*)
#symload gseq_rfoldall with gseq_rfoldall$f2un of 0100
//
fun
<xs:t0>
<x0:t0>
<r0:vt>
gseq_ifoldall$f3un
( xs: xs
, r0: r0
, fopr: (r0, ni, x0)->(bool, r0)): ( r0 )
//
(*
#symload ifoldall with gseq_ifoldall$f3un of 0100
#symload ifoldall$fun with gseq_ifoldall$f3un of 0100
*)
#symload gseq_ifoldall with gseq_ifoldall$f3un of 0100
//
fun
<xs:t0>
<x0:t0>
<r0:vt>
gseq_irfoldall$f3un
( xs: xs
, r0: r0
, fopr: (ni, x0, r0)->(bool, r0)): ( r0 )
//
(*
#symload irfoldall with gseq_irfoldall$f3un of 0100
#symload irfoldall$fun with gseq_irfoldall$f3un of 0100
*)
#symload gseq_irfoldall with gseq_irfoldall$f3un of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<ys:vt>
<y0:vt>
gseq_map_ares(xs: xs): (ys)
fun
<xs:t0>
<x0:t0>
gseq_map_self(xs: xs): (xs)
//
(*
#symload map with gseq_map_ares of 0100
#symload map with gseq_map_self of 0110
*)
//
#typedef
gseq_map_ares
(xs:t0, x0:t0
,ys:vt, y0:vt) = (xs) -> (ys)
#typedef
gseq_map_self
(xs:t0, x0:t0) = (xs) -> (xs)
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<ys:vt>
<y0:vt>
gseq_map$f1un_ares
(xs: xs, fopr: (x0)->(y0)): (ys)
//
(*
#symload map$fun with gseq_map$f1un_ares of 0100
#symload gseq_map with gseq_map$f1un_ares of 0100
*)
//
fun
<xs:t0>
<x0:t0>
gseq_map$f1un_self
(xs: xs, fopr: (x0)->(x0)): (xs)
//
(*
#symload map$fun with gseq_map$f1un_self of 0110
#symload gseq_map with gseq_map$f1un_self of 0110
*)
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<y0:t0>
gseq_map_list(xs: xs): list(y0)
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_map_llist(xs: xs): list_vt(y0)
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_map_lstrm(xs: xs): strm_vt(y0)
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_map_lstrq(xs: xs): strq_vt(y0)
//
(*
#symload map_list with gseq_map_list of 0100
#symload map_strm with gseq_map_strm of 0100
#symload map_llist with gseq_map_llist of 0100
#symload map_lstrm with gseq_map_lstrm of 0100
#symload map_lstrq with gseq_map_lstrq of 0100
*)
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<y0:t0>
gseq_map$f1un_list
(xs: xs, fopr: (x0)->(y0)): list(y0)
(*
#symload
map_list with gseq_map$f1un_list of 0100
*)
#symload
gseq_map_list with gseq_map$f1un_list of 0100
//
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_map$f1un_llist
(xs: xs, fopr: (x0)->(y0)): list_vt(y0)
(*
#symload
map_llist with gseq_map$f1un_llist of 0100
*)
#symload
gseq_map_llist with gseq_map$f1un_llist of 0100
//
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_map$f1un_lstrm
(xs: xs, fopr: (x0)->(y0)): strm_vt(y0)
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_map$f1un_lstrq
(xs: xs, fopr: (x0)->(y0)): strq_vt(y0)
//
(*
#symload
map_lstrm with gseq_map$f1un_lstrm of 0100
#symload
map_lstrq with gseq_map$f1un_lstrq of 0100
*)
#symload
gseq_map_lstrm with gseq_map$f1un_lstrm of 0100
#symload
gseq_map_lstrq with gseq_map$f1un_lstrq of 0100
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<y0:t0>
gseq_map_rlist(xs: xs): list(y0)
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_map_rllist(xs: xs): list_vt(y0)
//
fun
<xs:t0>
<x0:t0>
<y0:t0>
gseq_map$f1un_rlist
(xs: xs, fopr: (x0)->(y0)): list(y0)
//
(*
#symload
map_rlist with gseq_map$f1un_rlist of 0100
*)
#symload
gseq_map_rlist with gseq_map$f1un_rlist of 0100
//
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_map$f1un_rllist
(xs: xs, fopr: (x0)->(y0)): list_vt(y0)
//
(*
#symload
map_rllist with gseq_map$f1un_rllist of 0100
*)
#symload
gseq_map_rllist with gseq_map$f1un_rllist of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
gseq_rmap_self(xs: xs): (xs)
fun
<xs:t0>
<x0:t0>
<ys:vt>
<y0:vt>
gseq_rmap_ares(xs: xs): (ys)
//
(* ****** ****** *)
//
#typedef
gseq_rmap_self
(xs:t0, x0:t0) = (xs) -> (xs)
#typedef
gseq_rmap_ares
(xs:t0, x0:t0
,ys:vt, y0:vt) = (xs) -> (ys)
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<y0:t0>
gseq_rmap_list(xs: xs): list(y0)
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_rmap_llist(xs: xs): list_vt(y0)
//
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_rmap_lstrm(xs: xs): strm_vt(y0)
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_rmap_lstrq(xs: xs): strq_vt(y0)
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<y0:t0>
gseq_rmap$f1un_list
(xs: xs, fopr: (x0)->(y0)): list(y0)
(*
#symload
rmap_list with gseq_rmap$f1un_list of 0100
*)
#symload
gseq_rmap_list with gseq_rmap$f1un_list of 0100
//
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_rmap$f1un_llist
(xs: xs, fopr: (x0)->(y0)): list_vt(y0)
//
(*
#symload
rmap_llist with gseq_rmap$f1un_llist of 0100
*)
#symload
gseq_rmap_llist with gseq_rmap$f1un_llist of 0100
//
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_rmap$f1un_lstrm
(xs: xs, fopr: (x0)->(y0)): strm_vt(y0)
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_rmap$f1un_lstrq
(xs: xs, fopr: (x0)->(y0)): strq_vt(y0)
//
(*
#symload
rmap_lstrm with gseq_rmap$f1un_lstrm of 0100
#symload
rmap_lstrq with gseq_rmap$f1un_lstrq of 0100
*)
#symload
gseq_rmap_lstrm with gseq_rmap$f1un_lstrm of 0100
#symload
gseq_rmap_lstrq with gseq_rmap$f1un_lstrq of 0100
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<y0:t0>
gseq_rmap_rlist(xs: xs): list(y0)
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_rmap_rllist(xs: xs): list_vt(y0)
//
fun
<xs:t0>
<x0:t0>
<y0:t0>
gseq_rmap$f1un_rlist
(xs: xs, fopr: (x0)->(y0)): list(y0)
//
(*
#symload
rmap_rlist with gseq_rmap$f1un_rlist of 0100
*)
#symload
gseq_rmap_rlist with gseq_rmap$f1un_rlist of 0100
//
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_rmap$f1un_rllist
(xs: xs, fopr: (x0)->(y0)): list_vt(y0)
//
(*
#symload
rmap_rllist with gseq_rmap$f1un_rllist of 0100
*)
#symload
gseq_rmap_rllist with gseq_rmap$f1un_rllist of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<ys:vt>
<y0:vt>
gseq_imap_ares(xs: xs): (ys)
fun
<xs:t0>
<x0:t0>
gseq_imap_self(xs: xs): (xs)
//
(* ****** ****** *)
//
#typedef
gseq_imap_ares
(xs:t0, x0:t0
,ys:vt, y0:vt) = (xs) -> (ys)
#typedef
gseq_imap_self
(xs:t0, x0:t0) = (xs) -> (xs)
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<y0:t0>
gseq_imap_list(xs: xs): list(y0)
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_imap_llist(xs: xs): list_vt(y0)
//
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_imap_lstrm(xs: xs): strm_vt(y0)
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_imap_lstrq(xs: xs): strq_vt(y0)
//
fun
<xs:t0>
<x0:t0>
<y0:t0>
gseq_imap$f2un_list
(xs: xs, fopr: (ni, x0)->(y0)): list(y0)
//
(*
#symload
imap_list with gseq_imap$f2un_list of 0100
*)
#symload
gseq_imap_list with gseq_imap$f2un_list of 0100
//
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_imap$f2un_llist
(xs: xs, fopr: (ni, x0)->(y0)): list_vt(y0)
//
(*
#symload
imap_llist with gseq_imap$f2un_llist of 0100
*)
#symload
gseq_imap_llist with gseq_imap$f2un_llist of 0100
//
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_imap$f2un_lstrm
(xs: xs, fopr: (ni, x0)->(y0)): strm_vt(y0)
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_imap$f2un_lstrq
(xs: xs, fopr: (ni, x0)->(y0)): strq_vt(y0)
//
(*
#symload
imap_lstrm with gseq_imap$f2un_lstrm of 0100
#symload
imap_lstrq with gseq_imap$f2un_lstrq of 0100
*)
#symload
gseq_imap_lstrm with gseq_imap$f2un_lstrm of 0100
#symload
gseq_imap_lstrq with gseq_imap$f2un_lstrq of 0100
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<y0:t0>
gseq_imap_rlist(xs: xs): list(y0)
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_imap_rllist(xs: xs): list_vt(y0)
//
fun
<xs:t0>
<x0:t0>
<y0:t0>
gseq_imap$f2un_rlist
(xs: xs, fopr: (ni, x0)->(y0)): list(y0)
//
(*
#symload
imap_rlist with gseq_imap$f2un_rlist of 0100
*)
#symload
gseq_imap_rlist with gseq_imap$f2un_rlist of 0100
//
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_imap$f2un_rllist
(xs: xs, fopr: (ni, x0)->(y0)): list_vt(y0)
//
(*
#symload
imap_rllist with gseq_imap$f2un_rllist of 0100
*)
#symload
gseq_imap_rllist with gseq_imap$f2un_rllist of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-28:
Sun 28 Jul 2024 05:41:08 PM EDT
*)
//
fun
<xs:t0>
<x0:t0>
<ys:vt>
<y0:vt>
gseq_irmap_ares(xs: xs): (ys)
fun
<xs:t0>
<x0:t0>
gseq_irmap_self(xs: xs): (xs)
//
(* ****** ****** *)
//
#typedef
gseq_irmap_ares
(xs:t0, x0:t0
,ys:vt, y0:vt) = (xs) -> (ys)
#typedef
gseq_irmap_self
(xs:t0, x0:t0) = (xs) -> (xs)
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<y0:t0>
gseq_irmap_list(xs: xs): list(y0)
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_irmap_llist(xs: xs): list_vt(y0)
//
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_irmap_lstrm(xs: xs): strm_vt(y0)
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_irmap_lstrq(xs: xs): strq_vt(y0)
//
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_irmap$f2un_llist
(xs: xs, fopr: (ni, x0)->(y0)): list_vt(y0)
//
(*
#symload
irmap_llist with gseq_irmap$f2un_llist of 0100
*)
#symload
gseq_irmap_llist with gseq_irmap$f2un_llist of 0100
//
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_irmap$f2un_lstrm
(xs: xs, fopr: (ni, x0)->(y0)): strm_vt(y0)
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_irmap$f2un_lstrq
(xs: xs, fopr: (ni, x0)->(y0)): strq_vt(y0)
//
(*
#symload
irmap_lstrm with gseq_irmap$f2un_lstrm of 0100
#symload
irmap_lstrq with gseq_irmap$f2un_lstrq of 0100
*)
#symload
gseq_irmap_lstrm with gseq_irmap$f2un_lstrm of 0100
#symload
gseq_irmap_lstrq with gseq_irmap$f2un_lstrq of 0100
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<y0:t0>
gseq_irmap_rlist(xs: xs): list(y0)
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_irmap_rllist(xs: xs): list_vt(y0)
//
fun
<xs:t0>
<x0:t0>
<y0:t0>
gseq_irmap$f2un_rlist
(xs: xs, fopr: (ni, x0)->(y0)): list(y0)
//
(*
#symload
irmap_rlist with gseq_irmap$f2un_rlist of 0100
*)
#symload
gseq_irmap_rlist with gseq_irmap$f2un_rlist of 0100
//
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_irmap$f2un_rllist
(xs: xs, fopr: (ni, x0)->(y0)): list_vt(y0)
//
(*
#symload
irmap_rllist with gseq_irmap$f2un_rllist of 0100
*)
#symload
gseq_irmap_rllist with gseq_irmap$f2un_rllist of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<ys:vt>
gseq_filter_ares(xs: xs): (ys)
fun
<xs:t0>
<x0:t0>
gseq_filter_self(xs: xs): (xs)
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
gseq_filter_list(xs: xs): list(x0)
fun
<xs:t0>
<x0:t0>
gseq_filter_llist(xs: xs): list_vt(x0)
//
fun
<xs:t0>
<x0:t0>
gseq_filter_lstrm(xs: xs): strm_vt(x0)
fun
<xs:t0>
<x0:t0>
gseq_filter_lstrq(xs: xs): strq_vt(x0)
//
fun
<xs:t0>
<x0:t0>
gseq_filter$f1un_list
(xs: xs, test: (x0)->bool): list(x0)
fun
<xs:t0>
<x0:t0>
gseq_filter$f1un_llist
(xs: xs, test: (x0)->bool): list_vt(x0)
//
(*
#symload
filter_list with gseq_filter$f1un_list of 0100
#symload
filter_llist with gseq_filter$f1un_llist of 0100
*)
#symload
gseq_filter_list with gseq_filter$f1un_list of 0100
#symload
gseq_filter_llist with gseq_filter$f1un_llist of 0100
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
gseq_filter$f1un_lstrm
(xs: xs, test: (x0)->bool): strm_vt(x0)
fun
<xs:t0>
<x0:t0>
gseq_filter$f1un_lstrq
(xs: xs, test: (x0)->bool): strq_vt(x0)
//
(*
#symload
filter_lstrm with gseq_filter$f1un_lstrm of 0100
#symload
filter_lstrq with gseq_filter$f1un_lstrq of 0100
*)
#symload
gseq_filter_lstrm with gseq_filter$f1un_lstrm of 0100
#symload
gseq_filter_lstrq with gseq_filter$f1un_lstrq of 0100
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
gseq_filter_rlist(xs: xs): list(x0)
fun
<xs:t0>
<x0:t0>
gseq_filter_rllist(xs: xs): list_vt(x0)
//
fun
<xs:t0>
<x0:t0>
gseq_filter$f1un_rlist
(xs: xs, test: (x0)->bool): list(x0)
(*
#symload
filter_rlist with gseq_filter$f1un_rlist of 0100
*)
#symload
gseq_filter_rlist with gseq_filter$f1un_rlist of 0100
//
fun
<xs:t0>
<x0:t0>
gseq_filter$f1un_rllist
(xs: xs, test: (x0)->bool): list_vt(x0)
(*
#symload
filter_rllist with gseq_filter$f1un_rllist of 0100
*)
#symload
gseq_filter_rllist with gseq_filter$f1un_rllist of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
gseq_rfilter_lstrm(xs: xs): strm_vt(x0)
fun
<xs:t0>
<x0:t0>
gseq_rfilter_lstrq(xs: xs): strq_vt(x0)
//
fun
<xs:t0>
<x0:t0>
gseq_rfilter$f1un_lstrm
(xs: xs, test: (x0)->bool): strm_vt(x0)
fun
<xs:t0>
<x0:t0>
gseq_rfilter$f1un_lstrq
(xs: xs, test: (x0)->bool): strq_vt(x0)
//
#symload
gseq_rfilter_lstrm with gseq_rfilter$f1un_lstrm of 0100
#symload
gseq_rfilter_lstrq with gseq_rfilter$f1un_lstrq of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-17:
Sat 17 Aug 2024 11:35:35 AM EDT
*)
//
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_map$listize
(xs: xs): list_vt(y0) //HX: [map_llist]
//
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_map$strmize
(xs: xs): strm_vt(y0) //HX: [map_lstrm]
fun
<xs:t0>
<x0:t0>
<y0:vt>
gseq_map$strqize
(xs: xs): strq_vt(y0) //HX: [map_lstrq]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-16:
Fri 16 Aug 2024 08:33:31 AM EDT
*)
//
fun
<xs:t0>
<x0:t0>
<y0:vt>
// HX: this one composes [map] with
gseq_map$forall(xs: xs): bool // [forall]
fun
<xs:t0>
<x0:t0>
<y0:vt>
// HX: this one composes
gseq_map$forall$f1un // [map] with
(xs: xs, fopr: (x0)->y0): bool // [forall]
//
#symload
gseq_map$forall with gseq_map$forall$f1un of 0100
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<y0:vt>
// HX: this one composes [imap] with
gseq_imap$iforall(xs: xs): bool // [iforall]
fun
<xs:t0>
<x0:t0>
<y0:vt>
// HX: this one composes
gseq_imap$iforall$f2un // [imap] with
(xs: xs, fopr: (ni,x0)->y0): bool // [iforall]
//
#symload
gseq_imap$iforall with gseq_imap$iforall$f2un of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
//
HX-2024-08-17:
For instance,
a typical use of
gseq_uncons$forall:
//
#impltmp
< x0:t0 >
list_forall =
gseq_uncons$forall<list(x0)><x0>
//
*)
fun
<xs:t0>
<x0:t0> // HX: this one is forall cond.
gseq_uncons$forall(xs: xs): bool // on uncons
//
(* ****** ****** *)
//
(*
//
HX-2024-08-17:
For instance,
a typical use of
gseq_uncons$strmize:
//
#impltmp
< x0:t0 >
list_strmize =
gseq_uncons$strmize<list(x0)><x0>
//
*)
fun
<xs:t0>
<x0:t0> // HX: this one is strmize cond. on
gseq_uncons$strmize(xs: xs): strm_vt(x0)//uncons
fun
<xs:t0>
<x0:t0> // HX: this one is strqize cond. on
gseq_uncons$strqize(xs: xs): strq_vt(x0)//uncons
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
gseq_fmake_fwork(fwork: ((x0)->void)->void): (xs)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-05-31:
Sat May 31 07:52:59 PM EDT 2025
*)
//
fun
<xs:t0>
<x0:t0>
<y0:t0>
<e1:vt>
gseq_map$e1nv_list(xs: xs, e1: !e1): list(y0)
fun
<xs:t0>
<x0:t0>
<y0:vt>
<e1:vt>
gseq_map$e1nv_llist(xs: xs, e1: !e1): list_vt(y0)
fun
<xs:t0>
<x0:t0>
<y0:vt>
<e1:vt>
gseq_map$e1nv_lstrm(xs: xs, e1: !e1): strm_vt(y0)
fun
<xs:t0>
<x0:t0>
<y0:vt>
<e1:vt>
gseq_map$e1nv_lstrq(xs: xs, e1: !e1): strq_vt(y0)
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<y0:t0>
<e1:vt>
gseq_map$e1nv_rlist(xs: xs, e1: !e1): list(y0)
fun
<xs:t0>
<x0:t0>
<y0:vt>
<e1:vt>
gseq_map$e1nv_rllist(xs: xs, e1: !e1): list_vt(y0)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-25:
Thu Dec 25 04:40:27 PM EST 2025
*)
fun
<xs:t0>
<x0:t0>
gseq_search(xs: xs): optn_vt(x0)
fun
<xs:t0>
<x0:t0>
gseq_rsearch(xs: xs): optn_vt(x0)
fun
<xs:t0>
<x0:t0>
gseq_isearch(xs: xs): optn_vt(x0)
fun
<xs:t0>
<x0:t0>
gseq_irsearch(xs: xs): optn_vt(x0)
//
fun
<xs:t0>
<x0:t0>
gseq_search$f1un
(xs: xs, test: (x0)->bool): optn_vt(x0)
fun
<xs:t0>
<x0:t0>
gseq_rsearch$f1un
(xs: xs, test: (x0)->bool): optn_vt(x0)
fun
<xs:t0>
<x0:t0>
gseq_isearch$f2un
(xs: xs, test: (ni, x0)->bool): optn_vt(x0)
fun
<xs:t0>
<x0:t0>
gseq_irsearch$f2un
(xs: xs, test: (ni, x0)->bool): optn_vt(x0)
//
#symload gseq_search with gseq_search$f1un of 0100
#symload gseq_rsearch with gseq_rsearch$f1un of 0100
#symload gseq_isearch with gseq_isearch$f2un of 0100
#symload gseq_irsearch with gseq_irsearch$f2un of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-04:
Sun Jan  4 11:11:49 PM EST 2026
*)
//
fun
<xs:t0>
<x0:t0>
gseq_memberq(xs: xs, x0: x0): bool
#symload memberq with gseq_memberq of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-05:
Mon Jan  5 12:17:18 PM EST 2026
*)
//
fun
<xs:t0>
<x0:t0>
gseq_sortedq(xs: xs): bool
fun
<xs:t0>
<x0:t0>
gseq_sortedq$f2un
(xs: xs, lteq: (x0, x0) -> bool): bool
#symload gseq_sortedq with gseq_sortedq$f2un of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-13:
Tue Jan 13 03:00:54 PM EST 2026
*)
//
fun
<xs:t0>
<x0:t0>
<e1:vt>
gseq_forall$e1nv(xs: xs, e1: !e1): bool
fun
<xs:t0>
<x0:t0>
<e1:vt>
gseq_exists$e1nv(xs: xs, e1: !e1): bool
fun
<xs:t0>
<x0:t0>
<e1:vt>
gseq_rforall$e1nv(xs: xs, e1: !e1): bool
fun
<xs:t0>
<x0:t0>
<e1:vt>
gseq_rexists$e1nv(xs: xs, e1: !e1): bool
fun
<xs:t0>
<x0:t0>
<e1:vt>
gseq_iforall$e1nv(xs: xs, e1: !e1): bool
fun
<xs:t0>
<x0:t0>
<e1:vt>
gseq_irforall$e1nv(xs: xs, e1: !e1): bool
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_gseq001.sats] *)
(***********************************************************************)
`,
  "SATS/gseq002.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sat 13 Jul 2024 09:56:55 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#typedef ni = nint
#typedef si = sint
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-24:
Wed 24 Jul 2024 08:33:48 PM EDT
For additive combination of two
given lists: z is short for zip
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-09-07:
Sun Sep  7 08:06:58 PM EDT 2025
Here is the meaning of various prefixes:
//
rzip2(xs, ys) =
(zip2(rev(xs), rev(ys)))
//
z2map(xs, ys) = map(zip(xs, ys))
z2rmap(xs, ys) = rmap(zip(xs, ys))
//
z2imap(xs, ys) = imap(zip(xs, ys))
z2irmap(xs, ys) = irmap(zip(xs, ys))
//
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
gseq_cmp
(xs: xs, ys: xs): sint(*sign*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_z2listize
(xs: xs, ys: ys): list_vt@(x0, y0)
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_z2rlistize
(xs: xs, ys: ys): list_vt@(x0, y0)
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_z2ilistize
(xs: xs, ys: ys): list_vt@(ni, x0, y0)
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_z2strmize
(xs: xs, ys: ys): strm_vt@(x0, y0)
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_z2istrmize
(xs: xs, ys: ys): strm_vt@(ni, x0, y0)
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_z2strqize
(xs: xs, ys: ys): strq_vt@(x0, y0)
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_z2istrqize
(xs: xs, ys: ys): strq_vt@(ni, x0, y0)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_z2forall(xs: xs, ys: ys): bool
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_z2forcmp(xs: xs, ys: ys): sint
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_z2rforall(xs: xs, ys: ys): bool
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_z2rforcmp(xs: xs, ys: ys): sint
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_z2iforall(xs: xs, ys: ys): bool
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_z2iforcmp(xs: xs, ys: ys): sint
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_z2irforall(xs: xs, ys: ys): bool
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_z2irforcmp(xs: xs, ys: ys): sint
//
(*
#symload z2forall with gseq_z2forall of 0100
#symload z2forcmp with gseq_z2forcmp of 0100
#symload z2rforall with gseq_z2rforall of 0100
#symload z2rforcmp with gseq_z2rforcmp of 0100
#symload z2iforall with gseq_z2iforall of 0100
#symload z2iforcmp with gseq_z2iforcmp of 0100
#symload z2irforall with gseq_z2irforall of 0100
#symload z2irforcmp with gseq_z2irforcmp of 0100
*)
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_z2forall$f2un
(xs: xs, ys: ys, test: (x0, y0)->bool): bool
//
(*
#symload z2forall with gseq_z2forall$f2un of 0100
#symload z2forall$fun with gseq_z2forall$f2un of 0100
*)
#symload gseq_z2forall with gseq_z2forall$f2un of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_z2foritm(xs: xs, ys: ys): void
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_z2rforitm(xs: xs, ys: ys): void
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_z2iforitm(xs: xs, ys: ys): void
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_z2irforitm(xs: xs, ys: ys): void
//
(*
#symload z2foritm with gseq_z2foritm of 0100
#symload z2rforitm with gseq_z2rforitm of 0100
#symload z2iforitm with gseq_z2iforitm of 0100
#symload z2irforitm with gseq_z2irforitm of 0100
*)
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_z2foritm$f2un
(xs: xs, ys: ys, work: (x0, y0)->void): void
//
(*
#symload z2foritm with gseq_z2foritm$f2un of 0100
#symload z2foritm$fun with gseq_z2foritm$f2un of 0100
*)
#symload gseq_z2foritm with gseq_z2foritm$f2un of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
<zs:vt>
<z0:vt>
gseq_z2map_ares(xs: xs, ys: ys): (zs)
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_z2map_self(xs: xs, ys: ys): (xs)
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
<z0:vt>
gseq_z2map_llist(xs: xs, ys: ys): list_vt(z0)
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
<z0:vt>
gseq_z2map_lstrm(xs: xs, ys: ys): strm_vt(z0)
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
<z0:vt>
gseq_z2map_lstrq(xs: xs, ys: ys): strq_vt(z0)
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
<z0:vt>
gseq_z2rmap_llist(xs: xs, ys: ys): list_vt(z0)
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
<z0:vt>
gseq_z2rmap_lstrm(xs: xs, ys: ys): strm_vt(z0)
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
<z0:vt>
gseq_z2rmap_lstrq(xs: xs, ys: ys): strq_vt(z0)
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
<z0:vt>
gseq_z2imap_llist(xs: xs, ys: ys): list_vt(z0)
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
<z0:vt>
gseq_z2imap_lstrm(xs: xs, ys: ys): strm_vt(z0)
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
<z0:vt>
gseq_z2imap_lstrq(xs: xs, ys: ys): strq_vt(z0)
//
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
<z0:vt>
gseq_z2irmap_llist(xs: xs, ys: ys): list_vt(z0)
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
<z0:vt>
gseq_z2irmap_lstrm(xs: xs, ys: ys): strm_vt(z0)
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
<z0:vt>
gseq_z2irmap_lstrq(xs: xs, ys: ys): strq_vt(z0)
//
(* ****** ****** *)
(* ****** ****** *)
(*
HX-2024-08-04:
Sun 04 Aug 2024 07:17:13 AM EDT
For multiplicative combination of
two given lists: x is short for cross
*)
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_x2listize
(xs: xs, ys: ys): list_vt@(x0, y0)
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_x2rlistize
(xs: xs, ys: ys): list_vt@(x0, y0)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_x2strmize
(xs: xs, ys: ys): strm_vt@(x0, y0)
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_x2strqize
(xs: xs, ys: ys): strq_vt@(x0, y0)
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_ix2strmize
( xs: xs
, ys: ys): strm_vt@(ni, x0, ni, y0)
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_ix2strqize
( xs: xs
, ys: ys): strq_vt@(ni, x0, ni, y0)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_x2forall(xs: xs, ys: ys): bool
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_ix2forall(xs: xs, ys: ys): bool
//
(*
#symload x2forall with gseq_x2forall of 0100
#symload ix2forall with gseq_ix2forall of 0100
*)
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_x2forall$f2un
(xs: xs, ys: ys, test: (x0, y0)->bool): bool
//
(*
#symload x2forall with gseq_x2forall$f2un of 0100
#symload x2forall$fun with gseq_x2forall$f2un of 0100
*)
#symload gseq_x2forall with gseq_x2forall$f2un of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_x2foritm(xs: xs, ys: ys): void
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_ix2foritm(xs: xs, ys: ys): void
//
(*
#symload x2foritm with gseq_x2foritm of 0100
#symload ix2foritm with gseq_ix2foritm of 0100
*)
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_x2foritm$f2un
(xs: xs, ys: ys, work: (x0, y0)->void): void
//
(*
#symload x2foritm with gseq_x2foritm$f2un of 0100
#symload x2foritm$fun with gseq_x2foritm$f2un of 0100
*)
#symload gseq_x2foritm with gseq_x2foritm$f2un of 0100
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
<zs:vt>
<z0:vt>
gseq_x2map_ares(xs: xs, ys: ys): (zs)
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
gseq_x2map_self(xs: xs, ys: ys): (xs)
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
<z0:vt>
gseq_x2map_llist(xs: xs, ys: ys): list_vt(z0)
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
<z0:vt>
gseq_x2map_lstrm(xs: xs, ys: ys): strm_vt(z0)
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
<z0:vt>
gseq_x2map_lstrq(xs: xs, ys: ys): strq_vt(z0)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
<z0:vt>
gseq_ix2map_llist(xs: xs, ys: ys): list_vt(z0)
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
<z0:vt>
gseq_ix2map_lstrm(xs: xs, ys: ys): strm_vt(z0)
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
<z0:vt>
gseq_ix2map_lstrq(xs: xs, ys: ys): strq_vt(z0)
//
(* ****** ****** *)
(* ****** ****** *)
//
#typedef
gz2seq
( xs: t0, x0: t0
, ys: t0, y0: t0) =
(
  z2tup(GSEQ(xs, x0), GSEQ(ys, y0)))
//
#typedef
gx2seq
( xs: t0, x0: t0
, ys: t0, y0: t0) =
(
  x2tup(GSEQ(xs, x0), GSEQ(ys, y0)))
//
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
GSEQ_z2make
( xs: GSEQ(xs, x0)
, ys: GSEQ(ys, y0)): GSEQ(gz2seq(xs,x0,ys,y0),(x0,y0))
//
fun
<xs:t0>
<x0:t0>
<ys:t0>
<y0:t0>
GSEQ_x2make
( xs: GSEQ(xs, x0)
, ys: GSEQ(ys, y0)): GSEQ(gx2seq(xs,x0,ys,y0),(x0,y0))
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_gseq002.sats] *)
(***********************************************************************)
`,
  "SATS/gsyn000.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sat 27 Jul 2024 01:25:30 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-29:
Mon 29 Jul 2024 03:17:20 PM EDT
*)
//
fun
<x0:t0>
gs_add_a0
( (*void*) ): x0
fun
<x0:t0>
gs_add_a1(x0): x0
fun
<x0:t0>
gs_add_a2(x0, x0): x0
fun
<x0:t0>
gs_add_a3(x0, x0, x0): x0
fun
<x0:t0>
gs_add_a4(x0, x0, x0, x0): x0
fun
<x0:t0>
gs_add_a5(x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_add_a6(x0, x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_add_a7(x0, x0, x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_add_a8(x0, x0, x0, x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_add_a9(x0, x0, x0, x0, x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_add_a10(x0, x0, x0, x0, x0, x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_add_a11(x0, x0, x0, x0, x0, x0, x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_add_a12(x0, x0, x0, x0, x0, x0, x0, x0, x0, x0, x0, x0): x0
//
(* ****** ****** *)
//
#symload adds with gs_add_a0
#symload adds with gs_add_a1
#symload adds with gs_add_a2
#symload adds with gs_add_a3
#symload adds with gs_add_a4
#symload adds with gs_add_a5
#symload adds with gs_add_a6
#symload adds with gs_add_a7
#symload adds with gs_add_a8
#symload adds with gs_add_a9
#symload adds with gs_add_a10
#symload adds with gs_add_a11
#symload adds with gs_add_a12
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-29:
Mon 29 Jul 2024 03:17:20 PM EDT
*)
//
fun
<x0:t0>
gs_mul_a0
( (*void*) ): x0
fun
<x0:t0>
gs_mul_a1(x0): x0
fun
<x0:t0>
gs_mul_a2(x0, x0): x0
fun
<x0:t0>
gs_mul_a3(x0, x0, x0): x0
fun
<x0:t0>
gs_mul_a4(x0, x0, x0, x0): x0
fun
<x0:t0>
gs_mul_a5(x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_mul_a6(x0, x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_mul_a7(x0, x0, x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_mul_a8(x0, x0, x0, x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_mul_a9(x0, x0, x0, x0, x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_mul_a10(x0, x0, x0, x0, x0, x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_mul_a11(x0, x0, x0, x0, x0, x0, x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_mul_a12(x0, x0, x0, x0, x0, x0, x0, x0, x0, x0, x0, x0): x0
//
(* ****** ****** *)
//
#symload muls with gs_mul_a0
#symload muls with gs_mul_a1
#symload muls with gs_mul_a2
#symload muls with gs_mul_a3
#symload muls with gs_mul_a4
#symload muls with gs_mul_a5
#symload muls with gs_mul_a6
#symload muls with gs_mul_a7
#symload muls with gs_mul_a8
#symload muls with gs_mul_a9
#symload muls with gs_mul_a10
#symload muls with gs_mul_a11
#symload muls with gs_mul_a12
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-29:
Mon 29 Jul 2024 03:17:20 PM EDT
*)
//
(*
fun
<x0:t0>
gs_max_a0(): x0
fun
<x0:t0>
gs_max_a1(x0): x0
*)
fun
<x0:t0>
gs_max_a2(x0, x0): x0
fun
<x0:t0>
gs_max_a3(x0, x0, x0): x0
fun
<x0:t0>
gs_max_a4(x0, x0, x0, x0): x0
fun
<x0:t0>
gs_max_a5(x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_max_a6(x0, x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_max_a7(x0, x0, x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_max_a8(x0, x0, x0, x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_max_a9(x0, x0, x0, x0, x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_max_a10(x0, x0, x0, x0, x0, x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_max_a11(x0, x0, x0, x0, x0, x0, x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_max_a12(x0, x0, x0, x0, x0, x0, x0, x0, x0, x0, x0, x0): x0
//
(* ****** ****** *)
//
(*
#symload maxs with gs_max_a0
#symload maxs with gs_max_a1
*)
#symload maxs with gs_max_a2
#symload maxs with gs_max_a3
#symload maxs with gs_max_a4
#symload maxs with gs_max_a5
#symload maxs with gs_max_a6
#symload maxs with gs_max_a7
#symload maxs with gs_max_a8
#symload maxs with gs_max_a9
#symload maxs with gs_max_a10
#symload maxs with gs_max_a11
#symload maxs with gs_max_a12
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-29:
Mon 29 Jul 2024 03:17:20 PM EDT
*)
//
(*
fun
<x0:t0>
gs_min_a0(): x0
fun
<x0:t0>
gs_min_a1(x0): x0
*)
fun
<x0:t0>
gs_min_a2(x0, x0): x0
fun
<x0:t0>
gs_min_a3(x0, x0, x0): x0
fun
<x0:t0>
gs_min_a4(x0, x0, x0, x0): x0
fun
<x0:t0>
gs_min_a5(x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_min_a6(x0, x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_min_a7(x0, x0, x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_min_a8(x0, x0, x0, x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_min_a9(x0, x0, x0, x0, x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_min_a10(x0, x0, x0, x0, x0, x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_min_a11(x0, x0, x0, x0, x0, x0, x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_min_a12(x0, x0, x0, x0, x0, x0, x0, x0, x0, x0, x0, x0): x0
//
(* ****** ****** *)
//
(*
#symload mins with gs_min_a0
#symload mins with gs_min_a1
*)
#symload mins with gs_min_a2
#symload mins with gs_min_a3
#symload mins with gs_min_a4
#symload mins with gs_min_a5
#symload mins with gs_min_a6
#symload mins with gs_min_a7
#symload mins with gs_min_a8
#symload mins with gs_min_a9
#symload mins with gs_min_a10
#symload mins with gs_min_a11
#symload mins with gs_min_a12
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:vt>
gs_free_a1(x0): void
fun
<x0:vt>
<x1:vt>
gs_free_a2(x0, x1): void
fun
<x0:vt>
<x1:vt>
<x2:vt>
gs_free_a3(x0, x1, x2): void
//
fun
<x0:vt>
<x1:vt>
<x2:vt>
<x3:vt>
gs_free_a4(x0, x1, x2, x3): void
//
fun
<x0:vt>
<x1:vt>
<x2:vt>
<x3:vt>
<x4:vt>
gs_free_a5(x0, x1, x2, x3, x4): void
//
fun
<x0:vt>
<x1:vt>
<x2:vt>
<x3:vt>
<x4:vt>
<x5:vt>
gs_free_a6(x0, x1, x2, x3, x4, x5): void
//
fun
<x0:vt>
<x1:vt>
<x2:vt>
<x3:vt>
<x4:vt>
<x5:vt>
<x6:vt>
gs_free_a7(x0, x1, x2, x3, x4, x5, x6): void
//
fun
<x0:vt>
<x1:vt>
<x2:vt>
<x3:vt>
<x4:vt>
<x5:vt>
<x6:vt>
<x7:vt>
gs_free_a8(x0, x1, x2, x3, x4, x5, x6, x7): void
//
fun
<x0:vt>
<x1:vt>
<x2:vt>
<x3:vt>
<x4:vt>
<x5:vt>
<x6:vt>
<x7:vt>
<x8:vt>
gs_free_a9(x0, x1, x2, x3, x4, x5, x6, x7, x8): void
//
fun
<x0:vt>
<x1:vt>
<x2:vt>
<x3:vt>
<x4:vt>
<x5:vt>
<x6:vt>
<x7:vt>
<x8:vt>
<x9:vt>
gs_free_a10(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9): void
//
(* ****** ****** *)
//
fun
<x0:vt>
<x1:vt>
<x2:vt>
<x3:vt>
<x4:vt>
<x5:vt>
<x6:vt>
<x7:vt>
<x8:vt>
<x9:vt>
<x10:vt>
gs_free_a11(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10): void
//
fun
<x0:vt>
<x1:vt>
<x2:vt>
<x3:vt>
<x4:vt>
<x5:vt>
<x6:vt>
<x7:vt>
<x8:vt>
<x9:vt>
<x10:vt>
<x11:vt>
gs_free_a12(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11): void
//
(* ****** ****** *)
//
#symload free with gs_free_a1
//
#symload frees with gs_free_a1
#symload frees with gs_free_a2
#symload frees with gs_free_a3
#symload frees with gs_free_a4
#symload frees with gs_free_a5
#symload frees with gs_free_a6
#symload frees with gs_free_a7
#symload frees with gs_free_a8
#symload frees with gs_free_a9
#symload frees with gs_free_a10
#symload frees with gs_free_a11
#symload frees with gs_free_a12
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
gs_work$beg(): void
fun<>
gs_work$end(): void
fun<>
gs_work$sep(): void
//
(* ****** ****** *)
//
fun<>
gs_work_a0(): void
//
fun
<x0:t0>
gs_work_a1(x0): void
fun
<x0:t0>
<x1:t0>
gs_work_a2(x0, x1): void
fun
<x0:t0>
<x1:t0>
<x2:t0>
gs_work_a3(x0, x1, x2): void
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
gs_work_a4(x0, x1, x2, x3): void
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
<x4:t0>
gs_work_a5(x0, x1, x2, x3, x4): void
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
<x4:t0>
<x5:t0>
gs_work_a6(x0, x1, x2, x3, x4, x5): void
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
<x4:t0>
<x5:t0>
<x6:t0>
gs_work_a7(x0, x1, x2, x3, x4, x5, x6): void
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
<x4:t0>
<x5:t0>
<x6:t0>
<x7:t0>
gs_work_a8(x0, x1, x2, x3, x4, x5, x6, x7): void
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
<x4:t0>
<x5:t0>
<x6:t0>
<x7:t0>
<x8:t0>
gs_work_a9(x0, x1, x2, x3, x4, x5, x6, x7, x8): void
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
<x4:t0>
<x5:t0>
<x6:t0>
<x7:t0>
<x8:t0>
<x9:t0>
gs_work_a10(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9): void
//
(* ****** ****** *)
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
<x4:t0>
<x5:t0>
<x6:t0>
<x7:t0>
<x8:t0>
<x9:t0>
<x10:t0>
gs_work_a11(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10): void
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
<x4:t0>
<x5:t0>
<x6:t0>
<x7:t0>
<x8:t0>
<x9:t0>
<x10:t0>
<x11:t0>
gs_work_a12(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11): void
//
(* ****** ****** *)
//
#symload work with gs_work_a1
//
#symload works with gs_work_a0
#symload works with gs_work_a1
#symload works with gs_work_a2
#symload works with gs_work_a3
#symload works with gs_work_a4
#symload works with gs_work_a5
#symload works with gs_work_a6
#symload works with gs_work_a7
#symload works with gs_work_a8
#symload works with gs_work_a9
#symload works with gs_work_a10
#symload works with gs_work_a11
#symload works with gs_work_a12
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-05-08:
Thu May  8 09:29:23 PM EDT 2025
*)
//
fun<>
gs_tostr_a0(): strn
fun
<x0:t0>
gs_tostr_a1(x0): strn
fun
<x0:t0>
<x1:t0>
gs_tostr_a2(x0, x1): strn
fun
<x0:t0>
<x1:t0>
<x2:t0>
gs_tostr_a3(x0, x1, x2): strn
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
gs_tostr_a4(x0, x1, x2, x3): strn
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
<x4:t0>
gs_tostr_a5(x0, x1, x2, x3, x4): strn
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
<x4:t0>
<x5:t0>
gs_tostr_a6(x0, x1, x2, x3, x4, x5): strn
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
<x4:t0>
<x5:t0>
<x6:t0>
gs_tostr_a7(x0, x1, x2, x3, x4, x5, x6): strn
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
<x4:t0>
<x5:t0>
<x6:t0>
<x7:t0>
gs_tostr_a8(x0, x1, x2, x3, x4, x5, x6, x7): strn
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
<x4:t0>
<x5:t0>
<x6:t0>
<x7:t0>
<x8:t0>
gs_tostr_a9(x0, x1, x2, x3, x4, x5, x6, x7, x8): strn
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
<x4:t0>
<x5:t0>
<x6:t0>
<x7:t0>
<x8:t0>
<x9:t0>
gs_tostr_a10(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9): strn
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
<x4:t0>
<x5:t0>
<x6:t0>
<x7:t0>
<x8:t0>
<x9:t0>
<x10:t0>
gs_tostr_a11(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10): strn
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
<x4:t0>
<x5:t0>
<x6:t0>
<x7:t0>
<x8:t0>
<x9:t0>
<x10:t0>
<x11:t0>
gs_tostr_a12(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11): strn
//
(* ****** ****** *)
//
#symload tostr with gs_tostr_a1
//
#symload tostrs with gs_tostr_a0
#symload tostrs with gs_tostr_a1
#symload tostrs with gs_tostr_a2
#symload tostrs with gs_tostr_a3
#symload tostrs with gs_tostr_a4
#symload tostrs with gs_tostr_a5
#symload tostrs with gs_tostr_a6
#symload tostrs with gs_tostr_a7
#symload tostrs with gs_tostr_a8
#symload tostrs with gs_tostr_a9
#symload tostrs with gs_tostr_a10
#symload tostrs with gs_tostr_a11
#symload tostrs with gs_tostr_a12
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<(*tmp*)>
gs_print$beg(): void
fun
<(*tmp*)>
gs_print$sep(): void
fun
<(*tmp*)>
gs_print$end(): void
//
(* ****** ****** *)
//
fun<>
gs_print_a0(): void
//
fun
<x0:t0>
gs_print_a1(x0): void
fun
<x0:t0>
<x1:t0>
gs_print_a2(x0, x1): void
fun
<x0:t0>
<x1:t0>
<x2:t0>
gs_print_a3(x0, x1, x2): void
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
gs_print_a4(x0, x1, x2, x3): void
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
<x4:t0>
gs_print_a5(x0, x1, x2, x3, x4): void
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
<x4:t0>
<x5:t0>
gs_print_a6(x0, x1, x2, x3, x4, x5): void
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
<x4:t0>
<x5:t0>
<x6:t0>
gs_print_a7(x0, x1, x2, x3, x4, x5, x6): void
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
<x4:t0>
<x5:t0>
<x6:t0>
<x7:t0>
gs_print_a8(x0, x1, x2, x3, x4, x5, x6, x7): void
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
<x4:t0>
<x5:t0>
<x6:t0>
<x7:t0>
<x8:t0>
gs_print_a9(x0, x1, x2, x3, x4, x5, x6, x7, x8): void
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
<x4:t0>
<x5:t0>
<x6:t0>
<x7:t0>
<x8:t0>
<x9:t0>
gs_print_a10(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9): void
//
(* ****** ****** *)
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
<x4:t0>
<x5:t0>
<x6:t0>
<x7:t0>
<x8:t0>
<x9:t0>
<x10:t0>
gs_print_a11(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10): void
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
<x4:t0>
<x5:t0>
<x6:t0>
<x7:t0>
<x8:t0>
<x9:t0>
<x10:t0>
<x11:t0>
gs_print_a12(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11): void
//
(* ****** ****** *)
//
#symload print with gs_print_a1
//
#symload prints with gs_print_a0
#symload prints with gs_print_a1
#symload prints with gs_print_a2
#symload prints with gs_print_a3
#symload prints with gs_print_a4
#symload prints with gs_print_a5
#symload prints with gs_print_a6
#symload prints with gs_print_a7
#symload prints with gs_print_a8
#symload prints with gs_print_a9
#symload prints with gs_print_a10
#symload prints with gs_print_a11
#symload prints with gs_print_a12
//
(* ****** ****** *)
//
(*
HX-2024-07-31:
Wed 31 Jul 2024 07:34:41 PM EDT
How about supporting
the following style of macro form:
#define printsln@xs (prints@xs; println())
*)
//
(* ****** ****** *)
//
fun<>
gs_println_a0(): void
//
fun
<x0:t0>
gs_println_a1(x0): void
fun
<x0:t0>
<x1:t0>
gs_println_a2(x0, x1): void
fun
<x0:t0>
<x1:t0>
<x2:t0>
gs_println_a3(x0, x1, x2): void
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
gs_println_a4(x0, x1, x2, x3): void
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
<x4:t0>
gs_println_a5(x0, x1, x2, x3, x4): void
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
<x4:t0>
<x5:t0>
gs_println_a6(x0, x1, x2, x3, x4, x5): void
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
<x4:t0>
<x5:t0>
<x6:t0>
gs_println_a7(x0, x1, x2, x3, x4, x5, x6): void
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
<x4:t0>
<x5:t0>
<x6:t0>
<x7:t0>
gs_println_a8(x0, x1, x2, x3, x4, x5, x6, x7): void
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
<x4:t0>
<x5:t0>
<x6:t0>
<x7:t0>
<x8:t0>
gs_println_a9(x0, x1, x2, x3, x4, x5, x6, x7, x8): void
//
fun
<x0:t0>
<x1:t0>
<x2:t0>
<x3:t0>
<x4:t0>
<x5:t0>
<x6:t0>
<x7:t0>
<x8:t0>
<x9:t0>
gs_println_a10(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9): void
//
(* ****** ****** *)
//
#symload println with gs_println_a0
#symload println with gs_println_a1
//
#symload printsln with gs_println_a0
#symload printsln with gs_println_a1
#symload printsln with gs_println_a2
#symload printsln with gs_println_a3
#symload printsln with gs_println_a4
#symload printsln with gs_println_a5
#symload printsln with gs_println_a6
#symload printsln with gs_println_a7
#symload printsln with gs_println_a8
#symload printsln with gs_println_a9
#symload printsln with gs_println_a10
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-31:
Wed 31 Jul 2024 07:45:52 PM EDT
*)
//
(*
fun
<x0:t0>
gs_append_a0
( (*void*) ): x0
fun
<x0:t0>
gs_append_a1(x0): x0
*)
fun
<x0:t0>
gs_append_a2(x0, x0): x0
fun
<x0:t0>
gs_append_a3(x0, x0, x0): x0
fun
<x0:t0>
gs_append_a4(x0, x0, x0, x0): x0
fun
<x0:t0>
gs_append_a5(x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_append_a6(x0, x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_append_a7(x0, x0, x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_append_a8(x0, x0, x0, x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_append_a9(x0, x0, x0, x0, x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_append_a10(x0, x0, x0, x0, x0, x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_append_a11(x0, x0, x0, x0, x0, x0, x0, x0, x0, x0, x0): x0
fun
<x0:t0>
gs_append_a12(x0, x0, x0, x0, x0, x0, x0, x0, x0, x0, x0, x0): x0
//
(* ****** ****** *)
//
(*
#symload appends with gs_append_a0
#symload appends with gs_append_a1
*)
#symload appends with gs_append_a2
#symload appends with gs_append_a3
#symload appends with gs_append_a4
#symload appends with gs_append_a5
#symload appends with gs_append_a6
#symload appends with gs_append_a7
#symload appends with gs_append_a8
#symload appends with gs_append_a9
#symload appends with gs_append_a10
#symload appends with gs_append_a11
#symload appends with gs_append_a12
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_gsyn000.sats] *)
(***********************************************************************)
`,
  "SATS/gsyn001.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Wed 31 Jul 2024 03:49:34 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<y0:t0>
gs_forall_a1(y0): bool
fun
<y0:t0>
<y1:t0>
gs_forall_a2(y0, y1): bool
fun
<y0:t0>
<y1:t0>
<y2:t0>
gs_forall_a3(y0, y1, y2): bool
//
fun
<y0:t0>
<y1:t0>
<y2:t0>
<y3:t0>
gs_forall_a4(y0, y1, y2, y3): bool
//
fun
<y0:t0>
<y1:t0>
<y2:t0>
<y3:t0>
<y4:t0>
gs_forall_a5(y0, y1, y2, y3, y4): bool
//
fun
<y0:t0>
<y1:t0>
<y2:t0>
<y3:t0>
<y4:t0>
<y5:t0>
gs_forall_a6(y0, y1, y2, y3, y4, y5): bool
//
fun
<y0:t0>
<y1:t0>
<y2:t0>
<y3:t0>
<y4:t0>
<y5:t0>
<y6:t0>
gs_forall_a7(y0, y1, y2, y3, y4, y5, y6): bool
//
fun
<y0:t0>
<y1:t0>
<y2:t0>
<y3:t0>
<y4:t0>
<y5:t0>
<y6:t0>
<y7:t0>
gs_forall_a8(y0, y1, y2, y3, y4, y5, y6, y7): bool
//
fun
<y0:t0>
<y1:t0>
<y2:t0>
<y3:t0>
<y4:t0>
<y5:t0>
<y6:t0>
<y7:t0>
<y8:t0>
gs_forall_a9(y0, y1, y2, y3, y4, y5, y6, y7, y8): bool
//
fun
<y0:t0>
<y1:t0>
<y2:t0>
<y3:t0>
<y4:t0>
<y5:t0>
<y6:t0>
<y7:t0>
<y8:t0>
<y9:t0>
gs_forall_a10(y0, y1, y2, y3, y4, y5, y6, y7, y8, y9): bool
//
(* ****** ****** *)
//
fun
<y0:t0>
<y1:t0>
<y2:t0>
<y3:t0>
<y4:t0>
<y5:t0>
<y6:t0>
<y7:t0>
<y8:t0>
<y9:t0>
<y10:t0>
gs_forall_a11(y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10): bool
//
fun
<y0:t0>
<y1:t0>
<y2:t0>
<y3:t0>
<y4:t0>
<y5:t0>
<y6:t0>
<y7:t0>
<y8:t0>
<y9:t0>
<y10:t0>
<y11:t0>
gs_forall_a12(y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11): bool
//
(* ****** ****** *)
//
#symload foralls with gs_forall_a1
#symload foralls with gs_forall_a2
#symload foralls with gs_forall_a3
#symload foralls with gs_forall_a4
#symload foralls with gs_forall_a5
#symload foralls with gs_forall_a6
#symload foralls with gs_forall_a7
#symload foralls with gs_forall_a8
#symload foralls with gs_forall_a9
#symload foralls with gs_forall_a10
#symload foralls with gs_forall_a11
#symload foralls with gs_forall_a12
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<y0:t0>
gs_foritm_a1(y0): void
fun
<y0:t0>
<y1:t0>
gs_foritm_a2(y0, y1): void
fun
<y0:t0>
<y1:t0>
<y2:t0>
gs_foritm_a3(y0, y1, y2): void
//
fun
<y0:t0>
<y1:t0>
<y2:t0>
<y3:t0>
gs_foritm_a4(y0, y1, y2, y3): void
//
fun
<y0:t0>
<y1:t0>
<y2:t0>
<y3:t0>
<y4:t0>
gs_foritm_a5(y0, y1, y2, y3, y4): void
//
fun
<y0:t0>
<y1:t0>
<y2:t0>
<y3:t0>
<y4:t0>
<y5:t0>
gs_foritm_a6(y0, y1, y2, y3, y4, y5): void
//
fun
<y0:t0>
<y1:t0>
<y2:t0>
<y3:t0>
<y4:t0>
<y5:t0>
<y6:t0>
gs_foritm_a7(y0, y1, y2, y3, y4, y5, y6): void
//
fun
<y0:t0>
<y1:t0>
<y2:t0>
<y3:t0>
<y4:t0>
<y5:t0>
<y6:t0>
<y7:t0>
gs_foritm_a8(y0, y1, y2, y3, y4, y5, y6, y7): void
//
fun
<y0:t0>
<y1:t0>
<y2:t0>
<y3:t0>
<y4:t0>
<y5:t0>
<y6:t0>
<y7:t0>
<y8:t0>
gs_foritm_a9(y0, y1, y2, y3, y4, y5, y6, y7, y8): void
//
fun
<y0:t0>
<y1:t0>
<y2:t0>
<y3:t0>
<y4:t0>
<y5:t0>
<y6:t0>
<y7:t0>
<y8:t0>
<y9:t0>
gs_foritm_a10(y0, y1, y2, y3, y4, y5, y6, y7, y8, y9): void
//
(* ****** ****** *)
//
fun
<y0:t0>
<y1:t0>
<y2:t0>
<y3:t0>
<y4:t0>
<y5:t0>
<y6:t0>
<y7:t0>
<y8:t0>
<y9:t0>
<y10:t0>
gs_foritm_a11(y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10): void
//
fun
<y0:t0>
<y1:t0>
<y2:t0>
<y3:t0>
<y4:t0>
<y5:t0>
<y6:t0>
<y7:t0>
<y8:t0>
<y9:t0>
<y10:t0>
<y11:t0>
gs_foritm_a12(y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y11): void
//
(* ****** ****** *)
//
#symload foritms with gs_foritm_a1
#symload foritms with gs_foritm_a2
#symload foritms with gs_foritm_a3
#symload foritms with gs_foritm_a4
#symload foritms with gs_foritm_a5
#symload foritms with gs_foritm_a6
#symload foritms with gs_foritm_a7
#symload foritms with gs_foritm_a8
#symload foritms with gs_foritm_a9
#symload foritms with gs_foritm_a10
#symload foritms with gs_foritm_a11
#symload foritms with gs_foritm_a12
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_gsyn001.sats] *)
(***********************************************************************)
`,
  "SATS/list000.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon 08 Jul 2024 11:17:44 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
list_nil_
{a:t0}(): list(a,0)
fun
<a:t0>
list_cons_
{n:i0}
(
x0:(a),
xs:list(a,n)): list(a,n+1)
//
(* ****** ****** *)
//
fun<>
list_nilq
{a:t0}{n:i0}
(xs: list(a,n)): bool(n=0)
fun<>
list_consq
{a:t0}{n:i0}
(xs: list(a,n)): bool(n>0)
//
#symload
nilq with list_nilq of 1000
#symload
consq with list_consq of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:t0>
list_head
{n:i0|n>0}
(xs: list(a,n)): ( a )
fun
<a:t0>
list_tail
{n:i0|n>0}
( xs
: list(a,n)): list(a,n-1)
//
#symload
head with list_head of 1000
#symload
tail with list_tail of 1000
//
(* ****** ****** *)
//
fun
<a:t0>
list_head$opt
(xs: list(a)): optn_vt(a)
fun
<a:t0>
list_tail$opt
(xs: list(a)): optn_vt(list(a))
//
#symload
head$opt with list_head$opt of 1000
#symload
tail$opt with list_tail$opt of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-08:
Thu Jan  8 10:54:42 AM EST 2026
*)
//
fun
<a:t0>
list_make((*0*)): list(a)
fun<>
list_make'len((*0*)): nint
(*
g_make<list(a)> = list_make<a>
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:t0>
list_make_1val
( x1: a): list(a, 1)
fun
<a:t0>
list_make_2val
(x1: a, x2: a): list(a, 2)
fun
<a:t0>
list_make_3val
(x1: a
,x2: a, x3: a): list(a, 3)
//
#symload
list_sing with list_make_1val
#symload
list_pair with list_make_2val
//
#symload
list_1val with list_make_1val
#symload
list_2val with list_make_2val
#symload
list_3val with list_make_3val
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:t0>
list_make_ncpy
{n:nat}
(n0: sint(n), x0: a): list(a, n)
(*
#symload
list with list_make_ncpy//1000
*)
#symload
list_ncpy with list_make_ncpy//1000
//
fun
<a:t0>
list_make_nfun
{n:nat}
(n0: sint(n)
,f0: nintlt(n)->(a)): list(a, n)
//
#symload
list with list_make_nfun//1000
#symload
list_nfun with list_make_nfun//1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:t0>
list_length
{n:i0}
(xs: list(a, n)): sint(n)
//
#symload
length with list_length of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-06-01:
This is just [list_listize]!
*)
fun
<a:t0>
list_copy_vt
{n:i0}
(xs: list(a, n)): list_vt(a, n)
//
(*
HX-2025-12-17:
This is just [list_rlistize]!
*)
fun
<a:t0>
list_rcopy_vt
{n:i0}
(xs: list(a, n)): list_vt(a, n)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-17:
Wed 17 Jul 2024 05:27:03 PM EDT
*)
//
fun
<a:t0>
list_extend
{n:i0}
( xs
: list(a, n)
, y0: a(*elt*)): list(a, n+1)
//
fun
<a:t0>
list_append
{m,n:i0}
( xs: list(a, m)
, ys: list(a, n)): list(a, m+n)
//
fun
<a:t0>
list_append_vt
{m,n:i0}
( xs: list(a, m)
, ys: list(a, n)): list_vt(a, m+n)
//
fun
<a:t0>
list_appendx0_vt
{m,n:i0}
( xs: list(a, m)
, ys: list_vt(a, n)): list_vt(a, m+n)
//
(* ****** ****** *)
//
#symload
append with list_append of 1000
#symload
append_vt with list_append_vt of 1000
#symload
appendx0_vt with list_appendx0_vt of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:t0>
list_reverse
{n:i0}
(xs: list(a, n)): list(a, n)
fun
<a:t0>
list_reverse_vt
{n:i0}
(xs: list(a, n)): list_vt(a, n)
//
(* ****** ****** *)
//
#symload
reverse with list_reverse of 1000
#symload
reverse_vt with list_reverse_vt of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:t0>
list_rappend
{m,n:i0}
( xs: list(a, m)
, ys: list(a, n)): list(a, m+n)
//
fun
<a:t0>
list_rappend_vt
{m,n:i0}
( xs: list(a, m)
, ys: list(a, n)): list_vt(a, m+n)
//
fun
<a:t0>
list_rappendx0_vt
{m,n:i0}
( xs: list(a, m)
, ys: list_vt(a, n)): list_vt(a, m+n)
//
(* ****** ****** *)
//
#symload
rappend with list_rappend of 1000
#symload
rappend_vt with list_rappend_vt of 1000
#symload
rappendx0_vt with list_rappendx0_vt of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-04:
Is GSEQ coming of age?
Sun 04 Aug 2024 08:24:43 AM EDT
*)
fcast // fun
GSEQ_make_list
{a:t0}
(xs: list(a)): GSEQ(list(a), a)
#symload GSEQ with GSEQ_make_list of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<xs:t0>
<x0:t0>
list_make_gseq(xs: xs): list(x0)
//
fun
<xs:t0>
<x0:t0>
<y0:t0>
// HX: map$fopr(x0):y0
list_map$make_gseq(xs: xs): list(y0)
//
(* ****** ****** *)
//
fun
<x0:t0>
list_make_t0up1
(tup: t0up(x0)): list(x0,1)
fun
<x0:t0>
list_make_t0up2
(tup: t0up(x0,x0)): list(x0,2)
fun
<x0:t0>
list_make_t0up3
(tup: t0up(x0,x0,x0)): list(x0,3)
//
fun
<x0:t0>
list_make_t0up4
(tup: t0up(x0,x0,x0,x0)): list(x0,4)
fun
<x0:t0>
list_make_t0up5
(tup: t0up(x0,x0,x0,x0,x0)): list(x0,5)
fun
<x0:t0>
list_make_t0up6
(tup: t0up(x0,x0,x0,x0,x0,x0)): list(x0,6)
//
(* ****** ****** *)
//
#symload list with list_make_t0up1 of 1000
#symload list with list_make_t0up2 of 1000
#symload list with list_make_t0up3 of 1000
//
#symload list with list_make_t0up4 of 1000
#symload list with list_make_t0up5 of 1000
#symload list with list_make_t0up6 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-15:
Mon Dec 15 02:13:09 PM EST 2025
*)
//
fun
<a:t0>
list_make_lstrm
(xs: strm_vt(a)): list(a)
fun
<a:t0>
list_make_lstrq
{n:i0}
(xs: strq_vt(a, n)): list(a, n)
//
#symload list with list_make_lstrm of 1000
#symload list with list_make_lstrq of 1000
#symload list_lstrm with list_make_lstrm of 1000
#symload list_lstrq with list_make_lstrq of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-13:
Sat Dec 13 10:14:26 PM EST 2025
*)
//
fun
<a:t0>
list_list$concat(list(list(a))): list(a)
fun
<a:t0>
list_list$concat_vt(list(list(a))): list_vt(a)
//
#symload concat with list_list$concat of 1000
#symload concat_vt with list_list$concat_vt of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_list000.sats] *)
(***********************************************************************)
`,
  "SATS/list001.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sun 28 Jul 2024 08:51:05 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:t0>
list_listize
{n:i0}
(xs: list(a, n)): list_vt(a, n)
//
#symload listize with list_listize of 1000
//
fun
<a:t0>
list_rlistize
{n:i0}
(xs: list(a, n)): list_vt(a, n)
//
#symload rlistize with list_rlistize of 1000
//
(* ****** ****** *)
//
fun
<a:t0>
list_strmize
(xs: list(a)): strm_vt(a)
fun
<a:t0>
list_strqize
{n:i0}
(xs: list(a, n)): strq_vt(a, n)
//
#symload strmize with list_strmize of 1000
#symload strqize with list_strqize of 1000
//
(* ****** ****** *)
//
fun
<a:t0>
list_rstrmize
(xs: list(a)): strm_vt(a)
fun
<a:t0>
list_rstrqize
{n:i0}
(xs: list(a, n)): strq_vt(a, n)
//
#symload rstrmize with list_rstrmize of 1000
#symload rstrqize with list_rstrqize of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:t0>
list_forall(xs: list(x0)): bool
fun
<x0:t0>
list_rforall(xs: list(x0)): bool
fun
<x0:t0>
list_iforall(xs: list(x0)): bool
fun
<x0:t0>
list_irforall(xs: list(x0)): bool
//
#symload forall with list_forall of 1000
#symload rforall with list_rforall of 1000
#symload iforall with list_iforall of 1000
#symload irforall with list_irforall of 1000
//
(* ****** ****** *)
//
fun
<x0:t0>
list_forall$f1un
( xs
: list(x0), test: (x0) -> bool): bool
#symload forall with list_forall$f1un of 1000
#symload forall$fun with list_forall$f1un of 1000
#symload list_forall with list_forall$f1un of 1000
//
fun
<x0:t0>
list_iforall$f2un
( xs
: list(x0), test: (ni,x0) -> bool): bool
#symload iforall with list_iforall$f2un of 1000
#symload iforall$fun with list_iforall$f2un of 1000
#symload list_iforall with list_iforall$f2un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:t0>
list_exists(xs: list(x0)): bool
fun
<x0:t0>
list_rexists(xs: list(x0)): bool
fun
<x0:t0>
list_iexists(xs: list(x0)): bool
fun
<x0:t0>
list_irexists(xs: list(x0)): bool
//
#symload exists with list_exists of 1000
#symload rexists with list_rexists of 1000
#symload iexists with list_iexists of 1000
#symload irexists with list_irexists of 1000
//
(* ****** ****** *)
//
fun
<x0:t0>
list_exists$f1un
( xs
: list(x0), test: (x0) -> bool): bool
#symload exists with list_exists$f1un of 1000
#symload exists$fun with list_exists$f1un of 1000
#symload list_exists with list_exists$f1un of 1000
//
fun
<x0:t0>
list_iexists$f2un
( xs
: list(x0), test: (ni,x0) -> bool): bool
#symload iexists with list_iexists$f2un of 1000
#symload iexists$fun with list_iexists$f2un of 1000
#symload list_iexists with list_iexists$f2un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:t0>
list_foritm(xs: list(x0)): void
fun
<x0:t0>
list_rforitm(xs: list(x0)): void
fun
<x0:t0>
list_iforitm(xs: list(x0)): void
fun
<x0:t0>
list_irforitm(xs: list(x0)): void
//
#symload foritm with list_foritm of 1000
#symload rforitm with list_rforitm of 1000
#symload iforitm with list_iforitm of 1000
#symload irforitm with list_irforitm of 1000
//
(* ****** ****** *)
//
fun
<x0:t0>
list_foritm$f1un
( xs
: list(x0), work: (x0) -> void): void
#symload foritm with list_foritm$f1un of 1000
#symload foritm$fun with list_foritm$f1un of 1000
#symload list_foritm with list_foritm$f1un of 1000
//
fun
<x0:t0>
list_rforitm$f1un
( xs
: list(x0), work: (x0) -> void): void
#symload rforitm with list_rforitm$f1un of 1000
#symload rforitm$fun with list_rforitm$f1un of 1000
#symload list_rforitm with list_rforitm$f1un of 1000
//
fun
<x0:t0>
list_iforitm$f2un
( xs
: list(x0), work: (ni,x0) -> void): void
#symload iforitm with list_iforitm$f2un of 1000
#symload iforitm$fun with list_iforitm$f2un of 1000
#symload list_iforitm with list_iforitm$f2un of 1000
//
fun
<x0:t0>
list_irforitm$f2un
( xs
: list(x0), work: (ni,x0) -> void): void
#symload irforitm with list_irforitm$f2un of 1000
#symload irforitm$fun with list_irforitm$f2un of 1000
#symload list_irforitm with list_irforitm$f2un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-11-03:
Mon Nov  3 03:57:40 PM EST 2025
*)
//
fun
<x0:t0>
<r0:vt>
list_folditm
(xs: list(x0), r0: r0): ( r0 )
fun
<x0:t0>
<r0:vt>
list_rfolditm
(xs: list(x0), r0: r0): ( r0 )
fun
<x0:t0>
<r0:vt>
list_ifolditm
(xs: list(x0), r0: r0): ( r0 )
fun
<x0:t0>
<r0:vt>
list_irfolditm
(xs: list(x0), r0: r0): ( r0 )
//
#symload folditm with list_folditm of 1000
#symload rfolditm with list_rfolditm of 1000
#symload ifolditm with list_ifolditm of 1000
#symload irfolditm with list_irfolditm of 1000
//
(* ****** ****** *)
//
fun
<x0:t0>
<r0:vt>
list_folditm$f2un
( xs
: list(x0), r0: r0, fopr: (r0, x0) -> r0): (r0)
#symload folditm with list_folditm$f2un of 1000
#symload folditm$fun with list_folditm$f2un of 1000
#symload list_folditm with list_folditm$f2un of 1000
//
fun
<x0:t0>
<r0:vt>
list_rfolditm$f2un
( xs
: list(x0), r0: r0, fopr: (x0, r0) -> r0): (r0)
#symload rfolditm with list_rfolditm$f2un of 1000
#symload rfolditm$fun with list_rfolditm$f2un of 1000
#symload list_rfolditm with list_rfolditm$f2un of 1000
//
fun
<x0:t0>
<r0:vt>
list_ifolditm$f3un
( xs
: list(x0), r0: r0, fopr: (r0,ni,x0) -> r0): (r0)
#symload ifolditm with list_ifolditm$f3un of 1000
#symload ifolditm$fun with list_ifolditm$f3un of 1000
#symload list_ifolditm with list_ifolditm$f3un of 1000
//
fun
<x0:t0>
<r0:vt>
list_irfolditm$f3un
( xs
: list(x0), r0: r0, fopr: (ni,x0,r0) -> r0): (r0)
#symload irfolditm with list_irfolditm$f3un of 1000
#symload irfolditm$fun with list_irfolditm$f3un of 1000
#symload list_irfolditm with list_irfolditm$f3un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-31:
Wed 31 Jul 2024 03:16:49 AM EDT
*)
fun
<x0:t0>
list_2choose_lstrm
(xs: list(x0)): strm_vt@(x0, x0)
//
#symload c2hoose_lstrm with list_2choose_lstrm
//
fun
<x0:t0>
list_2choose$forall(list(x0)): bool
fun
<x0:t0>
list_2choose$forall$f2un
(xs:list(x0), test:(x0,x0)->bool): bool
//
#symload c2hoose$forall with list_2choose$forall
#symload c2hoose$forall with list_2choose$forall$f2un
//
(* ****** ****** *)
//
fun
<x0:t0>
list_3choose_lstrm
(xs: list(x0)): strm_vt@(x0, x0, x0)
//
#symload c3hoose_lstrm with list_3choose_lstrm
//
fun
<x0:t0>
list_3choose$forall(list(x0)): bool
fun
<x0:t0>
list_3choose$forall$f3un
(xs:list(x0), test:(x0,x0,x0)->bool): bool
//
#symload c3hoose$forall with list_3choose$forall
#symload c3hoose$forall with list_3choose$forall$f3un
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-31:
Wed 31 Jul 2024 12:53:34 PM EDT
*)
//
fun
<x0:t0>
list_fmake((*void*)): list(x0)
fun
<x0:t0>
list_fmake_fwork
(fwork: (x0 -> void) -> void): list(x0)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-03:
Tue 03 Sep 2024 01:11:20 PM EDT
*)
//
fun
<x0:t0>
<y0:t0>
list_map
{ln:i0}
(xs: list(x0, ln)): list(y0, ln)
fun
<x0:t0>
<y0:t0>
list_map$f1un
{ln:i0}
( xs
: list(x0, ln), fopr: (x0)->y0): list(y0, ln)
//
#symload map with list_map of 1000
#symload map with list_map$f1un of 1000
#symload map$fun with list_map$f1un of 1000
#symload list_map with list_map$f1un of 1000
//
(* ****** ****** *)
//
fun
<x0:t0>
<y0:vt>
list_map_vt
{ln:i0}
(xs: list(x0, ln)): list_vt(y0, ln)
fun
<x0:t0>
<y0:vt>
list_map$f1un_vt
{ln:i0}
( xs
: list(x0, ln), fopr: (x0)->y0): list_vt(y0, ln)
//
#symload map_vt with list_map_vt of 1000
#symload map_vt with list_map$f1un_vt of 1000
#symload map$fun_vt with list_map$f1un_vt of 1000
#symload list_map_vt with list_map$f1un_vt of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:t0>
<y0:t0>
list_maprev
{ln:i0}
(xs: list(x0, ln)): list(y0, ln)
fun
<x0:t0>
<y0:t0>
list_maprev$f1un
{ln:i0}
( xs
: list(x0, ln), fopr: (x0)->y0): list(y0, ln)
//
#symload maprev with list_maprev of 1000
#symload maprev with list_maprev$f1un of 1000
#symload maprev$fun with list_maprev$f1un of 1000
#symload list_maprev with list_maprev$f1un of 1000
//
(* ****** ****** *)
//
fun
<x0:t0>
<y0:vt>
list_maprev_vt
{ln:i0}
(xs: list(x0, ln)): list_vt(y0, ln)
fun
<x0:t0>
<y0:vt>
list_maprev$f1un_vt
{ln:i0}
( xs
: list(x0, ln), fopr: (x0)->y0): list_vt(y0, ln)
//
#symload maprev_vt with list_maprev_vt of 1000
#symload maprev_vt with list_maprev$f1un_vt of 1000
#symload maprev$fun_vt with list_maprev$f1un_vt of 1000
#symload list_maprev_vt with list_maprev$f1un_vt of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-05-31:
Sat May 31 07:59:21 PM EDT 2025
*)
//
fun
<x0:t0>
<y0:t0>
<e1:vt>
list_map$e1nv
{ln:i0}
(xs: list(x0, ln), e1: !e1): list(y0, ln)
fun
<x0:t0>
<y0:t0>
<e1:vt>
list_map$e1nv$f2un
{ln:i0}
( xs
: list(x0, ln), e1: !e1, fopr: (x0, !e1)->y0): list(y0, ln)
//
#symload map$e1nv with list_map$e1nv of 1000
#symload map$e1nv with list_map$e1nv$f2un of 1000
(*
HX-2025-09-08:
Mon Sep  8 02:35:01 AM EDT 2025
This conflicts with list_map$f2un:
#symload list_map with list_map$e1nv of 1000
#symload list_map with list_map$e1nv$f2un of 1000
*)
#symload list_map$e1nv with list_map$e1nv$f2un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-14:
Sun Dec 14 10:33:19 AM EST 2025
*)
//
fun
<x0:t0>
list_filter
{ln:i0}
(xs: list(x0, ln)): listlte(x0, ln)
fun
<x0:t0>
list_filter_vt
{ln:i0}
(xs: list(x0, ln)): listlte_vt(x0, ln)
//
fun
<x0:t0>
list_filter$f1un
{ln:i0}
( xs
: list(x0, ln), test: (x0)->bool): listlte(x0, ln)
fun
<x0:t0>
list_filter$f1un_vt
{ln:i0}
( xs
: list(x0, ln), test: (x0)->bool): listlte_vt(x0, ln)
//
#symload filter with list_filter of 1000
#symload filter with list_filter$f1un of 1000
#symload filter$fun with list_filter$f1un of 1000
#symload list_filter with list_filter$f1un of 1000
//
#symload filter_vt with list_filter_vt of 1000
#symload filter_vt with list_filter$f1un_vt of 1000
#symload filter$fun_vt with list_filter$f1un_vt of 1000
#symload list_filter_vt with list_filter$f1un_vt of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-14:
Sun Dec 14 11:11:41 AM EST 2025
*)
//
fun
<x0:t0>
list_1choose$split_lstrm
{ln:i0}
(xs: list(x0, ln)): strm_vt@(x0, list_vt(x0, ln-1))
#symload c1hoose$split_lstrm with list_1choose$split_lstrm
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-04:
Sun Jan  4 11:11:49 PM EST 2026
*)
//
fun
<x0:t0>
list_memberq
(xs: list(x0), x0: x0): bool
#symload memberq with list_memberq of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_list001.sats] *)
(***********************************************************************)
`,
  "SATS/list002.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sun 11 Aug 2024 09:11:41 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:t0>
<y0:t0>
list_z2forall
( xs: list(x0)
, ys: list(y0)): bool//end-of-[fun]
//
fun
<x0:t0>
<y0:t0>
list_z2iforall
( xs: list(x0)
, ys: list(y0)): bool//end-of-[fun]
//
#symload
z2forall with list_z2forall of 1000
#symload
z2iforall with list_z2iforall of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:t0>
<y0:t0>
list_z2forcmp
( xs: list(x0)
, ys: list(y0)): sint//end-of-[fun]
//
fun
<x0:t0>
<y0:t0>
list_z2iforcmp
( xs: list(x0)
, ys: list(y0)): sint//end-of-[fun]
//
#symload
z2forcmp with list_z2forcmp of 1000
#symload
z2iforcmp with list_z2iforcmp of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:t0>
<y0:t0>
list_z2foritm
( xs: list(x0)
, ys: list(y0)): void//end-of-[fun]
//
fun
<x0:t0>
<y0:t0>
list_z2iforitm
( xs: list(x0)
, ys: list(y0)): void//end-of-[fun]
//
#symload
z2foritm with list_z2foritm of 1000
#symload
z2iforitm with list_z2iforitm of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:t0>
<y0:t0>
<r0:t0>
list_z2folditm
(list(x0), list(y0), r0): (r0)
fun
<x0:t0>
<y0:t0>
<r0:t0>
list_z2ifolditm
(list(x0), list(y0), r0): (r0)
//
#symload
z2folditm with list_z2folditm of 1000
#symload
z2ifolditm with list_z2ifolditm of 1000
//
(* ****** ****** *)
//
fun
<x0:t0>
<y0:t0>
<r0:t0>
list_z2foldall
(list(x0), list(y0), r0): (r0)
fun
<x0:t0>
<y0:t0>
<r0:t0>
list_z2ifoldall
(list(x0), list(y0), r0): (r0)
//
#symload
z2foldall with list_z2foldall of 1000
#symload
z2ifoldall with list_z2ifoldall of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_list002.sats] *)
(***********************************************************************)
`,
  "SATS/lsrt000.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Thu Dec 25 10:09:49 AM EST 2025
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#typedef igtz = sintgt(0)
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-25:
For sorted lists
Originally, I named it 'lord'
instead of 'lsrt'. And today is
Christmas, 2025!
Thu Dec 25 12:03:10 PM EST 2025
*)
//
#abstbox
lsrt_t0_i0_tx
( a:t0,n:i0 ) <= list(a)
//
#sexpdef
lsrt = lsrt_t0_i0_tx
#typedef
lsrt(a:t0) = [n:i0] lsrt(a,n)
//
(* ****** ****** *)
//
fcast
lsrt_decd
{a:t0}
(lsrt(a, n)): list(a, n)
//
fcast
UN_lsrt_encd
{a:t0}
(list(a, n)): lsrt(a, n)
//
(* ****** ****** *)
//
fun<>
lsrt_nil
{a:t0}((*0*)): lsrt(a, 0)
//
(* ****** ****** *)
//
fun<>
lsrt_nilq
{a:t0}{n:i0}
(xs: lsrt(a,n)): bool(n=0)
fun<>
lsrt_consq
{a:t0}{n:i0}
(xs: lsrt(a,n)): bool(n>0)
//
#symload
nilq with lsrt_nilq of 1000
consq with lsrt_consq of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:t0>
lsrt_head
{n:i0|n>0}
(xs: lsrt(a,n)): ( a )
fun
<a:t0>
lsrt_tail
{n:i0|n>0}
( xs
: lsrt(a,n)): lsrt(a,n-1)
//
#symload
head with lsrt_head of 1000
#symload
tail with lsrt_tail of 1000
//
(* ****** ****** *)
//
fun
<a:t0>
lsrt_head$opt
(xs: lsrt(a)): optn_vt(a)
fun
<a:t0>
lsrt_tail$opt
(xs: lsrt(a)): optn_vt(lsrt(a))
//
#symload
head$opt with lsrt_head$opt of 1000
#symload
tail$opt with lsrt_tail$opt of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:t0>
lsrt_make_1val
( x1: a): lsrt(a, 1)
fun
<a:t0>
lsrt_make_2val
(x1: a, x2: a): lsrt(a, 2)
fun
<a:t0>
lsrt_make_3val
(x1: a
,x2: a, x3: a): lsrt(a, 3)
//
#symload
lsrt_sing with lsrt_make_1val
#symload
lsrt_pair with lsrt_make_2val
//
#symload
lsrt_1val with lsrt_make_1val
#symload
lsrt_2val with lsrt_make_2val
#symload
lsrt_3val with lsrt_make_3val
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:t0>
lsrt_length
{n:i0}
(xs: lsrt(a, n)): sint(n)
//
#symload
length with lsrt_length of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-25:
lsrt_exists:
This one uses [exists$tcmp]
lsrt_search:
This one uses [search$tcmp]
*)
fun
<x0:t0>
lsrt_exists
(xs: lsrt(x0)): ( bool )
fun
<x0:t0>
lsrt_search
(xs: lsrt(x0)): optn_vt(x0)
//
(* ****** ****** *)
//
(*
HX-2025-12-25:
insertion happens
at the first available position
Thu Dec 25 12:35:50 PM EST 2025
*)
fun
<x0:t0>
lsrt_insert
{ln:i0}
(xs: lsrt(x0, ln), x0: x0): lsrt(x0, ln+1)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-26:
Fri Dec 26 10:46:11 PM EST 2025
*)
//
fun
<x0:t0>
lsrt_msetize
(xs: lsrt(x0)): list@(x0, igtz)
fun
<x0:t0>
lsrt_msetize_vt
(xs: lsrt(x0)): list_vt@(x0, igtz)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-26:
The keys in a lsrt-map
are assumed to be distinct!!!
Fri Dec 26 10:27:50 AM EST 2025
*)
//
fun
<k0:t0>
<x0:t0>
lsrt$map_search$tst
( map
: lsrt@(k0,x0), key: k0): bool
fun
<k0:t0>
<x0:t0>
lsrt$map_search$opt
( map
: lsrt@(k0,x0), key: k0): optn_vt(x0)
//
fun
<k0:t0>
<x0:t0>
lsrt$map_getout$opt
( map
: lsrt@(k0, x0)
, key   :   k0): (lsrt@(k0,x0), optn_vt(x0))
//
fun
<k0:t0>
<x0:t0>
lsrt$map_insert$opt
( map
: lsrt@(k0,x0)
, key: k0, itm: x0): (lsrt@(k0, x0), optn_vt(x0))
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_lsrt000.sats] *)
(***********************************************************************)
`,
  "SATS/optn000.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon 02 Sep 2024 02:43:08 PM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
optn_nil_
{a:t0}((*0*)): optn(a,ff)
fun
<a:t0>
optn_cons_(x0:(a)): optn(a,tt)
//
(* ****** ****** *)
//
fun<>
optn_nilq
{a:t0}{b:b0}
(xs: optn(a,b)): bool(~b)
fun<>
optn_consq
{a:t0}{b:b0}
(xs: optn(a,b)): bool( b )
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:t0>
optn_head
(xs: optn(a, tt)): (  a  )
//
#symload head with optn_head of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:t0>
optn_make_1val(a): optn(a,tt)
//
#symload
optn with optn_make_1val// of 1000
#symload
optn_1val with optn_make_1val// of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-09-07:
This one can be polymorphic
*)
fun
<a:t0>
optn_length
{b:b0}
(xs:optn(a,b)): sint(b2i(b))
//
#symload length with optn_length of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_optn000.sats] *)
(***********************************************************************)
`,
  "SATS/optn001.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sat 07 Sep 2024 08:18:49 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:t0>
optn_forall(xs: optn(x0)): bool
fun
<x0:t0>
optn_rforall(xs: optn(x0)): bool
fun
<x0:t0>
optn_iforall(xs: optn(x0)): bool
fun
<x0:t0>
optn_irforall(xs: optn(x0)): bool
//
#symload forall with optn_forall of 1000
#symload rforall with optn_rforall of 1000
#symload iforall with optn_iforall of 1000
#symload irforall with optn_irforall of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:t0>
optn_foritm(xs: optn(x0)): void
fun
<x0:t0>
optn_rforitm(xs: optn(x0)): void
fun
<x0:t0>
optn_iforitm(xs: optn(x0)): void
fun
<x0:t0>
optn_irforitm(xs: optn(x0)): void
//
#symload foritm with optn_foritm of 1000
#symload rforitm with optn_rforitm of 1000
#symload iforitm with optn_iforitm of 1000
#symload irforitm with optn_irforitm of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
//
(*
HX-2025-05-29:
Thu May 29 08:44:08 AM EDT 2025
*)
//
fun
<x0:t0>
<y0:t0>
optn_map
{ln:b0}
(xs: optn(x0, ln)): optn(y0, ln)
fun
<x0:t0>
<y0:t0>
optn_map$f1un
{ln:b0}
(xs: optn(x0, ln), (x0)->y0): optn(y0, ln)
//
#symload map with optn_map of 1000
#symload map with optn_map$f1un of 1000
#symload map$fun with optn_map$f1un of 1000
#symload optn_map with optn_map$f1un of 1000
//
(* ****** ****** *)
//
fun
<x0:t0>
<y0:vt>
optn_map_vt
{ln:b0}
(xs: optn(x0, ln)): optn_vt(y0, ln)
fun
<x0:t0>
<y0:vt>
optn_map$f1un_vt
{ln:b0}
(xs: optn(x0, ln), (x0)->y0): optn_vt(y0, ln)
//
#symload map_vt with optn_map_vt of 1000
#symload map_vt with optn_map$f1un_vt of 1000
#symload map$fun_vt with optn_map$f1un_vt of 1000
#symload optn_map_vt with optn_map$f1un_vt of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-06-01:
Sun Jun  1 06:32:15 PM EDT 2025
*)
//
fun
<x0:t0>
<y0:t0>
<e1:vt>
optn_map$e1nv
{ln:b0}
(xs: optn(x0, ln), e1: !e1): optn(y0, ln)
fun
<x0:t0>
<y0:t0>
<e1:vt>
optn_map$e1nv$f2un
{ln:b0}
( xs
: optn(x0, ln), e1: !e1, fopr: (x0, !e1)->y0): optn(y0, ln)
//
#symload map$e1nv with optn_map$e1nv of 1000
#symload map$e1nv with optn_map$e1nv$f2un of 1000
(*
HX-2025-09-08:
Mon Sep  8 02:35:01 AM EDT 2025
This conflicts with optn_map$f2un:
#symload optn_map with optn_map$e1nv of 1000
#symload optn_map with optn_map$e1nv$f2un of 1000
*)
#symload optn_map$e1nv with optn_map$e1nv$f2un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_optn001.sats] *)
(***********************************************************************)
`,
  "SATS/strm000.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sat 07 Sep 2024 07:21:46 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-20:
Sat Dec 20 11:21:52 AM EST 2025
*)
//
fun<>
strm_nil
{a:t0}((*0*)): strm(a)
fun<>
strq_nil
{a:t0}((*0*)): strq(a, 0)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:t0>
strm_sing
( x0: ( a ) ): strm(a)
fun
<a:t0>
strq_sing
( x0: ( a ) ): strq(a, 1)
//
fun
<a:t0>
strm_cons
(
x0: ( a ),
xs: strm( a )): strm( a )
fun
<a:t0>
strq_cons
{n:i0}
(
x0: ( a ),
xs: strq(a, n)): strq(a, n+1)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:t0>
strm_eval(strm(a)): strmcon(a)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-20:
Sat Dec 20 12:27:24 PM EST 2025
*)
fun
<x0:t0>
strm_head
(xs: strm(x0)): (x0)
fun
<x0:t0>
strm_tail
(xs: strm(x0)): strm(x0)
//
#symload
head with strm_head of 1000
#symload
tail with strm_tail of 1000
//
(* ****** ****** *)
//
fun
<x0:t0>
strm_head$opt
(xs: strm(x0)): optn_vt(x0)
fun
<x0:t0>
strm_tail$opt
(xs: strm(x0)): optn_vt(strm(x0))
//
#symload
head$opt with strm_head$opt of 1000
#symload
tail$opt with strm_tail$opt of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:t0>
strm_length
(xs: strm(x0)): (nint)
fun
<x0:t0>
strq_length
{n0:i0}(xs: strq(x0,n0)): sint(n0)
//
#symload length with strm_length of 1000
#symload length with strq_length of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:t0>
strm_append
( xs: strm(x0)
, ys: strm(x0)): strm(x0)
fun
<x0:t0>
strq_append
{n1,n2:i0}
( xs: strq(x0,n1)
, ys: strq(x0,n2)): strq(x0,n1+n2)
//
fun
<x0:t0>
strm_append_vt
( xs: strm(x0)
, ys: strm(x0)): strm_vt(x0)
fun
<x0:t0>
strq_append_vt
{n1,n2:i0}
( xs: strq(x0,n1)
, ys: strq(x0,n2)): strq_vt(x0,n1+n2)
//
#symload append with strm_append of 1000
#symload append with strq_append of 1000
#symload append_vt with strm_append_vt of 1000
#symload append_vt with strq_append_vt of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-21:
Sun Dec 21 07:13:28 PM EST 2025
*)
//
fun<>
strm_beg(): strn
fun<>
strm_end(): strn
fun<>
strm_sep(): strn
fun<>
strm_rst(): strn
//
fun
<x0:t0>
strm_print(xs: strm(x0)): void
//
fun
<x0:t0>
strm_all$print(xs: strm(x0)): void
//
fun<>
strm_print$len(): sint
fun<>
strm_print'len(): sint
fun
<x0:t0>
strm_len$print(xs: strm(x0), ln: sint): void
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_strm000.sats] *)
(***********************************************************************)
`,
  "SATS/strm001.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sat Dec 20 11:28:05 PM EST 2025
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#typedef ni = nint
#typedef si = sint
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:t0>
strm_forall
(xs: strm(x0)): bool
fun
<x0:t0>
strm_iforall
(xs: strm(x0)): bool
//
#symload
forall with strm_forall of 1000
#symload
iforall with strm_iforall of 1000
//
fun
<x0:t0>
strm_forall$f1un
( xs: strm(x0)
, test: (x0) -> bool): bool
//
#symload
forall with strm_forall$f1un of 1000
#symload
forall$fun with strm_forall$f1un of 1000
#symload
strm_forall with strm_forall$f1un of 1000
//
fun
<x0:t0>
strm_iforall$f2un
( xs: strm(x0)
, test: (ni,x0) -> bool): bool
//
#symload
iforall with strm_iforall$f2un of 1000
#symload
iforall$fun with strm_iforall$f2un of 1000
#symload
strm_iforall with strm_iforall$f2un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:t0>
strm_foritm
(xs: strm(x0)): void
fun
<x0:t0>
strm_iforitm
(xs: strm(x0)): void
//
#symload
foritm with strm_foritm of 1000
#symload
iforitm with strm_iforitm of 1000
//
fun
<x0:t0>
strm_foritm$f1un
( xs: strm(x0)
, work: (x0) -> void): void
//
#symload
foritm with strm_foritm$f1un of 1000
#symload
foritm$fun with strm_foritm$f1un of 1000
#symload
strm_foritm with strm_foritm$f1un of 1000
//
fun
<x0:t0>
strm_iforitm$f2un
( xs: strm(x0)
, work: (ni,x0) -> void): void
//
#symload
iforitm with strm_iforitm$f2un of 1000
#symload
iforitm$fun with strm_iforitm$f2un of 1000
#symload
strm_iforitm with strm_iforitm$f2un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
//
fun
<x0:t0>
<r0:vt>
strm_folditm
(xs: strm(x0), r0: r0): (r0)
fun
<x0:t0>
<r0:vt>
strm_ifolditm
(xs: strm(x0), r0: r0): (r0)
//
#symload
folditm with strm_folditm of 1000
#symload
ifolditm with strm_ifolditm of 1000
//
fun
<x0:t0>
<r0:vt>
strm_folditm$f2un
( xs
: strm(x0), r0: r0
, fopr: (r0, x0) -> (r0)): (r0)
//
#symload
folditm with strm_folditm$f2un of 1000
#symload
folditm$fun with strm_folditm$f2un of 1000
#symload
strm_folditm with strm_folditm$f2un of 1000
//
fun
<x0:t0>
<r0:vt>
strm_ifolditm$f3un
( xs
: strm(x0), r0: r0
, fopr: (r0, ni, x0) -> (r0)): (r0)
//
#symload
ifolditm with strm_ifolditm$f3un of 1000
#symload
ifolditm$fun with strm_ifolditm$f3un of 1000
#symload
strm_ifolditm with strm_ifolditm$f3un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
//
fun
<x0:t0>
<r0:vt>
strm_foldall
(xs: strm(x0), r0: r0): (r0)
fun
<x0:t0>
<r0:vt>
strm_ifoldall
(xs: strm(x0), r0: r0): (r0)
//
fun
<x0:t0>
<r0:vt>
strm_foldall$f2un
( xs
: strm(x0), r0: r0
, fopr: (r0, ~x0) -> (bool,r0)): (r0)
//
#symload
foldall with strm_foldall$f2un of 1000
#symload
foldall$fun with strm_foldall$f2un of 1000
#symload
strm_foldall with strm_foldall$f2un of 1000
//
fun
<x0:t0>
<r0:vt>
strm_ifoldall$f3un
( xs
: strm(x0), r0: r0
, fopr: (ni, r0, ~x0) -> (bool,r0)): (r0)
//
#symload
ifoldall with strm_ifoldall$f3un of 1000
#symload
ifoldall$fun with strm_ifoldall$f3un of 1000
#symload
strm_ifoldall with strm_ifoldall$f3un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:t0>
<y0:t0>
strm_map
(xs: strm(x0)): strm(y0)
fun
<x0:t0>
<y0:t0>
strq_map
{ln:i0}
(xs: strq(x0,ln)): strq(y0,ln)
//
fun
<x0:t0>
<y0:vt>
strm_map_vt
(xs: strm(x0)): strm_vt(y0)
fun
<x0:t0>
<y0:vt>
strq_map_vt
{ln:i0}
(xs: strq(x0,ln)): strq_vt(y0,ln)
//
#symload map with strm_map of 1000
#symload map with strq_map of 1000
#symload map_vt with strm_map_vt of 1000
#symload map_vt with strq_map_vt of 1000
//
(* ****** ****** *)
//
fun
<x0:t0>
<y0:t0>
strm_imap
(xs: strm(x0)): strm(y0)
fun
<x0:t0>
<y0:t0>
strq_imap
{ln:i0}
(xs: strq(x0,ln)): strq(y0,ln)
//
fun
<x0:t0>
<y0:vt>
strm_imap_vt
(xs: strm(x0)): strm_vt(y0)
fun
<x0:t0>
<y0:vt>
strq_imap_vt
{ln:i0}
(xs: strq(x0,ln)): strq_vt(y0,ln)
//
#symload imap with strm_imap of 1000
#symload imap with strq_imap of 1000
#symload imap_vt with strm_imap_vt of 1000
#symload imap_vt with strq_imap_vt of 1000
//
(* ****** ****** *)
//
fun
<x0:t0>
<y0:t0>
strm_map$f1un
( xs: strm(x0)
, fopr: (x0) -> (y0)): strm(y0)
fun
<x0:t0>
<y0:t0>
strq_map$f1un
{ln:i0}
( xs: strq(x0,ln)
, fopr: (x0) -> (y0)): strq(y0,ln)
//
#symload map with strm_map$f1un of 1000
#symload map with strq_map$f1un of 1000
#symload map$fun with strm_map$f1un of 1000
#symload map$fun with strq_map$f1un of 1000
#symload strm_map with strm_map$f1un of 1000
#symload strm_map with strq_map$f1un of 1000
//
(* ****** ****** *)
//
fun
<x0:t0>
<y0:t0>
strm_imap$f1un
( xs: strm(x0)
, fopr: (ni, x0) -> (y0)): strm(y0)
fun
<x0:t0>
<y0:t0>
strq_imap$f1un
{ln:i0}
( xs: strq(x0,ln)
, fopr: (ni, x0) -> (y0)): strq(y0,ln)
//
#symload imap with strm_imap$f1un of 1000
#symload imap with strq_imap$f1un of 1000
#symload imap$fun with strm_imap$f1un of 1000
#symload imap$fun with strq_imap$f1un of 1000
#symload strm_imap with strm_imap$f1un of 1000
#symload strm_imap with strq_imap$f1un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:t0>
strm_filter
(xs: strm(x0)): strm(x0)
fun
<x0:t0>
strq_filter
{ln:i0}
(xs: strq(x0,ln)): strqlte(x0,ln)
//
fun
<x0:t0>
strm_filter_vt
(xs: strm(x0)): strm_vt(x0)
fun
<x0:t0>
strq_filter_vt
{ln:i0}
(xs: strq(x0,ln)): strqlte_vt(x0,ln)
//
#symload filter with strm_filter of 1000
#symload filter with strq_filter of 1000
#symload filter_vt with strm_filter_vt of 1000
#symload filter_vt with strq_filter_vt of 1000
//
(* ****** ****** *)
//
fun
<x0:t0>
strm_ifilter
(xs: strm(x0)): strm(x0)
fun
<x0:t0>
strq_ifilter
{ln:i0}
(xs: strq(x0,ln)): strqlte(x0,ln)
//
fun
<x0:t0>
strm_ifilter_vt
(xs: strm(x0)): strm_vt(x0)
fun
<x0:t0>
strq_ifilter_vt
{ln:i0}
(xs: strq(x0,ln)): strqlte_vt(x0,ln)
//
#symload ifilter with strm_ifilter of 1000
#symload ifilter with strq_ifilter of 1000
#symload ifilter_vt with strm_ifilter_vt of 1000
#symload ifilter_vt with strq_ifilter_vt of 1000
//
(* ****** ****** *)
//
fun
<x0:t0>
strm_filter$f1un
( xs: strm(x0)
, test: (!x0) -> bool): strm(x0)
#symload filter with strm_filter$f1un of 1000
#symload filter$fun with strm_filter$f1un of 1000
#symload strm_filter with strm_filter$f1un of 1000
//
fun
<x0:t0>
strm_ifilter$f2un
( xs: strm(x0)
, test: (ni,!x0) -> bool): strm(x0)
#symload ifilter with strm_ifilter$f2un of 1000
#symload ifilter$fun with strm_ifilter$f2un of 1000
#symload strm_ifilter with strm_ifilter$f2un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:t0>
strm_strmize
(xs: strm(x0)): strm_vt(x0)
fun
<x0:t0>
strq_strqize
{n0:i0}
(xs: strq(x0,n0)): strq_vt(x0,n0)
//
#symload strmize with strm_strmize of 1000
#symload strqize with strq_strqize of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<x0:t0>
strm_listize
(xs: strm(x0)): list_vt(x0)
fun
<x0:t0>
strq_listize
{n0:i0}
(xs: strq(x0,n0)): list_vt(x0,n0)
//
fun
<x0:t0>
strm_rlistize
(xs: strm(x0)): list_vt(x0)
fun
<x0:t0>
strq_rlistize
{n0:i0}
(xs: strq(x0,n0)): list_vt(x0,n0)
//
#symload listize with strm_listize of 1000
#symload listize with strq_listize of 1000
#symload rlistize with strm_rlistize of 1000
#symload rlistize with strq_rlistize of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-21:
Sun Dec 21 12:17:23 AM EST 2025
*)
//
fun
<x0:t0>
<y0:t0>
<e1:vt>
strm_map$e0nv
(xs: strm(x0), e1: ~e1): strm(y0)
fun
<x0:t0>
<y0:t0>
<e1:vt>
strm_map$e1nv
(xs: strm(x0), e1: !e1): strm(y0)
//
fun
<x0:t0>
<y0:t0>
<e1:vt>
strm_map$e0nv_vt
(xs: strm(x0), e1: ~e1): strm_vt(y0)
fun
<x0:t0>
<y0:t0>
<e1:vt>
strm_map$e1nv_vt
(xs: strm(x0), e1: !e1): strm_vt(y0)
//
fun
<x0:t0>
<y0:t0>
<e1:vt>
strq_map$e0nv
{ln:i0}
(xs: strq(x0,ln), e1: ~e1): strq(y0,ln)
fun
<x0:t0>
<y0:t0>
<e1:vt>
strq_map$e1nv
{ln:i0}
(xs: strq(x0,ln), e1: !e1): strq(y0,ln)
//
fun
<x0:t0>
<y0:t0>
<e1:vt>
strq_map$e0nv_vt
{ln:i0}
(xs: strq(x0,ln), e1: ~e1): strq_vt(y0,ln)
fun
<x0:t0>
<y0:t0>
<e1:vt>
strq_map$e1nv_vt
{ln:i0}
(xs: strq(x0,ln), e1: !e1): strq_vt(y0,ln)
//
#symload map$e0nv with strm_map$e0nv of 1000
#symload map$e1nv with strm_map$e1nv of 1000
#symload map$e1nv with strq_map$e0nv of 1000
#symload map$e1nv with strq_map$e1nv of 1000
#symload map$e0nv_vt with strm_map$e0nv_vt of 1000
#symload map$e1nv_vt with strm_map$e1nv_vt of 1000
#symload map$e1nv_vt with strq_map$e0nv_vt of 1000
#symload map$e1nv_vt with strq_map$e1nv_vt of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_strm001.sats] *)
(***********************************************************************)
`,
  "SATS/strn000.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon 08 Jul 2024 09:12:42 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#sortdef c0 = char
#typedef cgtz =
[c:c0 | c > 0] char(c)
//
#typedef
strnlst = list(strn)
#typedef
strnopt = optn(strn)
//
#vwtpdef
strnllst = list_vt(strn)
#vwtpdef
strnlopt = optn_vt(strn)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
strn_nilq
 {n:i0}
(cs: strn(n)): bool(n=0)
fun<>
strn_consq
 {n:i0}
(cs: strn(n)): bool(n>0)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
strn_lt
(xs:strn, ys:strn): bool
fun<>
strn_gt
(xs:strn, ys:strn): bool
fun<>
strn_eq
(xs:strn, ys:strn): bool
fun<>
strn_lte
(xs:strn, ys:strn): bool
fun<>
strn_gte
(xs:strn, ys:strn): bool
fun<>
strn_neq
(xs:strn, ys:strn): bool
//
#symload < with strn_lt of 1000
#symload > with strn_gt of 1000
#symload = with strn_eq of 1000
#symload <= with strn_lte of 1000
#symload >= with strn_gte of 1000
#symload != with strn_neq of 1000
//
(* ****** ****** *)
//
fun<>
strn_cmp
( xs: strn
, ys: strn): sint(*sign*)
#symload
cmp with strn_cmp of 1000
//
(*
fun<>
strn_compare // = strn_cmp
(x:strn, y:strn): sint(*sign*)
#symload
compare with strn_compare of 1000
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-17:
Note strn_print may not
be the same as g_print<strn>
*)
fun<>
strn_print(strn): void
//
#symload
pstrn with strn_print of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
strn_length
{n0:i0}
(cs: strn(n0)): sint(n0)
//
#symload
length with strn_length of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
strn_get$at
(cs: strn, i0: nint): cgtz
fun<>
strn_fset$at
(cs: strn
,i0: nint, c0: cgtz): strn
//
(*
HX-2024-08-16:
Plz see [unsfx00.sats]:
fun<>
UN_strn_get$at$raw
(cs: strn, i0: nint): cgtz
fun<>
UN_strn_fset$at$raw
( cs: strn
, i0: nint, c0: cgtz): strn
*)
//
#symload
[] with strn_get$at of 1000
#symload
get$at with strn_get$at of 1000
#symload
fset$at with strn_fset$at of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-11:
The 'g' in 'gmake' means
that the argument, which is
the subject here, is polymorphic.
*)
fun
<a:vt>
strn_gmake(x: (~a)): strn
fun
<a:vt>
strn_gmake1(x: (!a)): strn
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
strn_lower
{ln:i0}(strn(ln)): strn(ln)
fun<>
strn_upper
{ln:i0}(strn(ln)): strn(ln)
//
#symload
lower with strn_lower of 1000
#symload
upper with strn_upper of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
strn_slice
{n0:i0}
{i0:nat
;j0:int
|i0<=j0
;j0<=n0}
( cs: strn(n0)
, i0: sint(i0)
, j0: sint(j0)): strn(j0-i0)
#symload
slice with strn_slice of 1000
//
fun<>
strn_prefix
{n0:i0}
{i0:nat
|i0<=n0}
( cs: strn(n0)
, i0: sint(i0)): strn(i0)
#symload
prefix with strn_prefix of 1000
//
fun<>
strn_suffix
{n0:i0}
{i0:nat
|i0<=n0}
( cs: strn(n0)
, i0: sint(i0)): strn(n0-i0)
#symload
suffix with strn_suffix of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
strn_make_1val
(c0: cgtz): strn(1)
//
fun<>
strn_make_2val
(c0: cgtz, c1: cgtz): strn(2)
fun<>
strn_make_3val
( c0: cgtz
, c1: cgtz, c2: cgtz): strn(3)
//
#symload
strn with strn_make_1val of 1000
#symload
strn with strn_make_2val of 1000
#symload
strn with strn_make_3val of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
strn_make_ncpy
{n0:i0}
(n0:nint(n0),ch:cgtz): strn(n0)
#symload
strn with strn_make_ncpy of 1000
//
fun<>
strn_make_nfun
{n0:i0}
(n0:nint(n0)
,f0:nintlt(n0)->cgtz): strn(n0)
#symload
strn with strn_make_nfun of 1000
//
(* ****** ****** *)
//
fun
<cs:t0>
strn_make_gseq(cs: cs): strn
//
fun
<xs:t0>
<x0:t0>
// HX: map$fopr(x0):cgtz
strn_map$make_gseq(xs: xs): strn
//
(* ****** ****** *)
//
fun<>
strn_make_list
{n0:i0}
(cs: list(cgtz, n0)): strn(n0)
#symload
strn with strn_make_list of 1000
//
(* ****** ****** *)
//
fun<>
strn_make_llist
{n0:i0}
(cs: ~list_vt(cgtz,n0)): strn(n0)
#symload
strn with strn_make_llist of 1000
//
(* ****** ****** *)
//
fun<>
strn_make_lstrm
(cs: ~strm_vt(cgtz)): strn(*sz*)
fun<>
strn_make_lstrq
{n0:i0}
(cs: ~strq_vt(cgtz,n0)): strn(n0)
//
#symload
strn with strn_make_lstrm of 1000
#symload
strn with strn_make_lstrq of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-30:
[make] is [make0...0]
[make1] is [make1...0]
In general, [make0] is skipped.
*)
fun<>
strn_make1_llist
{ln:i0}
(
cs: !list_vt(cgtz, ln)): strn( ln )
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
strn_append
{m0,n0:i0}
( xs: strn(m0)
, ys: strn(n0)): strn(m0+n0)
#symload + with strn_append of 1000
#symload append with strn_append of 1000
//
(* ****** ****** *)
//
fun<>
strn_reverse
{n0:i0}
( cs: strn(n0)): strn(n0)
#symload reverse with strn_reverse of 1000
fun<> // HX-2024-08-17: is
strn_rappend // this one really useful?
{m0,n0:i0}
( xs: strn(m0)
, ys: strn(n0)): strn(m0+n0)
#symload rappend with strn_rappend of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fcast // fun
GSEQ_make_strn
(xs: strn): GSEQ(strn, cgtz)
#symload GSEQ with GSEQ_make_strn of 1000
#symload GSEQ_strn with GSEQ_make_strn of 1000
//
fcast // fun
GASQ_make_strn
(xs: strn): GASQ(strn, cgtz)
#symload GASQ with GASQ_make_strn of 1000
#symload GASQ_strn with GASQ_make_strn of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_strn000.sats] *)
(***********************************************************************)
`,
  "SATS/strn001.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Fri 26 Jul 2024 09:17:44 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
strn_strmize
(cs: strn): strm_vt(cgtz)
fun<>
strn_strqize
{n0:i0}
(cs: strn(n0)): strq_vt(cgtz, n0)
//
fun<>
strn_rstrmize
(cs: strn): strm_vt(cgtz)
fun<>
strn_rstrqize
{n0:i0}
(cs: strn(n0)): strq_vt(cgtz, n0)
//
#symload strmize with strn_strmize of 1000
#symload strqize with strn_strqize of 1000
#symload rstrmize with strn_strmize of 1000
#symload rstrqize with strn_strqize of 1000
//
(* ****** ****** *)
//
fun<>
strn_listize
{n0:i0}
(cs: strn(n0)): list_vt(cgtz, n0)
fun<>
strn_rlistize
{n0:i0}
(cs: strn(n0)): list_vt(cgtz, n0)
//
#symload listize with strn_listize of 1000
#symload rlistize with strn_listize of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
strn_forall(cs: strn): bool
fun<>
strn_rforall(cs: strn): bool
fun<>
strn_iforall(cs: strn): bool
fun<>
strn_irforall(cs: strn): bool
//
#symload forall with strn_forall of 1000
#symload rforall with strn_rforall of 1000
#symload iforall with strn_iforall of 1000
#symload irforall with strn_irforall of 1000
//
(* ****** ****** *)
//
(*
HX-2024-08-16:
Fri 16 Aug 2024 05:08:22 PM EDT
*)
//
fun<>
strn_forall$f1un
(cs: strn, test: (cgtz)->bool): bool
#symload forall with strn_forall$f1un of 1000
//
fun<>
strn_rforall$f1un
(cs: strn, test: (cgtz)->bool): bool
#symload rforall with strn_rforall$f1un of 1000
//
fun<>
strn_iforall$f2un
(cs: strn, test: (ni,cgtz)->bool): bool
#symload iforall with strn_iforall$f2un of 1000
//
fun<>
strn_irforall$f2un
(cs: strn, test: (ni,cgtz)->bool): bool
#symload irforall with strn_irforall$f2un of 1000
//
(* ****** ****** *)
//
(*
HX-2024-08-07:
There is no need for
these special interfaces!
HX-2024-08-08:
However, they do support
symbol overloading nicely!
*)
//
fun<>
strn_foritm(cs: strn): void
fun<>
strn_rforitm(cs: strn): void
fun<>
strn_iforitm(cs: strn): void
fun<>
strn_irforitm(cs: strn): void
//
#symload foritm with strn_foritm of 1000
#symload rforitm with strn_rforitm of 1000
#symload iforitm with strn_iforitm of 1000
#symload irforitm with strn_irforitm of 1000
//
(* ****** ****** *)
//
(*
HX-2024-08-16:
Fri 16 Aug 2024 05:08:22 PM EDT
*)
//
fun<>
strn_foritm$f1un
(cs: strn, work: (cgtz)->void): void
#symload foritm with strn_foritm$f1un of 1000
//
fun<>
strn_rforitm$f1un
(cs: strn, work: (cgtz)->void): void
#symload rforitm with strn_rforitm$f1un of 1000
//
fun<>
strn_iforitm$f2un
(cs: strn, work: (ni,cgtz)->void): void
#symload iforitm with strn_iforitm$f2un of 1000
//
fun<>
strn_irforitm$f2un
(cs: strn, work: (ni,cgtz)->void): void
#symload irforitm with strn_irforitm$f2un of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-16:
Fri 16 Aug 2024 04:48:12 PM EDT
*)
//
(*
fun<>
strn_fmake((*void*)): strn
*)
fun<>
strn_fmake_fwork
(fwork: (cgtz->void)->void): strn//HX:3rd-order!
//
fun
<env:vt>
strn_fmake_env$fwork
( env: env
, fwork: (env, cgtz->void)->void): strn//HX:3rd-order!
fun
<env:vt>
strn_fmake1_env$fwork
( env: !env
, fwork: (!env, cgtz->void)->void): strn//HX:3rd-order!
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-17:
Sat 17 Aug 2024 12:27:46 PM EDT
*)
fun
<xs:t0>
gseq_strn$concat(xs: xs(*strnseq*)): strn
fun
<xs:t0>
gseq_strn$rconcat(xs: xs(*strnseq*)): strn
//
(*
#symload strn$concat with gseq_strn$concat of 0100
#symload strn$rconcat with gseq_strn$rconcat of 0100
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-05-08:
Thu May  8 02:16:02 PM EDT 2025
*)
//
fun<>
strm_vt_strn$concat0(xs: strm_vt(strn)): strn
#symload strn with strm_vt_strn$concat0 of 1000
#symload strn$concat0 with strm_vt_strn$concat0 of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_strn001.sats] *)
(***********************************************************************)
`,
  "SATS/strx000.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Wed May  7 08:13:08 AM EDT 2025
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_strx000.sats] *)
(***********************************************************************)
`,
  "SATS/strx001.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2025 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sun Dec 21 01:16:36 AM EST 2025
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_strx001.sats] *)
(***********************************************************************)
`,
  "SATS/tupl000.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
(*
** for flat tuples
** for boxd tuples
*)
(* ****** ****** *)
(* ****** ****** *)
(*
HX-2023-08-06:
@(...): flat tuple
#(...): boxd tuple
$tup(...): boxd tuple
(Change: $(...) -> #(...))
Sun Aug  6 19:45:40 EDT 2023
*)
(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(Around some time in 2022)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-04:
Copying over from [srcgen1]
Sun 04 Aug 2024 05:41:59 PM EDT
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-08:
$tuptx for $tup_t0//nonlin
$tupvx for $tup_vt//linear
$tuprf for $tup_rf//nonlin
Mon Dec  8 12:37:01 PM EST 2025
However, for back compatibility,
please make no use of the newly
introduced keywords in the prelude!
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#typedef
t0up1_t0
(a0: t0) = @(  a0  )
#vwtpdef
t0up1_vt
(a0: vt) = @(  a0  )
//
#typedef
t1up1_t0
(a0: t0) = $tup_t0(a0)
#vwtpdef
t1up1_vt
(a0: vt) = $tup_vt(a0)
//
#sexpdef t0up = t0up1_t0//(a0)
#sexpdef t1up = t1up1_t0//(a0)
#sexpdef t0up_vt = t0up1_vt//(a0)
#sexpdef t1up_vt = t1up1_vt//(a0)
//
(* ****** ****** *)
(* ****** ****** *)
//
#typedef
t0up2_t0
(a0:t0,a1:t0) = @(a0,a1)
#vwtpdef
t0up2_vt
(a0:vt,a1:vt) = @(a0,a1)
//
#typedef
t1up2_t0
(a0:t0,a1:t0) = $tup_t0(a0,a1)
#vwtpdef
t1up2_vt
(a0:vt,a1:vt) = $tup_vt(a0,a1)
//
#sexpdef t0up = t0up2_t0//(a0,a1)
#sexpdef t1up = t1up2_t0//(a0,a1)
#sexpdef t0up_vt = t0up2_vt//(a0,a1)
#sexpdef t1up_vt = t1up2_vt//(a0,a1)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-17:
*)
#typedef
t0up3_t0
(a0:t0
,a1:t0,a2:t0) = @(a0,a1,a2)
#vwtpdef
t0up3_vt
(a0:vt
,a1:vt,a2:vt) = @(a0,a1,a2)
//
#typedef
t1up3_t0
(a0:t0
,a1:t0,a2:t0) = $tup_t0(a0,a1,a2)
#vwtpdef
t1up3_vt
(a0:vt
,a1:vt,a2:vt) = $tup_vt(a0,a1,a2)
//
#sexpdef t0up = t0up3_t0//(a0,a1,a2)
#sexpdef t1up = t1up3_t0//(a0,a1,a2)
#sexpdef t0up_vt = t0up3_vt//(a0,a1,a2)
#sexpdef t1up_vt = t1up3_vt//(a0,a1,a2)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-18:
Sun 18 Aug 2024 09:16:41 PM EDT
*)
#typedef
t0up4_t0
(a0:t0,a1:t0
,a2:t0,a3:t0) = @(a0,a1,a2,a3)
#vwtpdef
t0up4_vt
(a0:vt,a1:vt
,a2:vt,a3:vt) = @(a0,a1,a2,a3)
//
#typedef
t1up4_t0
(a0:t0,a1:t0
,a2:t0,a3:t0) = $tup_t0(a0,a1,a2,a3)
#vwtpdef
t1up4_vt
(a0:vt,a1:vt
,a2:vt,a3:vt) = $tup_vt(a0,a1,a2,a3)
//
#sexpdef t0up = t0up4_t0//(a0,a1,a2,a3)
#sexpdef t1up = t1up4_t0//(a0,a1,a2,a3)
#sexpdef t0up_vt = t0up4_vt//(a0,a1,a2,a3)
#sexpdef t1up_vt = t1up4_vt//(a0,a1,a2,a3)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-18:
Sun 18 Aug 2024 09:17:01 PM EDT
*)
//
#typedef
t0up5_t0
(a0:t0
,a1:t0,a2:t0
,a3:t0,a4:t0) = @(a0,a1,a2,a3,a4)
#vwtpdef
t0up5_vt
(a0:vt
,a1:vt,a2:vt
,a3:vt,a4:vt) = @(a0,a1,a2,a3,a4)
//
#typedef
t1up5_t0
(a0:t0
,a1:t0,a2:t0
,a3:t0,a4:t0) = $tup_t0(a0,a1,a2,a3,a4)
#vwtpdef
t1up5_vt
(a0:vt
,a1:vt,a2:vt
,a3:vt,a4:vt) = $tup_vt(a0,a1,a2,a3,a4)
//
#sexpdef t0up = t0up5_t0//(a0,a1,a2,a3,a4)
#sexpdef t1up = t1up5_t0//(a0,a1,a2,a3,a4)
#sexpdef t0up_vt = t0up5_vt//(a0,a1,a2,a3,a4)
#sexpdef t1up_vt = t1up5_vt//(a0,a1,a2,a3,a4)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-08-18:
Sun 18 Aug 2024 09:17:01 PM EDT
*)
//
#typedef
t0up6_t0
(a0:t0,a1:t0
,a2:t0,a3:t0
,a4:t0,a5:t0) = @(a0,a1,a2,a3,a4,a5)
#vwtpdef
t0up6_vt
(a0:vt,a1:vt
,a2:vt,a3:vt
,a4:vt,a5:vt) = @(a0,a1,a2,a3,a4,a5)
//
#typedef
t1up6_t0
(a0:t0,a1:t0
,a2:t0,a3:t0
,a4:t0,a5:t0) = $tup_t0(a0,a1,a2,a3,a4,a5)
#vwtpdef
t1up6_vt
(a0:vt,a1:vt
,a2:vt,a3:vt
,a4:vt,a5:vt) = $tup_vt(a0,a1,a2,a3,a4,a5)
//
#sexpdef t0up = t0up6_t0//(a0,a1,a2,a3,a4,a5)
#sexpdef t1up = t1up6_t0//(a0,a1,a2,a3,a4,a5)
#sexpdef t0up_vt = t0up6_vt//(a0,a1,a2,a3,a4,a5)
#sexpdef t1up_vt = t1up6_vt//(a0,a1,a2,a3,a4,a5)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-07:
Sun Dec  7 11:31:34 PM EST 2025
*)
//
#typedef
t0up7_t0
(a0:t0
,a1:t0,a2:t0
,a3:t0,a4:t0
,a5:t0,a6:t0) = @(a0,a1,a2,a3,a4,a5,a6)
#vwtpdef
t0up7_vt
(a0:vt
,a1:vt,a2:vt
,a3:vt,a4:vt
,a5:vt,a6:vt) = @(a0,a1,a2,a3,a4,a5,a6)
//
#typedef
t1up7_t0
(a0:t0
,a1:t0,a2:t0
,a3:t0,a4:t0
,a5:t0,a6:t0) = $tup_t0(a0,a1,a2,a3,a4,a5,a6)
#vwtpdef
t1up7_vt
(a0:vt
,a1:vt,a2:vt
,a3:vt,a4:vt
,a5:vt,a6:vt) = $tup_vt(a0,a1,a2,a3,a4,a5,a6)
//
#sexpdef t0up = t0up7_t0//(a0,a1,a2,a3,a4,a5,a6)
#sexpdef t1up = t1up7_t0//(a0,a1,a2,a3,a4,a5,a6)
#sexpdef t0up_vt = t0up7_vt//(a0,a1,a2,a3,a4,a5,a6)
#sexpdef t1up_vt = t1up7_vt//(a0,a1,a2,a3,a4,a5,a6)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-07:
Sun Dec  7 11:58:15 PM EST 2025
*)
//
#typedef
t0up8_t0
(a0:t0,a1:t0
,a2:t0,a3:t0
,a4:t0,a5:t0
,a6:t0,a7:t0) = @(a0,a1,a2,a3,a4,a5,a6,a7)
#vwtpdef
t0up8_vt
(a0:vt,a1:vt
,a2:vt,a3:vt
,a4:vt,a5:vt
,a6:vt,a7:vt) = @(a0,a1,a2,a3,a4,a5,a6,a7)
//
#typedef
t1up8_t0
(a0:t0,a1:t0
,a2:t0,a3:t0
,a4:t0,a5:t0
,a6:t0,a7:t0) = $tup_t0(a0,a1,a2,a3,a4,a5,a6,a7)
#vwtpdef
t1up8_vt
(a0:vt,a1:vt
,a2:vt,a3:vt
,a4:vt,a5:vt
,a6:vt,a7:vt) = $tup_vt(a0,a1,a2,a3,a4,a5,a6,a7)
//
#sexpdef t0up = t0up8_t0//(a0,a1,a2,a3,a4,a5,a6,a7)
#sexpdef t1up = t1up8_t0//(a0,a1,a2,a3,a4,a5,a6,a7)
#sexpdef t0up_vt = t0up8_vt//(a0,a1,a2,a3,a4,a5,a6,a7)
#sexpdef t1up_vt = t1up8_vt//(a0,a1,a2,a3,a4,a5,a6,a7)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-08:
Mon Dec  8 12:01:07 AM EST 2025
*)
//
#typedef
t0up9_t0
(a0:t0
,a1:t0,a2:t0
,a3:t0,a4:t0
,a5:t0,a6:t0
,a7:t0,a8:t0) = @(a0,a1,a2,a3,a4,a5,a6,a7,a8)
#vwtpdef
t0up9_vt
(a0:vt
,a1:vt,a2:vt
,a3:vt,a4:vt
,a5:vt,a6:vt
,a7:vt,a8:vt) = @(a0,a1,a2,a3,a4,a5,a6,a7,a8)
//
#typedef
t1up9_t0
(a0:t0
,a1:t0,a2:t0
,a3:t0,a4:t0
,a5:t0,a6:t0
,a7:t0,a8:t0) = $tup_t0(a0,a1,a2,a3,a4,a5,a6,a7,a8)
#vwtpdef
t1up9_vt
(a0:vt
,a1:vt,a2:vt
,a3:vt,a4:vt
,a5:vt,a6:vt
,a7:vt,a8:vt) = $tup_vt(a0,a1,a2,a3,a4,a5,a6,a7,a8)
//
#sexpdef t0up = t0up9_t0//(a0,a1,a2,a3,a4,a5,a6,a7,a8)
#sexpdef t1up = t1up9_t0//(a0,a1,a2,a3,a4,a5,a6,a7,a8)
#sexpdef t0up_vt = t0up9_vt//(a0,a1,a2,a3,a4,a5,a6,a7,a8)
#sexpdef t1up_vt = t1up9_vt//(a0,a1,a2,a3,a4,a5,a6,a7,a8)
//
(* ****** ****** *)
(* ****** ****** *)
//
//
(*
HX-2025-12-08:
Mon Dec  8 12:04:35 AM EST 2025
*)
//
#typedef
t0up10_t0
(a0:t0,a1:t0
,a2:t0,a3:t0
,a4:t0,a5:t0
,a6:t0,a7:t0
,a8:t0,a9:t0) = @(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9)
#vwtpdef
t0up10_vt
(a0:vt,a1:vt
,a2:vt,a3:vt
,a4:vt,a5:vt
,a6:vt,a7:vt
,a8:vt,a9:vt) = @(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9)
//
#typedef
t1up10_t0
(a0:t0,a1:t0
,a2:t0,a3:t0
,a4:t0,a5:t0
,a6:t0,a7:t0
,a8:t0,a9:t0) = $tup_t0(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9)
#vwtpdef
t1up10_vt
(a0:vt,a1:vt
,a2:vt,a3:vt
,a4:vt,a5:vt
,a6:vt,a7:vt
,a8:vt,a9:vt) = $tup_vt(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9)
//
#sexpdef t0up = t0up10_t0//(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9)
#sexpdef t1up = t1up10_t0//(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9)
#sexpdef t0up_vt = t0up10_vt//(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9)
#sexpdef t1up_vt = t1up10_vt//(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_tupl000.sats] *)
(***********************************************************************)
`,
  "SATS/unsfx00.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Mon 08 Jul 2024 02:15:16 AM EDT
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
// For casting of all sorts
//
(* ****** ****** *)
(* ****** ****** *)
//
fcast
detop0{a:t0}(dt: (?a)): (a)
fcast
detop1{a:vt}(dt: (?a)): (a)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
Mon Jul  4 17:58:26 EDT 2022
*)
//
fcast
delinear{a:vt}(dt: ( a)): ?!a
fcast//HX: it is safe!
datacopy{a:vt}(dt: (!a)): ?!a
fcast
enlinear{a:vt}(dt: (?!a)): (a)
//
(* ****** ****** *)
(* ****** ****** *)
//
fcast
castxy
{ax:t0}{ay:t0}(x0: ax): (ay)
fcast
castyx
{ay:t0}{ax:t0}(x0: ax): (ay)
//
(* ****** ****** *)
//
fcast
castxy0
{ax:vt}{ay:vt}(x0: ax): (ay)
fcast
castyx0
{ay:vt}{ax:vt}(x0: ax): (ay)
//
fcast
castxy1
{ax:vt}
{ay:vt}(x0: !ax):(owed(ay)|ay)
fcast
castyx1
{ay:vt}
{ax:vt}(x0: !ax):(owed(ay)|ay)
//
(* ****** ****** *)
//
(*
fcast
castlinxy{ax:vt}{ay:vt}(ax):(ay)
fcast
castlinyx{ay:vt}{ax:vt}(ax):(ay)
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<a:vt>
p1tr_get(p0: p1tr): (a)
fun
<a:vt>
p1tr_set(p0: p1tr, x0: a): void
fun
<a:vt>
p1tr_ret(p0: p1tr, x0: a): void
//
#symload ptr_get with p1tr_get of 1000
#symload ptr_set with p1tr_set of 1000
#symload ptr_ret with p1tr_ret of 1000
//
(* ****** ****** *)
//
fun
<a:vt>
p2tr_get(p0: p2tr(a)): (a)
fun
<a:vt>
p2tr_set(p0: p2tr(a), x0: a): void
fun
<a:vt>
p2tr_ret(p0: p2tr(a), x0: a): void
//
#symload ptr_get with p2tr_get of 1000
#symload ptr_set with p2tr_set of 1000
#symload ptr_ret with p2tr_ret of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2020-07-29:
const pointers are read-only
*)
//
fun
<a:vt>
cp1tr_get(cp: cp1tr): (a)
fun
<a:vt>
cp2tr_get(cp: cp2tr(a)): (a)
//
#symload cptr_get with cp1tr_get of 1000
#symload cptr_get with cp2tr_get of 1000
//
(* ****** ****** *)
//
fun
<a:t0>
p2tr_set_list_nil
(p2tr(?list(a))): void
fun
<a:t0>
p2tr_set_list_cons
(p0:p2tr(list(a)), x0: a): void
//
(*
fun
<a:t0>
p2tr_set_list_vt_nil
(p2tr(?list_vt(a))): void
fun
<a:t0>
p2tr_set_list_vt_cons
(p0:p2tr(list_vt(a)), x0: a): void
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX:
[i0] is assumed to be
less than the length of [xs]
*)
fun
<xs:t0>
<x0:t0>
gseq_get$at$raw
  (xs: xs, i0: ni): (x0)
//
fun
<xs:t0>
<x0:t0>
gseq_fset$at$raw
(xs: xs,i0: ni,x0: x0): (xs)
//
(* ****** ****** *)
//
(*
HX: |xs| > 0 is assumed
*)
fun
<xs:t0>
<x0:t0>
gseq_head$raw(xs): (x0)
fun
<xs:t0>
<x0:t0>
gseq_tail$raw(xs): (xs)
//
fun
<xs:t0>
<x0:t0>
gseq_uncons$raw(xs): @(x0, xs)
fun
<xs:t0>
<x0:t0>
gseq_unsnoc$raw(xs): @(xs, x0)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2024-07-26:
These should be
used with caution!!!
*)
fun
<xs:t0>
<x0:t0>
gasq_get$at$raw
(xs: xs, i0: ni): (x0)
fun
<xs:t0>
<x0:t0>
gasq_set$at$raw
(xs: xs, i0: ni, x0: x0): void
//
fun
<xs:t0>
<x0:vt>
gasq_cget$at$raw
( xs: xs, i0: ni): x0
fun
<xs:t0>
<x0:vt>
gasq_setf$at$raw
( xs: xs, i0: ni, x0: x0): void
//
fun
<xs:t0>
<x0:vt>
gasq_lget$at$raw
(xs: xs
,i0: ni): (owed(x0) | x0)
fun
<xs:t0>
<x0:vt>
gasq_lset$at$raw
(pf: owed(x0)
|xs: xs, i0: ni, x0: x0): void
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
strn_head$raw
( cs: strn ): cgtz
fun<>
strn_tail$raw
( cs: strn ): strn
//
fun<>
strn_get$at$raw
(cs:strn, i0:nint): cgtz
fun<>
strn_fset$at$raw
(cs:strn, i0:nint, c0:cgtz): strn
//
#symload
get$at$raw with strn_get$at$raw of 1000
#symload
fset$at$raw with strn_fset$at$raw of 1000
//
(* ****** ****** *)
(* ****** ****** *)
//
// HX-2024-07-30: it should not be loaded
#include "./VT/unsfx00_vt.sats" // elsewhere!
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_unsfx00.sats] *)
(***********************************************************************)
`,
  "SATS/uopt000.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2024 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
#abstype
uopt_t0_i0_t0
( a:t0,b:b0 ) <= @(a, sint)
#sexpdef uopt = uopt_t0_i0_t0
//
#typedef
uopt(a:t0) = [b:b0] uopt(a, b)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_SATS_uopt000.sats] *)
(***********************************************************************)
`,
  "almanac/DATS/.keeper": ``,
  "almanac/DATS/VT/pre2026_vt.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2026 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Wed Dec 31 12:25:51 PM EST 2025
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#include
"\\
prelude/\\
almanac/HATS/pre2026_sats.hats"
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-31:
Wed Dec 31 11:38:57 AM EST 2025
*)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_segmentize0_lstrm$llist
  (  xs  ) =
let
//
#vwtpdef rs = list_vt(x0)
//
#impltmp
map$fopr0<rs><rs> = list_vt_reverse0<x0>
in//let
strm_vt_map0<rs>(
gseq_segmentize0_lstrm$rllist<xs><x0>(xs))
end//let//end(gseq_segmentize0_lstrm$llist<xs><x0>)
//
(* ****** ****** *)
//
#impltmp
< xs:vt >
< x0:vt >
gseq_segmentize0_lstrm$rllist
  (  xs  ) =
let
val xs =
gseq_strmize0<xs><x0>(xs) in//let
(
  strm_vt_segmentize0_lstrm$rllist<x0>(xs))
end//let//end(gseq_segmentize0_lstrm$rllist<xs><x0>)
//
(* ****** ****** *)
//
#impltmp
< x0:vt >
strm_vt_segmentize0_lstrm$rllist
  (  xs  ) =
(
  auxmain(xs)) where
{
//
#vwtpdef xs = strm_vt(x0)
#vwtpdef rs = list_vt(x0)
//
fun
auxmain
( xs: xs): strm_vt(rs) =
$llazy(
auxloop(xs, list_vt_nil))
//
and
auxloop
( xs: xs
, rs: rs): strmcon_vt(rs) =
(
case+ !xs of
//
| ~
strmcon_vt_nil
 ( (*void*) ) =>
(
case+ rs of
| ~
list_vt_nil() =>
(
  strmcon_vt_nil())
| // !
list_vt_cons _ =>
(
  strmcon_vt_sing(rs)))
//
| ~
strmcon_vt_cons
 (  x1, xs  ) =>
(
if // if
segment$delim1<x0>(x1)
then
let
val () =
g_free<x0>(x1) in//let
(
  strmcon_vt_cons(rs, auxmain(xs)))
end//let//end-of-(then)
else
(
  auxloop(xs, list_vt_cons(x1, rs))))
)(*case+*)//end-of-[ auxloop(xs, rs) ]
//
}(*where*)//end(strm_vt_segmentize0_lstrm$rllist<x0>)
//
(* ****** ****** *)
//
#impltmp
<xs:vt>
<x0:vt>
gseq_segmentize0$f1un_lstrm$llist
  (xs, test) =
let
//
#impltmp
segment$delim1<x0> = test(*x0*)
//
in//let
(
  gseq_segmentize0_lstrm$llist<xs><x0>(xs))
end//let//end(gseq_segmentize0$f1un_lstrm$llist<xs><x0>)
//
#impltmp
<xs:vt>
<x0:vt>
gseq_segmentize0$f1un_lstrm$rllist
  (xs, test) =
let
//
#impltmp
segment$delim1<x0> = test(*x0*)
//
in//let
(
  gseq_segmentize0_lstrm$rllist<xs><x0>(xs))
end//let//end(gseq_segmentize0$f1un_lstrm$rllist<xs><x0>)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_almanac_DATS_VT_pre2026_vt.dats] *)
(***********************************************************************)
`,
  "almanac/DATS/pre2026.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2026 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
#staload UN =
"prelude/SATS/unsfx00.sats"
(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Thu Jan  1 09:54:41 PM EST 2026
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
#include
"\\
prelude/\\
almanac/HATS/pre2026_sats.hats"
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-05:
Mon Jan  5 03:06:12 PM EST 2026
*)
//
#impltmp
< xs:t0 >
gasq$seg_decd
(   xsii   ) =
$UN.castxy(    xsii    )
#impltmp
< xs:t0 >
gasq$seg_encd
(xs, lb, ub) =
(
  $UN.castxy(@(xs, lb, ub)))
//
(* ****** ****** *)
//
#impltmp
{ xs:t0
, x0:t0 }
$UN.gseq_head$raw
<gasq$seg(xs)><x0>
(      xsii      ) =
let
val
(xs, lb, ub) =
gasq$seg_decd<xs>(xsii) in//let
(
  $UN.gasq_get$at$raw<xs>(xs, lb)) end
//let//end-of-[$UN.gseq_head$raw<gasq$seg(xs)><x0>]
//
#impltmp
{ xs:t0
, x0:t0 }
$UN.gseq_tail$raw
<gasq$seg(xs)><x0>
(      xsii      ) =
let
val
(xs, lb, ub) =
gasq$seg_decd<xs>(xsii) in//let
(
  gasq$seg_encd<xs>(xs, lb+1, ub)) end
//let//end-of-[$UN.gseq_tail$raw<gasq$seg(xs)><x0>]
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2027-01-07:
Wed Jan  7 12:37:11 PM EST 2026
*)
//
#impltmp
<(*tmp*)>
nint_digitize
  (  n0  ) =
nint_base$digitize<>(n0, 10)
#impltmp
<(*tmp*)>
nint_rdigitize
  (  n0  ) =
nint_base$rdigitize<>(n0, 10)
//
#impltmp
<(*tmp*)>
nint_base$digitize
  (n0, b0) =
strm_vt_rlistize0<ni>
(
nint_base$rdigitize<>(n0, b0))
//
#impltmp
<(*tmp*)>
nint_base$rdigitize
  (n0, b0) =
(
  auxmain(n0)) where
{
//
fun
auxmain
(n0: nint):
strm_vt(nint) = $llazy
(
if // if
(n0 <= 0)
then strmcon_vt_nil(*0*) else
(
  strmcon_vt_cons(n0%b0, auxmain(n0/b0))))
//
}(*where*)//end-of-[nint_base$rdigitize<>(n0,b0)]
//
(* ****** ****** *)
(* ****** ****** *)
//
//
(*
HX-2026-01-12:
Given a sint i0,
sint_gte$strmize(i0)
yields: (i0, i0+1, i0+2, ...)
Mon Jan 12 01:30:34 AM EST 2026
*)
//
#impltmp
<(*tmp*)>
sint_lte$strmize =
fix
f0(i0) =>
$llazy(
strmcon_vt_cons(i0, f0(i0-1)))
#impltmp
<(*tmp*)>
sint_lte$strxize =
fix
f0(i0) =>
$llazy(
strxcon_vt_cons(i0, f0(i0-1)))
//
#impltmp
<(*tmp*)>
sint_gte$strmize =
fix
f0(i0) =>
$llazy(
strmcon_vt_cons(i0, f0(i0+1)))
#impltmp
<(*tmp*)>
sint_gte$strxize =
fix
f0(i0) =>
$llazy(
strxcon_vt_cons(i0, f0(i0+1)))
//
#impltmp
<(*tmp*)>
sint_btw$strmize
  ( sta, fin ) =
(
if (sta <= fin)
then auxup(sta) else auxdn(sta))
where
{
//
fun
auxup(i0) = $llazy
(
if i0 >= fin
then
strmcon_vt_nil() else
strmcon_vt_cons(i0, auxup(i0+1)))
//
fun
auxdn(i0) = $llazy
(
if i0 <= fin
then
strmcon_vt_nil() else
strmcon_vt_cons(i0, auxdn(i0-1)))
//
}(*where*)//end-of-[sint_btw$strmize(sta,fin)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_almanac_DATS_pre2026.dats] *)
(***********************************************************************)
`,
  "almanac/HATS/pre2026_dats.hats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2026 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Thu Jan  1 09:56:13 PM EST 2026
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-11: For FP
HX-2026-01-11: For LFP
*)
#staload
"./../DATS/pre2026.dats"
#staload
"./../DATS/VT/pre2026_vt.dats"
//
(* ****** ****** *)
(* ****** ****** *)
//
#staload
"./../pre2026/DATS/i1range.dats"
#staload
"./../pre2026/DATS/trec000.dats"
//
(* ****** ****** *)
(* ****** ****** *)
//
#staload
"./../pre2026/DATS/VT/trec000_vt.dats"
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_almanac_HATS_pre2026_dats.hats] *)
(***********************************************************************)
`,
  "almanac/HATS/pre2026_sats.hats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2026 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Thu Jan  1 11:21:42 AM EST 2026
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-11: For FP
HX-2026-01-11: For LFP
*)
#staload
"./../SATS/pre2026.sats"
#staload
"./../SATS/VT/pre2026_vt.sats"
//
(* ****** ****** *)
(* ****** ****** *)
//
#staload
"./../pre2026/SATS/i1range.sats"
#staload
"./../pre2026/SATS/trec000.sats"
//
(* ****** ****** *)
(* ****** ****** *)
//
#staload
"./../pre2026/SATS/VT/strm000_vt.sats"
#staload
"./../pre2026/SATS/VT/trec000_vt.sats"
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_almanac_HATS_pre2026_sats.hats] *)
(***********************************************************************)
`,
  "almanac/SATS/.keeper": ``,
  "almanac/SATS/VT/pre2026_vt.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2026 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Wed Dec 31 12:25:51 PM EST 2025
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2025-12-31:
Wed Dec 31 11:38:57 AM EST 2025
*)
//
fun
<x0:vt>
segment$delim1(x0: !x0): bool
//
(* ****** ****** *)
//
(*
HX-2025-12-31:
Wed Dec 31 11:38:57 AM EST 2025
*)
//
fun
<xs:vt>
<x0:vt>
gseq_segmentize0_lstrm$llist
  (xs: xs): strm_vt(list_vt(x0))
//
fun
<xs:vt>
<x0:vt>
gseq_segmentize0_lstrm$rllist
  (xs: xs): strm_vt(list_vt(x0))
fun
<x0:vt>
strm_vt_segmentize0_lstrm$rllist
  (xs: strm_vt(x0)): strm_vt(list_vt(x0))
//
fun
<xs:vt>
<x0:vt>
gseq_segmentize0$f1un_lstrm$llist
  (xs: xs, test: (!x0) -> bool): strm_vt(list_vt(x0))
//
fun
<xs:vt>
<x0:vt>
gseq_segmentize0$f1un_lstrm$rllist
  (xs: xs, test: (!x0) -> bool): strm_vt(list_vt(x0))
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_almanac_SATS_VT_pre2026_vt.sats] *)
(***********************************************************************)
`,
  "almanac/SATS/pre2026.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2026 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Wed Dec 31 12:25:51 PM EST 2025
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-05:
Mon Jan  5 03:06:12 PM EST 2026
*)
//
#typedef
gasq$seg_def
(  xs: t0  ) = (xs, nint, nint)
#abstype
gasq$seg_t0_t0
(  xs: t0  ) <= gasq$seg_def(xs)
//
#typedef
gasq$seg(xs: t0) = gasq$seg_t0_t0(xs)
//
(* ****** ****** *)
//
fun
<xs:t0>
gasq$seg_decd
(xsii: gasq$seg(xs)): @(xs, ni, ni)
fun
<xs:t0>
gasq$seg_encd
(xs: xs, lb: ni, ub: ni): gasq$seg(xs)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2027-01-07:
Wed Jan  7 12:37:11 PM EST 2026
*)
//
fun<>
nint_digitize(nint): list_vt(nint)
fun<>
nint_rdigitize(nint): strm_vt(nint)
//
(*
fun<>
nint_digitize'base((*0*)): sintgte(2)
*)
//
fun<>
nint_base$digitize
(n0: nint, b0: sintgte(2)): list_vt(nint)
fun<>
nint_base$rdigitize
(n0: nint, b0: sintgte(2)): strm_vt(nint)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-12:
For each given sint i0,
lte$strmize(i0)
yields: (i0, i0-1, i0-2, ...)
gte$strmize(i0)
yields: (i0, i0+1, i0+2, ...)
Mon Jan 12 01:30:34 AM EST 2026
*)
//
(*
HX: [start] is included
*)
//
fun<>
sint_lte$strmize
 (start: sint): strm_vt(sint)
fun<>
sint_gte$strmize
 (start: sint): strm_vt(sint)
//
fun<>
sint_lte$strxize
 (start: sint): strx_vt(sint)
fun<>
sint_gte$strxize
 (start: sint): strx_vt(sint)
//
(*
//
#symload
from$dn with sint_lte$strmize of 1000
#symload
sint_from$dn with sint_lte$strmize of 1000
//
#symload
from$up with sint_gte$strmize of 1000
#symload
sint_from$up with sint_gte$strmize of 1000
//
*)
//
(*
HX-2026-01-12:
[start] is excluded
[finish] is excluded
btw$strmize(0, 10) = (0, 1, ..., 9)
btw$strmize(10, 0) = (10, 9, ..., 1)
*)
fun<>
sint_btw$strmize
(start: sint, finish: sint): strm_vt(sint)
(*
#symload
from$to with sint_gte$strmize of 1000
#symload
sint_from$to with sint_gte$strmize of 1000
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_almanac_SATS_pre2026.sats] *)
(***********************************************************************)
`,
  "almanac/pre2026/DATS/VT/trec000_vt.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2026 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Thu Jan 15 10:31:07 AM EST 2026
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#staload
"./../../SATS/VT/trec000_vt.sats"
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<
state:vt>
g_state$updts1
  ( st0 ) =
let
//
val sts =
(
  auxloop(st0))
//
#impltmp
search$test1
< bool >( btf ) = (btf)
//
in//let
g_void(
strx_vt_search0<bool>(sts))
end where // end-of-(let...)
{
//
fun
auxloop
( st0
: !state)
: strx_vt(bool) = $llazy
let
//
val () =
(
  state$updts$updt1<state>(st0))
val btf =
(
  state$updts$test1<state>(st0))
//
in//let
(
  strxcon_vt_cons(btf, auxloop(st0)))
end//let//end-of-[auxloop(st0:!state)]
//
}(*where*)//end-of-[g_state$updts1<state>(st0)]
//
(* ****** ****** *)
(* ****** ****** *)
//
//
#impltmp
<
state:vt>
g_state$updts1x
  ( st0 ) =
let
//
val sts =
(
  auxloop(st0))
//
#impltmp
search$test1
< bool >( btf ) = (btf)
//
in//let
g_void(
strx_vt_search0<bool>(sts))
end where // end-of-(let...)
{
//
fun
auxloop
( st0
: &state)
: strx_vt(bool) = $llazy
let
//
val () =
(
  state$updts$updt1x<state>(st0))
val btf =
(
  state$updts$test1x<state>(st0))
//
in//let
(
  strxcon_vt_cons(btf, auxloop(st0)))
end//let//end-of-[auxloop(st0:&state)]
//
}(*where*)//end-of-[g_state$updts1x<state>(st0)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_almanac_pre2026_DATS_VT_trec000_vt.dats] *)
(***********************************************************************)
`,
  "almanac/pre2026/DATS/i1range.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2026 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sun Jan 11 03:53:42 PM EST 2026
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#staload
"./../SATS/i1range.sats"
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
g_ptype
<i1range>() = pstrn"i1range"
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
i1range_make_lbub
  (lb, ub) =
(
  i1range_encd@(lb, ub))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
i1range_lb$get
  (range) =
let
val (lb, ub) =
i1range_decd(range) in lb end
//
#impltmp
<(*tmp*)>
i1range_ub$get
  (range) =
let
val (lb, ub) =
i1range_decd(range) in ub end
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
g_print
<i1range>
( range ) =
(
pstrn"i1range(";
g_print<sint>(lb);pstrn",";
g_print<sint>(ub);pstrn")")
where
{
val
(lb, ub) = i1range_decd(range)
}(*where*)//end(g_print<i1range>)
//
(* ****** ****** *)
//
#impltmp
gasq_length
<i1range><si> = i1range_length<>
#impltmp
gseq_length
<i1range><si> = i1range_length<>
//
#impltmp
<(*tmp*)>
i1rangelength
(    range    ) =
(
if
(lb >= ub)
then (0) else (ub - lb))
where
{
val (lb, ub) = i1range_decd(range)
}(*where*)//endof(i1range_length<>(...))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
gasq_forall
<i1range><sint> = i1range_forall<>
#impltmp
gseq_forall
<i1range><sint> = i1range_forall<>
//
#impltmp
<(*tmp*)>
i1range_forall
(    range    ) =
(
  auxloop(lb, ub)) where
{
//
val
(lb, ub) = i1range_decd(range)
//
fun
auxloop
( lb: si
, ub: si): bool =
if
(lb >= ub)
then (true) else
(
if
forall$test<si>(lb)
then
(
  auxloop(lb+1, ub)) else false)
//
}(*where*)//endof(i1range_forall<>(...))
//
(* ****** ****** *)
//
#impltmp
gseq_rforall
<i1range><sint> = i1range_rforall<>
#impltmp
gasq_rforall
<i1range><sint> = i1range_rforall<>
//
#impltmp
<(*tmp*)>
i1range_rforall
(    range    ) =
(
if
(lb < ub)
then
auxloop
(lb, ub-1) else true)
where
{
//
val
(lb, ub) =
(
  i1range_decd(range))
//
fun
auxloop
( lb: si
, ub: si): bool = // lb <= ub
(
if
rforall$test<si>(ub)
then
(
if
(lb < ub)
then
auxloop
(lb, ub-1) else true) else false)
//
}(*where*)//endof(i1range_rforall<>(...))
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
gseq_strmize
<i1range><sint> = i1range_strmize<>
//
#impltmp
<(*tmp*)>
i1range_strmize
(    range    ) =
(
  auxmain(lb, ub))
where
{
//
val
(lb, ub) = i1range_decd(range)
//
fun
auxmain
( lb: si
, ub: si)
: strm_vt(si) = $llazy
(
if lb >= ub
then strmcon_vt_nil() else
strmcon_vt_cons(lb, auxmain(lb+1, ub)))
//
}(*where*)//end-of-[i1range_strmize<>(...)]
//
(* ****** ****** *)
//
#impltmp
gseq_rstrmize
<i1range><sint> = i1range_rstrmize<>
//
#impltmp
<(*tmp*)>
i1range_rstrmize
(    range    ) =
(
  auxmain(lb, ub))
where
{
//
val
(lb, ub) = i1range_decd(range)
//
fun
auxmain
( lb: si
, ub: si)
: strm_vt(si) = $llazy
(
if ub <= lb
then strmcon_vt_nil() else
strmcon_vt_cons(ub-1, auxmain(lb, ub-1)))
//
}(*where*)//end-of-[i1range_rstrmize<>(...)]
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<(*tmp*)>
list_make_i1range
  ( range ) =
list_vt2t(
list_vt_make_i1range<>(range))
//
#impltmp
<(*tmp*)>
list_vt_make_i1range
  ( range ) =
(
strm_vt_listize0(
  strm_vt_make_i1range(range)))
//
#impltmp
<(*tmp*)>
strm_vt_make_i1range
  ( range ) = i1range_strmize<>(range)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_almanac_pre2026_SATS_i1range.dats] *)
(***********************************************************************)
`,
  "almanac/pre2026/DATS/trec000.dats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2026 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Wed Jan 14 04:31:21 PM EST 2026
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
#staload
"./../SATS/trec000.sats"
//
(* ****** ****** *)
(* ****** ****** *)
//
#impltmp
<
state:t0>
g_state$trans
  ( st0 ) =
let
//
val sts =
(
  auxloop(st0))
//
#impltmp
search$test1<state> =
state$trans$test<state>
//
in//let
strx_vt_search0<state>(sts)
end where // end-of-(let...)
{
//
fun
auxloop
( st0
: state)
: strx_vt(state) = $llazy
let
val st1 =
(
state$trans$fupdt<state>(st0))
in//let
(
  strxcon_vt_cons(st0, auxloop(st1)))
end//let//end-of-[auxloop(st0)]
//
}(*where*)//end-of-[g_state$trans<state>(st0)]
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_almanac_pre2026_DATS_trec000.dats] *)
(***********************************************************************)
`,
  "almanac/pre2026/SATS/VT/strm000_vt.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2026 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Thu Jan 15 09:46:36 AM EST 2026
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-15: l/r = -1/1
Thu Jan 15 09:51:09 AM EST 2026
*)
fun<>
bidir$moves$dirget((*0*)): sint
fun
<x0:vt>
strm_vt_bidir$moves
(xs: strm_vt(x0)): strx_vt(optn_vt(x0))
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_almanac_pre2026_SATS_VT_strm000_vt.sats] *)
(***********************************************************************)
`,
  "almanac/pre2026/SATS/VT/trec000_vt.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2026 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Thu Jan 15 10:12:12 AM EST 2026
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<state:vt>
g_state$updts1(st0: !state): void
fun
<state:vt>
state$updts$test1(st1: !state): bool
fun
<state:vt>
state$updts$updt1(st1: !state): void
//
(* ****** ****** *)
(* ****** ****** *)
//
fun
<state:vt>
g_state$updts1x(st0: &state): void
fun
<state:vt>
state$updts$test1x(st1: &state): bool
fun
<state:vt>
state$updts$updt1x(st1: &state): (void)
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_almanac_pre2026_SATS_trec000.sats] *)
(***********************************************************************)
`,
  "almanac/pre2026/SATS/i1range.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2026 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Sun Jan 11 10:36:44 AM EST 2026
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-11:
i1range:
one-dimension int range
i1range(lb, ub)
stands for [lb, ub), that is,
left-inclusive and right-inclusive
*)
#abstype
i1range_t0 == (si, si)
#typedef i1range = i1range_t0
//
(*
HX-2026-01-11:
[i1ranges] is for
a list of *disjoint* intervals!
*)
#abstbox
i1ranges_t0 == lsrt(i1range)
#typedef i1ranges = i1ranges_t0
//
(* ****** ****** *)
(* ****** ****** *)
//
fcast
i1range_encd
(lbub: (sint, sint)): i1range
fcast
i1range_decd(i1range): (si, si)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
i1range_lb$get(i1range): sint
fun i1range_ub$get(i1range): sint
//
#symload lb with i1range_lb$get
#symload ub with i1range_ub$get
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
i1range_make_lbub
(lb: sint, ub: sint): i1range
//
#symload
range with i1range_make_lbub
#symload
i1range with i1range_make_lbub
//
(* ****** ****** *)
(* ****** ****** *)
fun<>
i1range_length(i1range): (nint)
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
i1range_get$at: gasq_get$at(i1range, si)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
i1range_forall: gseq_forall(i1range, si)
fun<>
i1range_rforall: gseq_rforall(i1range, si)
//
fun<>
i1range_strmize: gseq_strmize(i1range, si)
fun<>
i1range_rstrmize: gseq_strmize(i1range, si)
//
(* ****** ****** *)
(* ****** ****** *)
//
fun<>
list_make_i1range(i1range): list(si)
fun<>
list_vt_make_i1range(i1range): list_vt(si)
fun<>
strm_vt_make_i1range(i1range): strm_vt(si)
//
#symload list with list_make_i1range
#symload list_vt with list_vt_make_i1range
#symload strm_vt with strm_vt_make_i1range
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_almanac_pre2026_SATS_i1range.sats] *)
(***********************************************************************)
`,
  "almanac/pre2026/SATS/trec000.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2026 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
(*
Author: Hongwei Xi
(*
Wed Jan 14 04:14:03 PM EST 2026
*)
Authoremail: gmhwxiATgmailDOTcom
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-14:
Tail-recursion via
functional state transition
Wed Jan 14 06:44:37 PM EST 2026
*)
//
(* ****** ****** *)
(* ****** ****** *)
//
(*
HX-2026-01-15:
[g_state$trans] applies
[state$trans$fupdt] to a given
state ST0 repeatedly until a state
ST1 statisfying [state$trans$test]
is encountered; and it returns ST1.
Please find some code in the following
directory where [g_state$trans] is used to
perform "manual tail-recursion optimization":
XATSHOME/contrib/githwxi/pground/proj001@250424/misc011
*)
fun
<state:t0>
g_state$trans(st0: state): state
//
fun
<state:t0>
state$trans$test(st1: state): bool
fun
<state:t0>
state$trans$fupdt(st1: state): state
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_almanac_pre2026_SATS_trec000.sats] *)
(***********************************************************************)
`,
  "basics0.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                             3rd edition                             *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2018 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)
//
#define
XATSPACK="ATS-Xanadu@20220500"
(*
#define // HX: first start
XATSPACK="ATS-Xanadu@20180400"
#define // HX: more explicit
XATSPACK="ATS3-Xanadu@20220500"
*)
//
(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
//
// This one was
// there at the very beginning of ATS
//
(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)
//
// sort for true
//
(*
#abssort true
// [true] is built-in
*)
//
(* ****** ****** *)(* ****** ****** *)
//
// predicative sorts
//
(*
#abssort int0
// [int0] is built-in
#abssort addr
// [addr] is built-in
#abssort bool//tt,ff
// [bool] is built-in
#abssort char//[0,256)
// [char] is built-in
#abssort float
// [float] is built-in
#abssort string
// [string] is built-in
*)
//
(* ****** ****** *)(* ****** ****** *)
//
(*
#abssort real
// for handling reals
#abssort float
// for handling floats
#abssort string
// for handling strings
*)
//
(* ****** ****** *)(* ****** ****** *)
//
#sortdef i0 = int0
//
#sortdef a0 = addr
#sortdef b0 = bool
#sortdef c0 = char
//
#sortdef p0 = prop
(*
#sortdef pf = prop
*)
#sortdef pp = prop
#sortdef v0 = view
#sortdef vw = view
#sortdef t0 = type
#sortdef tx = tbox
(*
#sortdef x0 = tbox
*)
#sortdef vt = vwtp
#sortdef vx = vtbx
//
(* ****** ****** *)(* ****** ****** *)
#sortdef int = int0
(* ****** ****** *)(* ****** ****** *)
//
datasort
ints_sort =
|
ints_nil//of()
|
ints_cons of
(int, ints_sort)
//
#sortdef
ints = ints_sort // int-seqs
//
(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)
//
(*
t->1/f->0
*)
#stacst0
cast_b0_i0:(b0)->i0
(*
!0->t/=0->f
*)
#stacst0
cast_i0_b0:(i0)->b0
//
#sexpdef
b2i = cast_b0_i0 // overloading
#sexpdef
i2b = cast_i0_b0 // overloading
//
(* ****** ****** *)(* ****** ****** *)
//
#stacst0
tt_b0 : b0 // true
#stacst0
ff_b0 : b0 // false
//
#sexpdef tt = tt_b0 // overloading
#sexpdef ff = ff_b0 // overloading
//
(* ****** ****** *)(* ****** ****** *)
//
#stacst0
neg_b0:( b0 ) -> b0
#sexpdef ~ = neg_b0 // overloading
(*
#sexpdef neg = neg_b0 // overloading
*)
//
#stacst0
add_b0_b0:(b0,b0)->b0
#stacst0
mul_b0_b0:(b0,b0)->b0
//
#sexpdef + = add_b0_b0 // overloading
#sexpdef * = mul_b0_b0 // overloading
#sexpdef || = add_b0_b0 // overloading
#sexpdef && = mul_b0_b0 // overloading
(*
#sexpdef add = add_b0_b0 // overloading
#sexpdef mul = mul_b0_b0 // overloading
*)
//
(* ****** ****** *)(* ****** ****** *)
//
#stacst0
lt_b0_b0:(b0,b0)->b0
#stacst0
gt_b0_b0:(b0,b0)->b0
#stacst0
eq_b0_b0:(b0,b0)->b0
//
#stacst0
lte_b0_b0:(b0,b0)->b0
#stacst0
gte_b0_b0:(b0,b0)->b0
#stacst0
neq_b0_b0:(b0,b0)->b0
//
#sexpdef < = lt_b0_b0 // overloading
#sexpdef > = gt_b0_b0 // overloading
#sexpdef = = eq_b0_b0 // overloading
//
#sexpdef <= = lte_b0_b0 // overloading
#sexpdef >= = gte_b0_b0 // overloading
#sexpdef != = neq_b0_b0 // overloading
//
(* ****** ****** *)(* ****** ****** *)
//
#stacst0
lt_c0_c0:
(c0, c0) -> b0 // c0: [0, 256)
#stacst0
gt_c0_c0:
(c0, c0) -> b0 // c0: [0, 256)
#stacst0
eq_c0_c0:
(c0, c0) -> b0 // c0: [0, 256)
//
#stacst0
lte_c0_c0:
(c0, c0) -> b0 // c0: [0, 256)
#stacst0
gte_c0_c0:
(c0, c0) -> b0 // c0: [0, 256)
#stacst0
neq_c0_c0:
(c0, c0) -> b0 // c0: [0, 256)
//
#sexpdef < = lt_c0_c0 // overloading
#sexpdef > = gt_c0_c0 // overloading
#sexpdef = = eq_c0_c0 // overloading
//
#sexpdef <= = lte_c0_c0 // overloading
#sexpdef >= = gte_c0_c0 // overloading
#sexpdef != = neq_c0_c0 // overloading
//
(* ****** ****** *)(* ****** ****** *)
//
#stacst0
lt_c0_i0:
(c0, i0) -> b0 // c0: [0, 256)
#stacst0
gt_c0_i0:
(c0, i0) -> b0 // c0: [0, 256)
#stacst0
eq_c0_i0:
(c0, i0) -> b0 // c0: [0, 256)
//
#stacst0
lte_c0_i0:
(c0, i0) -> b0 // c0: [0, 256)
#stacst0
gte_c0_i0:
(c0, i0) -> b0 // c0: [0, 256)
#stacst0
neq_c0_i0:
(c0, i0) -> b0 // c0: [0, 256)
//
#sexpdef < = lt_c0_i0 // overloading
#sexpdef > = gt_c0_i0 // overloading
#sexpdef = = eq_c0_i0 // overloading
//
#sexpdef <= = lte_c0_i0 // overloading
#sexpdef >= = gte_c0_i0 // overloading
#sexpdef != = neq_c0_i0 // overloading
//
(* ****** ****** *)(* ****** ****** *)
//
#stacst0
neg_i0: i0 -> i0
#sexpdef - = neg_i0 // overloading
//
#stacst0
abs_i0: i0 -> i0
#sexpdef abs = abs_i0 // overloading
//
#stacst0
sgn_i0: i0 -> i0
#sexpdef sgn = sgn_i0 // overloading
//
(*
#stacst0
succ_i0: i0 -> i0 // +1
#stacst0
pred_i0: i0 -> i0 // -1
#sexpdef succ = succ_i0 // overloading
#sexpdef pred = pred_i0 // overloading
*)
//
(* ****** ****** *)(* ****** ****** *)
//
#stacst0
add_a0_i0: (a0, i0) -> a0
#stacst0
add_c0_i0: (c0, i0) -> c0
#stacst0
add_i0_i0: (i0, i0) -> i0
//
#stacst0
sub_a0_a0: (a0, a0) -> i0
#stacst0
sub_c0_c0: (c0, c0) -> i0
#stacst0
sub_i0_i0: (i0, i0) -> i0
//
#stacst0
mul_i0_i0: (i0, i0) -> i0
#stacst0
div_i0_i0: (i0, i0) -> i0
#stacst0
mod_i0_i0: (i0, i0) -> i0
//
#sexpdef + = add_a0_i0 // overloading
#sexpdef + = add_c0_i0 // overloading
#sexpdef + = add_i0_i0 // overloading
//
#sexpdef - = sub_a0_a0 // overloading
#sexpdef - = sub_c0_c0 // overloading
#sexpdef - = sub_i0_i0 // overloading
//
#sexpdef * = mul_i0_i0 // overloading
#sexpdef / = div_i0_i0 // overloading
#sexpdef % = mod_i0_i0 // overloading
//
(*
//
#sexpdef add = add_a0_i0 // overloading
#sexpdef add = add_c0_i0 // overloading
#sexpdef add = add_i0_i0 // overloading
//
*)
//
(*
#sexpdef sub = sub_a0_a0 // overloading
#sexpdef sub = sub_c0_c0 // overloading
#sexpdef sub = sub_i0_i0 // overloading
*)
//
(*
#sexpdef mul = mul_i0_i0 // overloading
#sexpdef div = div_i0_i0 // overloading
*)
//
#sexpdef mod = mod_i0_i0 // overloading
//
(* ****** ****** *)(* ****** ****** *)
//
#stacst0
lt_a0_a0: (a0, a0) -> b0
#stacst0
gt_a0_a0: (a0, a0) -> b0
#stacst0
gt_a0_i0: (a0, i0) -> b0
#stacst0
eq_a0_a0: (a0, a0) -> b0
#stacst0
eq_a0_i0: (a0, i0) -> b0
//
#stacst0
lte_a0_a0: (a0, a0) -> b0
#stacst0
gte_a0_a0: (a0, a0) -> b0
#stacst0
gte_a0_i0: (a0, i0) -> b0
#stacst0
neq_a0_a0: (a0, a0) -> b0
#stacst0
neq_a0_i0: (a0, i0) -> b0
//
#sexpdef < = lt_a0_a0 // overloading
#sexpdef > = gt_a0_a0 // overloading
#sexpdef > = gt_a0_i0 // overloading
#sexpdef = = eq_a0_a0 // overloading
#sexpdef = = eq_a0_i0 // overloading
//
#sexpdef <= = lte_a0_a0 // overloading
#sexpdef >= = gte_a0_a0 // overloading
#sexpdef >= = gte_a0_i0 // overloading
#sexpdef != = neq_a0_a0 // overloading
#sexpdef != = neq_a0_i0 // overloading
//
(* ****** ****** *)(* ****** ****** *)
//
#stacst0
lt_i0_i0: (i0, i0) -> b0
#stacst0
gt_i0_i0: (i0, i0) -> b0
#stacst0
eq_i0_i0: (i0, i0) -> b0
//
#stacst0
lte_i0_i0: (i0, i0) -> b0
#stacst0
gte_i0_i0: (i0, i0) -> b0
#stacst0
neq_i0_i0: (i0, i0) -> b0
//
#sexpdef < = lt_i0_i0 // overloading
#sexpdef > = gt_i0_i0 // overloading
#sexpdef = = eq_i0_i0 // overloading
//
#sexpdef <= = lte_i0_i0 // overloading
#sexpdef >= = gte_i0_i0 // overloading
#sexpdef != = neq_i0_i0 // overloading
//
(* ****** ****** *)(* ****** ****** *)
//
#sortdef n0 = {a:i0 | a >= 0}
//
(* ****** ****** *)(* ****** ****** *)
//
#sortdef neg = {a:i0 | a < 0}
#sortdef nat = {a:i0 | a >= 0}
#sortdef pos = {a:i0 | a >= 1}
//
(* ****** ****** *)(* ****** ****** *)
//
#sortdef agtz = {l:a0 | l > 0}
#sortdef agez = {l:a0 | l >= 0}
//
(* ****** ****** *)(* ****** ****** *)
//
#stacst0
sizeof_vt_i0: (vt) -> i0
#sexpdef
sz(a:vt) = sizeof_vt_i0(a)
#sexpdef
size(a:vt) = sizeof_vt_i0(a)
//
(* ****** ****** *)(* ****** ****** *)
//
(*
#stacst0
offset_vt_cs: (vt,cs) -> i0
#sexpdef
ofs(a:vt,l:cs) = offset_vt_cs(a,l)
*)
//
(* ****** ****** *)(* ****** ****** *)
//
// impredicative sorts
//
(*
#abssort prop // prop: for proofs
#abssort view // view: linear prop
*)
//
(*
#abssort type // unspecified size
#abssort tbox // tbox: of 1-word size
#abssort tflt // tflt: alias for type
*)
//
(*
#abssort vwtp // viewtype: linear type
#abssort vtbx // viewtbox: linear tbox
*)
(*
#abssort vtype // viewtype: linear type
#abssort vtbox // viewtbox: linear tbox
#abssort vtflt // viewtflt: linear tflt
*)
//
(* ****** ****** *)(* ****** ****** *)
//
#absvwtp
cbv0_v0_vt(a: v0) <= a
#absvwtp
cbv1_v0_vt(a: v0) <= a
//
#absvwtp
cbrf_vt_vt(a: vt) <= a
//
#sexpdef ~ = cbv0_v0_vt
#sexpdef ! = cbv1_v0_vt
#sexpdef & = cbrf_vt_vt
//
(* ****** ****** *)(* ****** ****** *)
//
#abstype
top0_vt_t0(a: vt) <= a
#abstype
top1_vt_t0(a: vt) <= a
//
#sexpdef ?  = top0_vt_t0
#sexpdef ?! = top1_vt_t0
//
(* ****** ****** *)(* ****** ****** *)
(*
//
HX-2023-07-18:
This is not working due
to the special use of (_)
//
#absvwtp
atx2_vt_vt_vt(a:vt,b:vt)<=a
#sexpdef >> = atx2_vt_vt_vt
*)
(* ****** ****** *)(* ****** ****** *)
#typedef
void = $extype("xats_void_t")
(* ****** ****** *)(* ****** ****** *)
#typedef
p0tr = $extbox("xats_p0tr_t")
(* ****** ****** *)(* ****** ****** *)
//
#typedef
p1tr_k = $extype("xats_p1tr_t")
#typedef
p2tr_k = $extype("xats_p2tr_t")
//
(* ****** ****** *)(* ****** ****** *)
//
#abstype
p1tr_tbox(a0) <= p1tr_k
#abstype
p2tr_tbox(vt,a0) <= p2tr_k
//
#typedef
p1tr0 = [l:a0] p1tr_tbox(l)
#typedef
p1tr1(l: a0) = p1tr_tbox(l)
//
#typedef
p2tr0
(a:vt) = [l:a0] p2tr_tbox(a, l)
#typedef
p2tr1
(a: vt, l: a0) = p2tr_tbox(a, l)
//
#typedef p1tr = p1tr0
#typedef p1tr(l:a0) = p1tr1(l)
#typedef p2tr(x:vt) = p2tr0(x)
#typedef p2tr(x:vt, l:a0) = p2tr1(x, l)
//
(* ****** ****** *)(* ****** ****** *)
//
#absview
p2at_view(vt,a0) // linprop
#viewdef
p2at0
(a:vt) = [l:a0] p2at_view(a, l)
#viewdef
p2at1
(a: vt, l: a0) = p2at_view(a, l)
//
#viewdef p2at(x:vt) = p2tr0(x)
#viewdef p2at(x:vt, l:a0) = p2tr1(x, l)
//
(* ****** ****** *)(* ****** ****** *)
//
#abstype
cp1tr_tbox
(l:a0) <= p1tr_k
#abstype
cp2tr_tbox
(x:vt, l:a0) <= p2tr_k
//
#typedef
cp1tr0 = [l:a0] cp1tr_tbox(l)
#typedef
cp1tr1(l: a0) = cp1tr_tbox(l)
//
#typedef
cp2tr0
(a:vt) = [l:a0] cp2tr_tbox(a, l)
#typedef
cp2tr1
(a: vt, l: a0) = cp2tr_tbox(a, l)
//
#typedef cp1tr = cp1tr0
#typedef cp1tr(l:a0) = cp1tr1(l)
#typedef cp2tr(x:vt) = cp2tr0(x)
#typedef cp2tr(x:vt, l:a0) = cp2tr1(x, l)
//
(* ****** ****** *)(* ****** ****** *)

#typedef
bool_k = $extype("xats_bool_t")
#typedef
char_k = $extype("xats_char_t")

#typedef
sint_k = $extype("xats_sint_t")
#typedef
uint_k = $extype("xats_uint_t")

#typedef
slint_k = $extype("xats_slint_t")
#typedef
ulint_k = $extype("xats_ulint_t")

#typedef
ssize_k = $extype("xats_ssize_t")
#typedef
usize_k = $extype("xats_usize_t")

#typedef
sllint_k = $extype("xats_sllint_t")
#typedef
ullint_k = $extype("xats_ullint_t")

(* ****** ****** *)(* ****** ****** *)
//
#abstype
bool_type(b0) <= bool_k
//
#typedef
bool0 =
[b:b0] bool_type(b)
#typedef
bool1(b:b0) = bool_type(b)
//
(* ****** ****** *)(* ****** ****** *)
//
#typedef
tbool = bool1(tt) // singleton
#typedef
fbool = bool1(ff) // singleton
//
#typedef bool = bool0
#typedef bool(b:b0) = bool1(b)
//
(* ****** ****** *)(* ****** ****** *)
//
#abstype
char_type(c0) <= char_k
//
#typedef
char0 =
[c:c0] char_type(c)
#typedef
char1(c:c0) = char_type(c)
//
#typedef char = char0
#typedef char(c:c0) = char1(c)
//
(* ****** ****** *)(* ****** ****** *)
//
#abstype
gint_type(a:t0,i0) <= (a)
//
#typedef
gint0(a:t0)=
[i:i0] gint_type(a(*k*), i)
//
#typedef
gint1 // HX: indexed int-type
(a:t0,i:i0) = gint_type(a, i)
//
(* ****** ****** *)(* ****** ****** *)
//
#typedef sint0 = gint0(sint_k)
#typedef uint0 = gint0(uint_k)
//
#typedef
sint1(i:i0) = gint1(sint_k, i)
#typedef
uint1(i:i0) = gint1(uint_k, i)
//
#typedef slint0 = gint0(slint_k)
#typedef ulint0 = gint0(ulint_k)
//
#typedef
slint1(i:i0) = gint1(slint_k, i)
#typedef
ulint1(i:i0) = gint1(ulint_k, i)
//
#typedef ssize0 = gint0(ssize_k)
#typedef usize0 = gint0(usize_k)
//
#typedef
ssize1(i:i0) = gint1(ssize_k, i)
#typedef
usize1(i:i0) = gint1(usize_k, i)
//
(* ****** ****** *)(* ****** ****** *)
//
#typedef sllint0 = gint0(sllint_k)
#typedef ullint0 = gint0(ullint_k)
//
#typedef
sllint1(i:i0) = gint1(sllint_k, i)
#typedef
ullint1(i:i0) = gint1(ullint_k, i)
//
(* ****** ****** *)(* ****** ****** *)
//
#typedef
gint(a:t0) = gint0(a)
#typedef
gint(a:t0,i:i0) = gint1(a, i)
//
(* ****** ****** *)(* ****** ****** *)
//
#typedef int = sint0
#typedef int(i:i0) = sint1(i)
#typedef sint = sint0
#typedef sint(i:i0) = sint1(i)
#typedef uint = uint0
#typedef uint(i:i0) = uint1(i)
//
#typedef lint = slint0
#typedef lint(i:i0) = slint1(i)
#typedef slint = slint0
#typedef slint(i:i0) = slint1(i)
#typedef ulint = ulint0
#typedef ulint(i:i0) = ulint1(i)
//
#typedef size = usize0
#typedef size(i:i0) = usize1(i)
#typedef usize = usize0
#typedef usize(i:i0) = usize1(i)
#typedef ssize = ssize0
#typedef ssize(i:i0) = ssize1(i)
//
#typedef llint = sllint0
#typedef llint(i:i0) = sllint1(i)
#typedef sllint = sllint0
#typedef sllint(i:i0) = sllint1(i)
#typedef ullint = ullint0
#typedef ullint(i:i0) = ullint1(i)
//
(* ****** ****** *)(* ****** ****** *)
//
#typedef
nint = [i:i0 | i >= 0] sint(i)
#typedef
nlint = [i:i0 | i >= 0] slint(i)
#typedef
nsize = [i:i0 | i >= 0] ssize(i)
#typedef
nllint = [i:i0 | i >= 0] sllint(i)
//
(* ****** ****** *)(* ****** ****** *)
#typedef
nint(n:i0) = [ n >= 0 ] sint(n)
#typedef
nlint(n:i0) = [ n >= 0 ] slint(n)
#typedef
nsize(n:i0) = [ n >= 0 ] ssize(n)
#typedef
nllint(n:i0) = [ n >= 0 ] sllint(n)
(* ****** ****** *)(* ****** ****** *)
//
#typedef
sintlt
(n:i0) = [i:i0 | i < n] sint(i)
#typedef
sintgt
(n:i0) = [i:i0 | i > n] sint(i)
#typedef
sintlte
(n:i0) = [i:i0 | i <= n] sint(i)
#typedef
sintgte
(n:i0) = [i:i0 | i >= n] sint(i)
//
#typedef
nintlt
(n:i0) = [i:nat | i < n] sint(i)
#typedef
nintlte
(n:i0) = [i:nat | i <= n] sint(i)
//
#typedef
sintbtw
(m:i0
,n:i0) = [i:i0 | m <= i; i < n] sint(i)
#typedef
sintbtwe
(m:i0
,n:i0) = [i:i0 | m <= i; i <= n] sint(i)
//
(* ****** ****** *)(* ****** ****** *)
//
#typedef
sizelt(n:i0) = [i:i0 | i < n] size(i)
#typedef
sizegt(n:i0) = [i:i0 | i > n] size(i)
#typedef
sizelte(n:i0) = [i:i0 | i <= n] size(i)
#typedef
sizegte(n:i0) = [i:i0 | i >= n] size(i)
//
#typedef
sizebtw
(m:i0
,n:i0) = [i:i0 | m <= i; i < n] size(i)
#typedef
sizebtwe
(m:i0
,n:i0) = [i:i0 | m <= i; i <= n] size(i)
//
(* ****** ****** *)(* ****** ****** *)

datatype
unit = unit of ()
datavwtp
unit_vt = unit_vt of ()

(* ****** ****** *)(* ****** ****** *)
//
datatype
optn_t0_i0_tx
(
  a:type+, bool ) =
| optn_nil(a, ff) of ()
| optn_cons(a, tt) of (a)
//
// end of [optn_t0_i0_tbox]
//
datavwtp
optn_vt_i0_vx
(
  a:vwtp+, bool ) =
| optn_vt_nil(a, ff) of ()
| optn_vt_cons(a, tt) of (a)
//
// end of [optn_vt_i0_vtbx]
//
(* ****** ****** *)(* ****** ****** *)
//
#sexpdef optn = optn_t0_i0_tx
//
#sexpdef loptn = optn_vt_i0_vx
#sexpdef optn_vt = optn_vt_i0_vx
//
(* ****** ****** *)(* ****** ****** *)
//
fcast
optn_vt2t
{a:t0}{b:b0}
(xs: optn_vt(a, b)): optn(a, b)
//
#symload vt2t with optn_vt2t of 1000
//
(* ****** ****** *)(* ****** ****** *)
//
(*
#symload nil with optn_nil
#symload cons with optn_cons
#symload nil with optn_vt_nil
#symload cons with optn_vt_cons
#symload lnil with optn_vt_nil
#symload lcons with optn_vt_cons
*)
(*
#symload none with optn_nil0
#symload some with optn_cons
#symload lnone with optn_vt_nil
#symload lsome with optn_vt_cons
*)
(*
#symload nil_vt with optn_vt_nil
#symload cons_vt with optn_vt_cons
#symload none_vt with optn_vt_nil
#symload some_vt with optn_vt_cons
*)
//
(* ****** ****** *)(* ****** ****** *)
//
#typedef
optn
(a:t0) = [b:b0] optn(a, b)
#typedef
optn0
(a:t0) = [b:b0] optn(a, b)
#typedef
optn1(a:t0,b:b0) = optn(a, b)
//
#vwtpdef
loptn
(a:vt) = [b:b0] loptn(a, b)
#vwtpdef
loptn0
(a:vt) = [b:b0] loptn(a, b)
#vwtpdef
loptn1(a:vt,b:b0) = loptn(a, b)
//
#vwtpdef
optn_vt
(a:vt) = [b:b0] optn_vt(a, b)
#vwtpdef
optn0_vt
(a:vt) = [b:b0] optn_vt(a, b)
#vwtpdef
optn1_vt(a:vt,b:b0) = optn_vt(a, b)
//
(* ****** ****** *)(* ****** ****** *)
//
// HX-2018-10-01:
//
datatype
list_t0_i0_tx
(
  a:type+, int(*len*) ) =
//
|
list_nil
(a, 0(*len*)) of ((*0*))//nil
//
|
{n:i0 | n >= 0}
list_cons
(a, n+1(*len*)) of
(a, list_t0_i0_tx(a, n))//cons
//
// end of [ list_t0_i0_tx(a,n) ]
//
datavwtp
list_vt_i0_vx
(
  a:vwtp+, int(*len*) ) =
//
|
list_vt_nil
(a, 0(*len*)) of ((*0*))//nil
//
|
{n:i0 | n >= 0}
list_vt_cons
(a, n+1(*len*)) of
(a, list_vt_i0_vx(a, n))//cons
//
// end of [ list_vt_i0_vx(a,n) ]
//
(* ****** ****** *)(* ****** ****** *)
//
#sexpdef list = list_t0_i0_tx
//
#sexpdef llist = list_vt_i0_vx
#sexpdef list_vt = list_vt_i0_vx
//
(* ****** ****** *)(* ****** ****** *)
//
fcast
list_vt2t
{a:t0}{n:i0}
(xs: list_vt(a, n)): list(a, n)
//
#symload vt2t with list_vt2t of 1000
//
(* ****** ****** *)(* ****** ****** *)
//
(*
#symload nil with list_nil
#symload cons with list_cons
*)
//
(*
#symload nil with list_vt_nil
#symload cons with list_vt_cons
#symload lnil with list_vt_nil
#symload lcons with list_vt_cons
#symload nil_vt with list_vt_nil
#symload cons_vt with list_vt_cons
*)
//
(* ****** ****** *)(* ****** ****** *)
//
#typedef
list(a:t0) = [n:i0] list(a, n)
//
#typedef
list0(a:t0) = [n:i0 | n >= 0] list(a, n)
#typedef
list1(a:t0) = [n:i0 | n >= 1] list(a, n)
//
#typedef
listlt
(a:t0, n:i0) = [i:nat | i < n] list(a, i)
#typedef
listgt
(a:t0, n:i0) = [k:int | k > n] list(a, k)
//
#typedef
listlte
(a:t0, n:i0) = [i:nat | i <= n] list(a, i)
#typedef
listgte
(a:t0, n:i0) = [k:int | k >= n] list(a, k)
//
#typedef
listbtw
( a:t0
, m:i0, n:i0) = [i:nat | m <= i; i < n] list(a, i)
#typedef
listbtwe
( a:t0
, m:i0, n:i0) = [i:nat | m <= i; i <= n] list(a, i)
//
(* ****** ****** *)(* ****** ****** *)
//
//
#vwtpdef
llist(a:vt) =
[n:i0] llist(a, n)
//
#vwtpdef
llist0(a:vt) =
[n:i0 | n >= 0] llist(a, n)
#vwtpdef
llist1(a:vt) =
[n:i0 | n >= 1] llist(a, n)
//
#vwtpdef
llistlt
(a:vt, n:i0) = [i:nat | i < n] llist(a, i)
#vwtpdef
llistgt
(a:vt, n:i0) = [k:int | k > n] llist(a, k)
#vwtpdef
llistlte
(a:vt, n:i0) = [i:nat | i <= n] llist(a, i)
#vwtpdef
llistgte
(a:vt, n:i0) = [k:int | k >= n] llist(a, k)
//
#vwtpdef
llistbtw
( a:vt
, m:i0, n:i0) = [i:i0 | m <= i; i < n] llist(a, i)
#vwtpdef
llistbtwe
( a:vt
, m:i0, n:i0) = [i:i0 | m <= i; i <= n] llist(a, i)
//
(* ****** ****** *)(* ****** ****** *)
//
#vwtpdef
list_vt(a:vt) =
[n:i0] list_vt(a, n)
//
#vwtpdef
list0_vt(a:vt) =
[n:i0 | n >= 0] list_vt(a, n)
#vwtpdef
list1_vt(a:vt) =
[n:i0 | n >= 1] list_vt(a, n)
//
#vwtpdef
listlt_vt
(a:vt, n:i0) = [i:nat | i < n] list_vt(a, i)
#vwtpdef
listgt_vt
(a:vt, n:i0) = [k:int | k > n] list_vt(a, k)
#vwtpdef
listlte_vt
(a:vt, n:i0) = [i:nat | i <= n] list_vt(a, i)
#vwtpdef
listgte_vt
(a:vt, n:i0) = [k:int | k >= n] list_vt(a, k)
//
#vwtpdef
listbtw_vt
( a:vt
, m:i0, n:i0) = [i:i0 | m <= i; i < n] list_vt(a, i)
#vwtpdef
listbtwe_vt
( a:vt
, m:i0, n:i0) = [i:i0 | m <= i; i <= n] list_vt(a, i)
//
(* ****** ****** *)(* ****** ****** *)
//
#typedef
sflt_k =
$extype("xats_sflt_t")
#typedef
dflt_k =
$extype("xats_dflt_t")
#typedef
ldflt_k =
$extype("xats_ldflt_t")
//
#abstype
gflt_type(a:t0) <= a
//
#typedef
sflt = gflt_type(sflt_k)
#typedef
dflt = gflt_type(dflt_k)
#typedef
ldflt = gflt_type(ldflt_k)
//
#typedef
gflt(a:t0) = gflt_type(a)
//
#typedef
float = sflt // single precision
#typedef
double = dflt // double precision
#typedef
ldouble = ldflt // double precision
//
(* ****** ****** *)(* ****** ****** *)
//
#abstype
string_i0_tx(n:i0) <= p0tr
#abstype
stropt_i0_tx(n:i0) <= p0tr
//
#typedef
string0 =
[n:i0] string_i0_tx(n)
#typedef
string1
(n:i0) = string_i0_tx( n )
//
#typedef
stropt0 =
[n:i0] stropt_i0_tx(n)
#typedef
stropt1
(n:i0) = stropt_i0_tx( n )
//
(* ****** ****** *)(* ****** ****** *)
//
#sexpdef strn = string0
#sexpdef strn = string1
//
#sexpdef strn0 = string0
#sexpdef strn1 = string1
//
#typedef string = string0
#typedef string(n:i0) = string1(n)
//
#typedef stropt = stropt0
#typedef stropt(n:i0) = stropt1(n)
//
(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)
//
#absvwtp
string_i0_vx(n:i0) <= p0tr
#absvwtp
stropt_i0_vx(n:i0) <= p0tr
#absvwtp
strtmp_i0_vx(n:i0) <= p0tr
//
#vwtpdef
string0_vt =
[n:i0] string_i0_vx(n)
#vwtpdef
string1_vt
(n:i0) = string_i0_vx( n )
//
#vwtpdef
stropt0_vt =
[n:i0] stropt_i0_vx(n)
#vwtpdef
stropt1_vt
(n:i0) = stropt_i0_vx( n )
//
#vwtpdef
strtmp0_vt =
[n: i0] strtmp_i0_vx(n)
#vwtpdef
strtmp1_vt
(n: i0) = strtmp_i0_vx( n )
//
(* ****** ****** *)(* ****** ****** *)
//
#sexpdef lstrn = string0_vt
#sexpdef lstrn = string1_vt
//
#sexpdef strn_vt = string0_vt
#sexpdef strn_vt = string1_vt
//
#vwtpdef string_vt = string0_vt
#vwtpdef string_vt(n:i0) = string1_vt(n)
//
(* ****** ****** *)(* ****** ****** *)
//
#vwtpdef lstropt = stropt0_vt
#vwtpdef lstropt(n:i0) = stropt1_vt(n)
//
#vwtpdef stropt_vt = stropt0_vt
#vwtpdef stropt_vt(n:i0) = stropt1_vt(n)
//
(* ****** ****** *)(* ****** ****** *)
//
#vwtpdef strtmp_vt = strtmp0_vt
#vwtpdef strtmp_vt(n:i0) = strtmp1_vt(n)
//
(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)
(*
//
// HX:
// For exceptions:
//
#absvwtp excptn_vt <= p0tr
//
*)
(* ****** ****** *)(* ****** ****** *)
//
#abstbox
lazy_t0_tx
(elt:type+) <= p0tr
#typedef
lazy(a:t0) = lazy_t0_tx(a)
//
#absvtbx
lazy_vt_vx
(elt:vwtp+) <= p0tr
#vwtpdef
lazy_vt(a:vt) = lazy_vt_vx(a)
//
(* ****** ****** *)(* ****** ****** *)
//
(*
fun
<a1:t0>
<a2:vt>
assign
(x1: &a1 >> a2, x2: a2): void
//
#symload := with assign of 00
//
fun
<a1:v0>
<a2:v0>
pfexch
(pf1: !a0>>a1, pf2: !a2>>a1): void
*)
//
(* ****** ****** *)(* ****** ****** *)
//
#absview
a0ptr_view(a:vt,l:a0)
#sexpdef @ = a0ptr_view
//
#absview
a1ptr_view(a:vt,l:a0,n:i0)
#sexpdef arrvw = a1ptr_view
//
(* ****** ****** *)(* ****** ****** *)
//
datatype
strmcon(a:type+) =
|strmcon_nil of ((*void*))
|strmcon_cons of (a, stream(a))
and//datatype
strxcon(a:type+) =
|strxcon_cons of (a, streax(a))
//
where
{
#typedef
stream(a:t0) = lazy(strmcon(a))
#typedef
streax(a:t0) = lazy(strxcon(a)) }
//(* where *) // [strmcon/strxcon]
//
(* ****** ****** *)(* ****** ****** *)
#sexpdef
strm(* (a,n) *) = stream(*(a,n)*)
#sexpdef
strx(* (a,n) *) = streax(*(a,n)*)
(* ****** ****** *)(* ****** ****** *)
//
datavwtp
strmcon_vt(a:vwtp+) =
|
strmcon_vt_nil of ((*void*))
|
strmcon_vt_cons of (a, stream_vt(a))
//
and//datavwtp
strxcon_vt(a:vwtp+) =
|
strxcon_vt_cons of (a, streax_vt(a))
//
where
{
//
#vwtpdef
stream_vt
( a: vt ) = lazy_vt( strmcon_vt(a) )
#vwtpdef
streax_vt
( a: vt ) = lazy_vt( strxcon_vt(a) )
//
} (*where*)//end-of-[strmcon/strxcon]
//
(* ****** ****** *)(* ****** ****** *)
//
#sexpdef
lstrm(*a:vt*) = stream_vt(* a:vt *)
#sexpdef
lstrx(*a:vt*) = streax_vt(* a:vt *)
//
#sexpdef
strm_vt(*a:vt*) = stream_vt(* a:vt *)
#sexpdef
strx_vt(*a:vt*) = streax_vt(* a:vt *)
//
(* ****** ****** *)(* ****** ****** *)
//
(*
#symload nil with strmcon_nil
#symload cons with strmcon_cons
#symload nil with strmcon_vt_nil
#symload cons with strmcon_vt_cons
#symload lnil with strmcon_vt_nil
#symload lcons with strmcon_vt_cons
#symload nil_vt with strmcon_vt_nil
#symload cons_vt with strmcon_vt_cons
*)
(*
#symload cons with strxcon_cons
#symload cons with strxcon_vt_cons
#symload lcons with strxcon_vt_cons
#symload cons_vt with strxcon_vt_cons
*)
//
(* ****** ****** *)(* ****** ****** *)
//
datatype
strqcon
(a:type+, int) =
|
strqcon_nil
( a, 0(*len*) ) of ((*void*))
|
{n:i0 | n >= 0}
strqcon_cons
( a, n+1(*len*) ) of (a, streaq(a,n))
where
{
#typedef
streaq(a:t0,n:i0) = lazy(strqcon(a,n))}
//
(* ****** ****** *)(* ****** ****** *)
//
datavwtp
strqcon_vt
(a:vwtp+, int) =
|
strqcon_vt_nil
( a, 0(*len*) ) of ((*void*))
|
{n:i0 | n >= 0}
strqcon_vt_cons
( a, n+1(*len*) ) of (a, streaq_vt(a,n))
where
{
#vwtpdef
streaq_vt
( a:vt,n:i0 ) = lazy_vt(strqcon_vt(a,n))
} (* where *)//end-of-[strqcon_vt(a, n)]
//
(* ****** ****** *)(* ****** ****** *)
//
(*
#symload nil with strqcon_nil
#symload cons with strqcon_cons
#symload nil with strqcon_vt_nil
#symload cons with strqcon_vt_cons
#symload lnil with strqcon_vt_nil
#symload lcons with strqcon_vt_cons
#symload nil_vt with strqcon_vt_nil
#symload cons_vt with strqcon_vt_cons
*)
//
(* ****** ****** *)(* ****** ****** *)
//
#sexpdef
strq(*a:t0,n:i0*) = streaq(*(a, n)*)
//
#sexpdef
lstrq(*a:vt,n:i0*) = streaq_vt(*(a, n)*)
#sexpdef
strq_vt(*a:vt,n:i0*) = streaq_vt(*(a, n)*)
//
(* ****** ****** *)(* ****** ****** *)
//
#typedef
strq(a:t0) = [n:i0] strq(a, n)
#typedef
strqcon(a:t0) = [n:i0] strqcon(a, n)
//
#vwtpdef
strq_vt(a:vt) = [n:i0] strq_vt(a, n)
#vwtpdef
strqcon_vt(a:vt) = [n:i0] strqcon_vt(a, n)
//
(* ****** ****** *)(* ****** ****** *)
//
#vwtpdef
strqlt
(a:t0, n:i0) = [i:nat | i < n] strq(a, i)
#vwtpdef
strqgt
(a:t0, n:i0) = [k:int | k > n] strq(a, k)
#vwtpdef
strqlte
(a:t0, n:i0) = [i:nat | i <= n] strq(a, i)
#vwtpdef
strqgte
(a:t0, n:i0) = [k:int | k >= n] strq(a, k)
//
(* ****** ****** *)(* ****** ****** *)
//
#vwtpdef
strqlt_vt
(a:vt, n:i0) = [i:nat | i < n] strq_vt(a, i)
#vwtpdef
strqgt_vt
(a:vt, n:i0) = [k:int | k > n] strq_vt(a, k)
#vwtpdef
strqlte_vt
(a:vt, n:i0) = [i:nat | i <= n] strq_vt(a, i)
#vwtpdef
strqgte_vt
(a:vt, n:i0) = [k:int | k >= n] strq_vt(a, k)
//
(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)
//
(*
HX-2024-07-13
*)
#typedef
ilist(a:t0) = list@(nint, a)
#typedef
istrm(a:t0) = strm@(nint, a)
#typedef
istrq(a:t0) = strq@(nint, a)
#typedef
ilist(a:t0,n:i0) = list(@(nintlt(n), a), n)
#typedef
istrq(a:t0,n:i0) = strq(@(nintlt(n), a), n)
//
#vwtpdef
ilist_vt(a:vt) = list_vt@(nint, a)
#vwtpdef
istrm_vt(a:vt) = strm_vt@(nint, a)
#vwtpdef
istrq_vt(a:vt) = strq_vt@(nint, a)
#vwtpdef
ilist_vt(a:v0,n:i0) = list_vt(@(nintlt(n), a), n)
#vwtpdef
istrq_vt(a:v0,n:i0) = strq_vt(@(nintlt(n), a), n)
//
(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)
//
(*
HX-2024-07-27:
Sat 27 Jul 2024 07:45:40 PM EDT
*)
//
#absview
owed_view(vt) // linprop
#sexpdef owed = owed_view
//
prfun
owed_t0_make
{a:t0}((*void*)): owed(a)
prfun
owed_t0_elim0
{a:t0}(pf: ~owed(a)): void
prfun
owed_vt_return0
{a:vt}(pf: ~owed(a), x0: a): void
//
#symload return0 with owed_vt_return0
//
(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)
//
(*
HX-2024-07-29:
Mon 29 Jul 2024 04:56:14 PM EDT
*)
//
fcast
t0_{a:t0}(a): ( a )
fcast
tx_{a:tx}(a): ( a )
fcast
vt_{a:vt}(a): ( a )
fcast
vx_{a:vx}(a): ( a )
//
fcast
fc_sflt(dflt): sflt
fcast
fc_dflt(dflt): dflt
fcast
fc_ldflt(ldflt): ldflt
//
fcast
fc_bool
{b:b0}(bool(b)): bool(b)
fcast
fc_char
{c:c0}(char(c)): char(c)
fcast
fc_sint
{i:i0}(sint(i)): sint(i)
//
fcast
fc_strn
{n:i0}(strn(n)): strn(n)
fcast
fc_strn_vt
{n:i0}(strn_vt(n)): strn_vt(n)
//
fcast
fc_list{a:t0}
{n:i0}(list(a, n)): list(a, n)
fcast
fc_list_vt{a:vt}
{n:i0}(list_vt(a, n)): list_vt(a, n)
//
(***********************************************************************)
(***********************************************************************)
//
(*
HX-2025-05-16:
Achtung!Achtung!Achtung!
Fri May 16 07:49:11 PM EDT 2025
The following declarations should NOT be used.
The very purpose of having them here is for bootstrapping ATS3!
*)
//
(***********************************************************************)
(***********************************************************************)
//
(* ****** ****** *)(* ****** ****** *)
//
// HX: singleton
// HX: 1-dimensional
// HX: 2-dimensional
//
(* ****** ****** *)(* ****** ****** *)
//
#abstbox
a0ref_vt_tx(elem:vwtp)
#typedef
a0ref(a:vt) = a0ref_vt_tx(a)
//
(* ****** ****** *)(* ****** ****** *)
//
#abstbox
a1ref_vt_i0_tx(elem:vt,ntot:i0)
#abstbox
a1rsz_vt_i0_x0(elem:vt, ntot:i0)
//
#typedef
a1ref(a:vt,n:i0) = a1ref_vt_i0_tx(a, n)
#typedef
a1rsz(a:vt,n:i0) = a1rsz_vt_i0_x0(a, n)
//
(* ****** ****** *)(* ****** ****** *)
//
#abstbox
a2ref_vt_i0_i0_tx(elem:vt,nrow:i0,ncol:i0)
#abstbox
a2rsz_vt_i0_i0_x0(elem:vt,nrow:i0,ncol:i0)
//
#typedef
a2ref(a:vt,m:i0,n:i0) = a2ref_vt_i0_i0_tx(a, m, n)
#typedef
a2rsz(a:vt,m:i0,n:i0) = a2rsz_vt_i0_i0_x0(a, m, n)
//
(* ****** ****** *)(* ****** ****** *)
//
#typedef
a1rsz(a:vt) = [n:i0] a1rsz(a, n)
#typedef
a2rsz(a:vt) = [m:i0;n:i0] a2rsz(a, m, n)
//
(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)
//
// HX: singleton
// HX: 1-dimensional
// HX: 2-dimensional
//
(* ****** ****** *)(* ****** ****** *)
//
#absvtbx
a0ptr_vt_vx(elem:vwtp)
//
#vwtpdef
a0ptr(a:vt) = a0ptr_vt_vx(a)
//
(* ****** ****** *)(* ****** ****** *)
//
#absvtbx
a1ptr_vt_i0_vx(elem:vt,ntot:i0)
#absvtbx
a1psz_vt_i0_vx(elem:vt,ntot:i0)
//
#vwtpdef
a1ptr(a:vt,n:i0) = a1ptr_vt_i0_vx(a, n)
#vwtpdef
a1psz(a:vt,n:i0) = a1psz_vt_i0_vx(a, n)
//
(* ****** ****** *)(* ****** ****** *)
//
#absvtbx
a2ptr_vt_i0_i0_vx(elem:vt,nrow:i0,ncol:i0)
#absvtbx
a2psz_vt_i0_i0_vx(elem:vt,nrow:i0,ncol:i0)
//
#vwtpdef a2ptr
(a:vt,m:i0,n:i0) = a2ptr_vt_i0_i0_vx(a,m,n)
#vwtpdef a2psz
(a:vt,m:i0,n:i0) = a2psz_vt_i0_i0_vx(a,m,n)
//
(* ****** ****** *)(* ****** ****** *)
//
#vwtpdef a1psz(a:vt) = [n:i0] a1psz(a, n)
#vwtpdef a2psz(a:vt) = [m:i0;n:i0] a2psz(a,m,n)
//
(* ****** ****** *)(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_basics0.sats] *)
(***********************************************************************)
`,
  "fixity0.sats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                             3rd edition                             *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2018 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
//
// This one was
// there at the very beginning of ATS
//
(* ****** ****** *)
//
(*
HX-2018-10:
fixity declarations
#include "prelude/xparam.hats"
*)
//
(* ****** ****** *)
//
#if
VERBOSE_FIXITY0
#then
#print \\
"Loading [fixity.sats] starts!\\n"
#endif // end of [VERBOSE_FIXITY0]
//
(* ****** ****** *)
//
(*
#infixl app of 70
*)
//
(* ****** ****** *)
//
(*
HX: ATS-specialty:
*)
//
#prefix
!  of 69 (*stadyn*)
(*
#prefix
~  of 69 (*static*)
*)
#prefix
&  of 69 (*stadyn*)
#prefix
?  of 69 (*static*)
#prefix
?! of 69 (*static*)
//
(* ****** ****** *)
//
#infixl + of 50 (*add*)
#infixl - of 50 (*sub*)
//
#infixl * of 60 (*mul*)
#infixl / of 60 (*div*)
#infixl % of 60 (*mod*)
//
(* ****** ****** *)
//
(*
HX-2015-08-04:
FORTRAN-notation
for exponentiation
*)
//
#infixr ** of 61 (* exp *)
//
(* ****** ****** *)
//
(*
HX: +1*2 = +(1*2)
HX: -1*2 = -(1*2)
*)
#prefix + of +(+1) (*uplus*)
#prefix - of -(+1) (*uminus*)
//
(* ****** ****** *)
(*
#infixl nadd nsub of 50
#infixl nmul ndiv nmod of 60
*)
(* ****** ****** *)
//
#prefix ~ of 51 // lnot(*neg*)
//
(* ****** ****** *)
//
#infixl & of 46 // land(*mul*)
#infixl ^ of 45 // lxor(*add*)
(*
HX-2023-12-30:
BAR(|) is special;
it is for separating
proofs from programs!
#infixl \\| of 45 // lor2(*add*)
*)
//
(*
#infixl asrn of 41
#infixl lsln lsrn of 41
*)
#infixl << of 41 // lsln
#infixl >> of 41 // asrn
#infixl >>> of 41 // lsrn
//
(* ****** ****** *)
//
#infixr @ of 40 (*flat*)
#prefix @ of 69 (*uflat*)
//
#infixr :: of 41 (* cons *)
#infixr ++ of 40 (* join *)
//
(* ****** ****** *)
//
#infix0 < <= of 40 (*lt/eq*)
#infix0 > >= of 40 (*gt/eq*)
#infix0 = != of 30 (*equal*)
//
#infix0 == !== of 30 (*eqref*)
//
(* ****** ****** *)
(*
#infix0
=== !=== of 30 // HX: for JS?
*)
(* ****** ****** *)
//
#infixl || of 20
#infixl && of ||(+1)
//
(* ****** ****** *)

#infixr -> of 10 (*funarrow*)

(* ****** ****** *)
//
#infix0 := of 0 // HX: assign
#infix0 :=> of 0 // HX: exassign
#infix0 :=: of 0 // HX: exchange
//
(*
#infix0 <-> of 0 // HX: exchange?
*)
//
(* ****** ****** *)

(*
#prefix ++ -- // HX: inc/dec
#prefix !++ --! // HX: getinc/decget
#infixr =++ --= // HX: setinc/decset
*)

(* ****** ****** *)

(*
#infix0
:+= :-= :*= :/= // x:=x+a, x:=x-a, ...
#infix0
:=+ :=- :=* :=/ // x:=a+x, x:=a-x, ...
*)

(* ****** ****** *)
//
#infixl
orelse of || // HX: short-cutting
#infixl
andalso of && // HX: short-cutting
//
(* ****** ****** *)

#prefix
$raise of 0 // raising an exception

(* ****** ****** *)
(*
#prefix
ignoret of 0 // ignoring a funcall return
*)
(* ****** ****** *)
//
#if
VERBOSE_FIXITY0
#then
#print \\
"Loading [fixity.sats] is done!\\n"
#endif // end of [VERBOSE_FIXITY0]
//
(* ****** ****** *)(* ****** ****** *)
(* ****** ****** *)(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_fixity0.sats] *)
(***********************************************************************)
`,
  "xparam0.hats": `(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                             3rd edition                             *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Xanadu - Unleashing the Potential of Types!
** Copyright (C) 2018 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(* ****** ****** *)
//
#define VERBOSE_FIXITY0 0
#define VERBOSE_PRELUDE 0
//
(* ****** ****** *)
(* ****** ****** *)
//
(***********************************************************************)
(* end of [ATS3/XANADU_prelude_xparam0.hats] *)
(***********************************************************************)
`,
};
